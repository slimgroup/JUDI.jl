<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Full-Waveform Inversion - Part 3: optimization · JUDI documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JUDI documentation</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../basics/">Getting Started</a></li><li><span class="tocitem">JUDI API</span><ul><li><a class="tocitem" href="../../abstract_vectors/">Abstract vectors</a></li><li><a class="tocitem" href="../../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../linear_operators/">Linear Operators</a></li><li><a class="tocitem" href="../../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../../io/">Input/Output</a></li><li><a class="tocitem" href="../../helper/">Helper Functions</a></li></ul></li><li><a class="tocitem" href="../../inversion/">Inversion</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../01_intro/">Introduction to JUDI</a></li><li><a class="tocitem" href="../02_fwi_example_NLopt/">FWI with Quasi-Newton methods from the NLopt library</a></li><li><a class="tocitem" href="../03_constrained_fwi/">FWI Example</a></li><li class="is-active"><a class="tocitem" href>Full-Waveform Inversion - Part 3: optimization</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Optimizing-the-FWI-objective-function"><span>Optimizing the FWI objective function</span></a></li><li><a class="tocitem" href="#Implementing-FWI-in-JUDI"><span>Implementing FWI in JUDI</span></a></li><li><a class="tocitem" href="#FWI-via-gradient-descent"><span>FWI via gradient descent</span></a></li><li><a class="tocitem" href="#FWI-via-the-Gauss–Newton-method"><span>FWI via the Gauss–Newton method</span></a></li><li><a class="tocitem" href="#Conclusions"><span>Conclusions</span></a></li><li><a class="tocitem" href="#Acknowledgments"><span>Acknowledgments</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../05_custom_misfit/">FWI with user provided misfit function</a></li><li><a class="tocitem" href="../06_automatic_differentiation/">Automatic differentiation with JUDI</a></li><li><a class="tocitem" href="../07_preconditionners/">Seismic preconditionners</a></li><li><a class="tocitem" href="../imaging_conditions/">Imaging conditions in JUDI</a></li><li><a class="tocitem" href="../quickstart/">Modeling and inversion with JUDI</a></li></ul></li><li><a class="tocitem" href="../../pysource/">Devito backend reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Full-Waveform Inversion - Part 3: optimization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Full-Waveform Inversion - Part 3: optimization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/JUDI.jl/blob/master/docs/src/tutorials/04_judi_leading_edge_tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h3 id="Geophysics-tutorial"><a class="docs-heading-anchor" href="#Geophysics-tutorial">Geophysics tutorial</a><a id="Geophysics-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Geophysics-tutorial" title="Permalink"></a></h3><h1 id="Full-Waveform-Inversion-Part-3:-optimization"><a class="docs-heading-anchor" href="#Full-Waveform-Inversion-Part-3:-optimization">Full-Waveform Inversion - Part 3: optimization</a><a id="Full-Waveform-Inversion-Part-3:-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Waveform-Inversion-Part-3:-optimization" title="Permalink"></a></h1><p>Philipp Witte&lt;sup&gt;1&lt;/sup&gt;*, Mathias Louboutin&lt;sup&gt;1&lt;/sup&gt;, Keegan Lensink&lt;sup&gt;1&lt;/sup&gt;, Michael Lange&lt;sup&gt;2&lt;/sup&gt;, Navjot Kukreja&lt;sup&gt;2&lt;/sup&gt;, Fabio Luporini&lt;sup&gt;2&lt;/sup&gt;, Gerard Gorman&lt;sup&gt;2&lt;/sup&gt;, and Felix J. Herrmann&lt;sup&gt;1,3&lt;/sup&gt;</p><p>&lt;sup&gt;1&lt;/sup&gt; Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia </p><p>&lt;sup&gt;2&lt;/sup&gt; Imperial College London, London, UK</p><p>&lt;sup&gt;3&lt;/sup&gt; now at Georgia Institute of Technology, USA </p><p>Corresponding author: pwitte.slim@gmail.com</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>This tutorial is the third part of a full-waveform inversion (FWI) tutorial series with a step-by-step walkthrough of setting up forward and adjoint wave equations and building a basic FWI inversion framework. For discretizing and solving wave equations, we use [Devito], a Python-based domain-specific language for automated generation of finite-difference code (Lange et al., 2016). The first two parts of this tutorial (Louboutin et al., 2017, 2018) demonstrated how to solve the acoustic wave equation for modeling seismic shot records and how to compute the gradient of the FWI objective function using the adjoint-state method. With these two key ingredients, we will now build an inversion framework that can be used to minimize the FWI least-squares objective function.</p><p>[Devito]:http://www.opesci.org/devito-public [Julia]:https://julialang.org [JUDI]:https://github.com/slimgroup/JUDI.jl/tree/tle<em>tutorial</em>jan_2018</p><p>FWI is a computationally and mathematically challenging problem. The computational complexity comes from the fact that an already expensive solution procedure for the wave equation needs to be repeated for a large number of source positions for each iteration of the optimization algorithm. The mathematical complexity comes from the fact that the FWI objective is known to have many local minima due to cycle skipping. </p><p>&lt;div style=&quot;background: #eeeeee; border: 2px solid gray; border-radius:5px; padding: 6px 10px 6px 10px;&quot;&gt;</p><p>&lt;h3&gt; NOT FOR MANUSCRIPT&lt;/h3&gt;</p><p>&lt;p&gt;Furthermore, since the solution is not unique it is generally not possible to unambiguously recover the parameterization of the subsurface from the given data alone, making FWI an active field of research (e.g. Leeuwen et al., 2013; Warner and Guasch, 2014; Peters and Herrmann, 2017).&lt;/p&gt;</p><p>&lt;/div&gt;</p><p>This tutorial demonstrates how we can set up a basic FWI framework with two alternative gradient-based optimization algorithms: stochastic gradient descent, and the Gauss–Newton method (Nocedal and Wright, 2009). </p><p>We implement our inversion framework with the <a href="https://github.com/slimgroup/JUDI.jl/tree/tle_tutorial_jan_2018">Julia Devito Inversion framework</a> (JUDI), a parallel software package for seismic modeling and inversion in the <a href="https://julialang.org/">Julia</a> (Bezanson et al., 2012) programming language. JUDI provides abstractions and function wrappers that allow the implementation of wave-equation-based inversion problems such as FWI using code that closely follows the mathematical notation, while using Devito’s automatic code generation for solving the underlying wave equations.</p><p>All the code to run the algorithms and generate the figures in this paper can be found at http://github.com/SEG. </p><h2 id="Optimizing-the-FWI-objective-function"><a class="docs-heading-anchor" href="#Optimizing-the-FWI-objective-function">Optimizing the FWI objective function</a><a id="Optimizing-the-FWI-objective-function-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-the-FWI-objective-function" title="Permalink"></a></h2><p>The goal of this tutorial series is to optimize the FWI objective function with the <span>$\ell_2$</span>-misfit:</p>$<pre><code class="language-none">\mathop{\hbox{minimize}}_{\mathbf{m}} \hspace{.2cm} f(\mathbf{m})= \sum_{i=1}^{n_s} \frac{1}{2} \left\lVert \mathbf{d}^\mathrm{pred}_i (\mathbf{m}, \mathbf{q}_i) - \mathbf{d}_i^\mathrm{obs} \right\rVert_2^2,</code></pre>$<p>where <span>$\mathbf{d}^\mathrm{pred}_i$</span> and <span>$\mathbf{d}^\mathrm{obs}_i$</span> are the predicted and observed seismic shot records of the <span>$i^{\text{th}}$</span> source location and <span>$\mathbf{m}$</span> is the velocity model (expressed as squared slowness). In part one, we demonstrated how to implement a forward modeling operator to generate the predicted shot records, which we will denote as <span>$\mathbf{d}^\mathrm{pred}_i = \mathbf{F}(\mathbf{m},\mathbf{q}_i)$</span>.  In the second tutorial, we then showed how we can compute the gradient <span>$\nabla f(\mathbf{m})$</span> of the objective function and update our initial model using gradient descent.</p><p>There is a snag, however. This first-order optimization algorithm has a linear convergence rate at best, and typically requires many iterations to converge. Second-order optimization methods converge considerably faster. To implement them, we first approximate the objective with a second-order Taylor expansion:</p>$<pre><code class="language-none">f(\mathbf{m}) = f(\mathbf{m}_0) + \nabla f(\mathbf{m}_0) \delta \mathbf{m} + \delta \mathbf{m}^\top \nabla^2 f(\mathbf{m}_0) \delta \mathbf{m} + \mathcal{O}(\delta \mathbf{m}^3),</code></pre>$<p>where <span>$\mathcal{O}(\delta \mathbf{m}^3)$</span> represents the error term, <span>$\nabla f(\mathbf{m}_0)$</span> is the gradient as implemented in part two, and <span>$\nabla^2 f(\mathbf{m}_0)$</span> is the Hessian of the objective function, which we will refer to as <span>$\mathbf{H}$</span>. Rather than using the negative gradient to incrementally update our model, as in gradient descent, we directly calculate a model update <span>$\delta \mathbf{m}$</span> that leads us to the minimum. This is called Newton&#39;s method:</p>$<pre><code class="language-none">\delta \mathbf{m} = - \mathbf{H}(\mathbf{m}_0)^{-1} \nabla f(\mathbf{m}_0).</code></pre>$<p>Although the method converges to the minimum of the FWI objective function quickly, it comes at the cost of having to compute and invert the Hessian matrix (Nocedal and Wright, 2009). Fortunately, for least squares problems, such as FWI, the Hessian can be approximated by the Gauss-Newton (GN) Hessian <span>$\mathbf{J}^\top \mathbf{J}$</span>, where <span>$\mathbf{J}$</span> is the Jacobian matrix. This is the partial derivative of the forward modeling operator <span>$\mathbf{F}(\mathbf{m},\mathbf{q})$</span> with respect to <span>$\mathbf{m}$</span> — something we can easily compute. Furthermore, the Jacobian can also be used to express the gradient of the FWI objective function as <span>$\nabla f(\mathbf{m}_0) = \mathbf{J}^\top (\mathbf{d}^\mathrm{pred}_i - \mathbf{d}_i^\mathrm{obs})$</span>, where <span>$\mathbf{J}^\top$</span> is the adjoint (transposed) Jacobian. This is useful, because we now have a set of operators <span>$\mathbf{F}, \mathbf{J}$</span> and <span>$\mathbf{H}_{GN}=\mathbf{J}^\top\mathbf{J}$</span>, through which we can express both first and second order optimization algorithms for FWI.</p><p>Although forming these matrices explicitly is not possible, since they can become extremely large, we only need the action of these operators on vectors. This allows us to implement these operators matrix-free. In the following section we will demonstrate how to set up these operators in our JUDI software framework and to how to use them to implement FWI algorithms.</p><p>&lt;div style=&quot;background: #eeeeee; border: 2px solid gray; border-radius:5px; padding: 6px 10px 6px 10px;&quot;&gt;</p><p>&lt;h3&gt; NOT FOR MANUSCRIPT&lt;/h3&gt;</p><p>&lt;p&gt;[SegyIO]:https://github.com/slimgroup/SegyIO.jl&lt;/p&gt;</p><p>&lt;p&gt;The Julia Devito Inversion framework is a parallel matrix-free linear operator library for seismic modeling and inversion based on Devito and [SeisIO], a performant Julia package for reading and writing large data volumes in SEG-Y format. JUDI allows implementing seismic inversion algorithms as linear algebra operations, enabling rapid translations of FWI algorithms to executable Julia code. The underlying wave equations are set up and solved using Devito, as described in the first two tutorials, and are interfaced from Julia using the <a href="https://github.com/JuliaPy/PyCall.jl">PyCall</a> package (Johnson, 2017). &lt;/p&gt;</p><p>&lt;p&gt;For reading and writing SEG-Y data, JUDI uses the SeisIO package, a sophisticated SEG-Y reader that allows us to scan large 3D data sets for creating look-up tables with header summaries. However, since our data set is relatively small, we will directly load the full file into memory. The <code>segy_read</code> command takes the file name as an input and returns a dense data block. This is our observed data and we store it as a JUDI vector.&lt;/p&gt;</p><p>&lt;/div&gt;</p><pre><code class="language-julia"># NOT FOR MANUSCRIPT
# using Distributed
# addprocs(4);</code></pre><pre><code class="language-julia">using JUDI.TimeModeling, JUDI.SLIM_optim, SegyIO, Random, Statistics</code></pre><h2 id="Implementing-FWI-in-JUDI"><a class="docs-heading-anchor" href="#Implementing-FWI-in-JUDI">Implementing FWI in JUDI</a><a id="Implementing-FWI-in-JUDI-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-FWI-in-JUDI" title="Permalink"></a></h2><p>We start our demonstration by reading our data set, which consists of 16 shot records and was generated with an excerpt from the SEG/EAGE Overthrust model (Aminzadeh et al. 1997). We store it as a <code>judiVector</code>:</p><pre><code class="language-julia">block = segy_read(&quot;overthrust_shot_records.segy&quot;)
d_obs = judiVector(block);</code></pre><pre><code class="language-julia">using PyPlot

i = 8
figure(figsize=(15,6))
imshow(d_obs.data[i], cmap=&quot;seismic&quot;, extent=[0,size(d_obs.data[i],2),2,0], aspect=&quot;auto&quot;, vmin=-3, vmax=3)
xlabel(&quot;Receiver number&quot;, size=12)
ylabel(&quot;Time [s]&quot;, size=12)
text(3, 0.13, &quot;Shot record $i&quot;, size=16)
show()</code></pre><blockquote><p><strong>Figure 1</strong>: Observed shot record number 8.</p></blockquote><p>JUDI vectors such as <code>d_obs</code> can be used like a regular Julia vectors, so we can compute norms via <code>norm(d_obs)</code> or the inner product via <code>dot(d_obs, d_obs)</code>, but they contain the shot records in their original dimension. Shot records can be accessed via their respective shot number with <code>d_obs.data[shot_no]</code>, while the header information can be accessed with <code>d_obs.geometry</code>. We extract the source geometry from our SEG-Y file and then manually set up a source vector <code>q</code> with an 8 Hz Ricker wavelet:</p><pre><code class="language-julia">f = 0.008  # kHz
src_geom = Geometry(block; key=&quot;source&quot;)
src_data = ricker_wavelet(src_geom.t[1], src_geom.dt[1], f)
q = judiVector(src_geom, src_data);</code></pre><pre><code class="language-julia">plot(q.data[1])
show()</code></pre><p>&lt;div style=&quot;background: #eeeeee; border: 2px solid gray; border-radius:5px; padding: 6px 10px 6px 10px;&quot;&gt;</p><p>&lt;h3&gt; NOT FOR MANUSCRIPT&lt;/h3&gt;</p><p>&lt;p&gt;Since our data set consists of <span>$16$</span> shot records, both <code>d_obs</code> and <code>q</code> contain the data and geometries for all source positions. We can check the number of source positions with <code>d_obs.nsrc</code> and <code>q.nsrc</code> and we can extract the part of the vector that corresponds to one or multiple shots with <code>d_obs[shot_no], q[shot_no]</code>. &lt;/p&gt;</p><p>&lt;/div&gt;</p><p>We will now set up the forward modeling operator <span>$\mathbf{F}(\mathbf{m},\mathbf{q})$</span> as a matrix-free operator for the inverse wave equation <span>$\mathbf{A}(\mathbf{m})^{-1}$</span>, where <span>$\mathbf{m}$</span> is the current model, and source/receiver injection and sampling operators <span>$\mathbf{P}_\mathrm{s}$</span> and <span>$\mathbf{P}_\mathrm{r}$</span>.</p><p>Since the dimensions of the inverse wave equation operator depend on the number of computational time steps, we calculate this number using the <code>get_computational_nt</code> function and set up an <code>info</code> object that contains some dimensionality information required by all operators.</p><p>Then we can define <code>Pr</code> and <code>Ps</code> as matrix-free operators implementing Devito sparse point injection and interpolation (Louboutin et al., 2017). Multiplications with <code>Ps</code> and <code>Pr</code> represent sampling the wavefield at source/receiver locations, while their adjoints <code>Ps&#39;, Pr&#39;</code> denote injecting either source wavelets or shot records into the computational grid.</p><p>These projection and modelling operators can then be set up in Julia in the following way:</p><pre><code class="language-julia">using HDF5

m0, n, d, o = read(h5open(&quot;overthrust_model.h5&quot;,&quot;r&quot;),&quot;m0&quot;,&quot;n&quot;,&quot;d&quot;,&quot;o&quot;)
model0 = Model((n[1],n[2]), (d[1],d[2]), (o[1],o[2]), m0);</code></pre><pre><code class="language-julia">

Pr = judiProjection(d_obs.geometry)
Ps = judiProjection(q.geometry)
Ainv = judiModeling(model0);</code></pre><p>The forward modeling step can be expressed mathematically as</p>$<p>F(\mathbf{m};\mathbf{q})=\mathbf{P}<em>r\mathbf{A}^{-1}(\mathbf{m})\mathbf{P}</em>s^\top\mathbf{q} $</p><p>which is expressed in Julia as</p><pre><code class="language-none">d_pred = Pr * Ainv * Ps&#39; * q</code></pre><p>This forward models all 16 predicted shot records in parallel. Notice that, in instantiating <code>Ainv</code>, we made the wave equation solver implicitly dependent on <code>model0</code>.</p><p>Finally, we set up the matrix-free Jacobian operator <code>J</code> and the Gauss–Newton Hessian <code>J&#39; * J</code>. As mentioned in the introduction, <code>J</code> is the partial derivative of the forward modeling operator <span>$\mathbf{F}(\mathbf{m}, \mathbf{q})$</span> with respect to the model <code>m</code> and is therefore directly constructed from our modeling operator <code>Pr * Ainv * Ps&#39;</code> and a specified source vector <code>q</code>:</p><pre><code class="language-julia">J = judiJacobian(Pr * Ainv * Ps&#39;, q);</code></pre><p>&lt;div style=&quot;background: #eeeeee; border: 2px solid gray; border-radius:5px; padding: 6px 10px 6px 10px;&quot;&gt;</p><p>&lt;h3&gt; NOT FOR MANUSCRIPT&lt;/h3&gt;</p><p>&lt;p&gt;Note that, if we started our Julia session with multiple CPU cores or nodes (<code>julia -p n</code>, with <code>n</code> being the number of workers), the wave equation solves are automatically parallelized over source locations and all shots are collected in the <code>d_pred</code> vector.&lt;/p&gt;</p><p>&lt;p&gt;We can also model a single or subset of shots by indexing the operators with the respective shot numbers. E.g. if we want to model the first two shots, we define <code>i=[1,2]</code> and then run <code>d_sub = Pr[i]*Ainv[i]*Ps[i]&#39;*q[i]</code>.&lt;/p&gt;</p><p>&lt;p&gt;The FWI gradient would then be given by:&lt;/p&gt;</p><p>&lt;pre style=&quot;background: #eeeeee;&quot;&gt; <code>g = J[i]&#39; * (d_pred - d_obs[i])</code> &lt;/pre&gt;</p><p>&lt;p&gt;If we want to solve an adjoint wave equation with the observed data as the adjoint source and restrictions of the wavefields back to the source locations, we can simply run <code>qad = Ps * Ainv&#39; * Pr&#39; * d_obs</code>, exemplifying the advantages of casting FWI in a proper computational linear algebra framework.&lt;/p&gt;</p><p>&lt;p&gt;Once we have <code>J</code> we can also form the Gauss–Newton Hessian:&lt;/p&gt;</p><p>&lt;pre style=&quot;background: #eeeeee;&quot;&gt; <code>H_GN = J&#39; * J</code> &lt;/pre&gt;</p><p>&lt;/div&gt;</p><p>In the context of seismic inversion, the Jacobian is also called the linearized modeling or demigration operator and its adjoint <code>J&#39;</code> is the migration operator. One drawback of this notation is that the forward wavefields for the gradient calculation have to be recomputed, since the forward modeling operator only returns the shot records and not the complete wavefields. For this reason, JUDI has an additional function for computing the gradients of the FWI objective function <code>f,g = fwi_objective(model0,q[i],d_obs[i])</code>, which takes the current model, source and data vectors as an input and computes the objective value and gradient in parallel without having to recompute the forward wavefields.</p><h2 id="FWI-via-gradient-descent"><a class="docs-heading-anchor" href="#FWI-via-gradient-descent">FWI via gradient descent</a><a id="FWI-via-gradient-descent-1"></a><a class="docs-heading-anchor-permalink" href="#FWI-via-gradient-descent" title="Permalink"></a></h2><p>With expressions for modeling operators, Jacobians and gradients of the FWI objective, we can now implement different FWI algorithms in a few lines of code. We will start with a basic gradient descent example with a line search. To reduce the computational cost of full gradient descent, we will use a stochastic approach in which we only compute the gradient and function value for a randomized subset of source locations. In JUDI, this is accomplished by choosing a random vector of integers between 1 and 16 and indexing the data vectors as described earlier. Furthermore, we will apply a projection operator <code>proj(x)</code>, which prevent velocities (or squared slownesses) becoming negative or too large by clipping values outside the allowed range.</p><p>A few extra variables are defined in the notebook, but the full algorithm for FWI with stochastic gradient descent and box constraints is implemented as follows:</p><pre><code class="language-julia"># Set up bound constraints.
v0 = sqrt.(1f0./model0.m)
vmin = ones(Float32, model0.n) .* 1.3f0
vmax = ones(Float32, model0.n) .* 6.5f0

# Fix water column.
vmin[:,1:21] = v0[:,1:21]
vmax[:,1:21] = v0[:,1:21]

# Convert to squared slowness.
mmin = vec((1f0./vmax).^2)
mmax = vec((1f0./vmin).^2);</code></pre><pre><code class="language-julia">maxiter = 10
batchsize = 8    # Number of shots for each iteration.
proj(x) = reshape(median([vec(mmin) vec(x) vec(mmax)], dims=2), model0.n)
fhistory_SGD = zeros(Float32, maxiter);</code></pre><pre><code class="language-julia">for j=1:maxiter
    
    # FWI objective function value and gradient.
    i = randperm(d_obs.nsrc)[1:batchsize]
    fval, grad = fwi_objective(model0, q[i], d_obs[i])
    fhistory_SGD[j] = fval

    # Line search and update model.
    update = backtracking_linesearch(model0, q[i], d_obs[i], fval, grad, proj; alpha=1f0)
    model0.m += reshape(update, model0.n)

    # Apply box constraints.
    model0.m = proj(model0.m)
end</code></pre><pre><code class="language-julia">model_SGD = copy(model0.m);</code></pre><p>JUDI&#39;s <code>backtracking_linesearch</code> function performs an approximate line search and returns a model update that leads to a decrease of the objective function value (Armijo condition; Nocedal and Wright, 2009). The result after 10 iterations of SGD with box constraints is shown in Figure 2. In practice, where starting models are typically less accurate than in our example, FWI is often performed from low to high frequencies, since the objective function has less local minima for lower frequencies (Bunks et al., 1995). In this multi-scale FWI approach, a low-pass filtered version of the data is used to invert for a low resolution velocity model first and higher frequencies are added in subsequent iterations.</p><h2 id="FWI-via-the-Gauss–Newton-method"><a class="docs-heading-anchor" href="#FWI-via-the-Gauss–Newton-method">FWI via the Gauss–Newton method</a><a id="FWI-via-the-Gauss–Newton-method-1"></a><a class="docs-heading-anchor-permalink" href="#FWI-via-the-Gauss–Newton-method" title="Permalink"></a></h2><p>As discussed earlier, the convergence rate of GD depends on the objective function, but requires many FWI iterations necessary to reach an acceptable solution. Using our matrix-free operator for the Jacobian J, we can modify the above code to implement the Gauss–Newton method (Equation 3) to improve the convergence rate. In practice, directly inverting the Gauss–Newton Hessian <code>J&#39;* J</code> should be avoided, because the matrix is badly conditioned and takes many iterations to invert. Instead, we perform a few iterations of a least-squares solver, <code>lsqr()</code>, to approximately solve <code>J * p = d_pred - d_obs</code> and obtain the update direction <code>p</code>. <code>lsqr</code>,  from the Julia <code>IterativeSolvers</code> package, is a conjugate-gradient type algorithm for solving least squares problems and is mathematically equivalent to inverting <code>J&#39; * J</code>, but has better numerical properties (Paige and Saunders, 1982). We implement the Gauss-Newton method as follows:</p><pre><code class="language-julia">model0.m = m0    # Reset velocity model.
fhistory_GN = zeros(Float32,maxiter);</code></pre><pre><code class="language-julia">using IterativeSolvers

# Return data as Julia array
Ainv.options.return_array = true
d_vec = convert_to_array(d_obs)

for j=1:maxiter
    
    # Model predicted data.
    d_pred = Pr * Ainv * Ps&#39; * q

    # GN update direction.
    p = lsqr(J, d_pred - d_obs; maxiter=6)
    fhistory_GN[j] = .5f0 * norm(d_pred - d_vec)^2  # OMIT LINE FROM MANUSCRIPT

    # update model and box constraints.
    model0.m = model0.m - reshape(p, model0.n)
end</code></pre><p>&lt;div style=&quot;background: #eeeeee; border: 2px solid gray; border-radius:5px; padding: 6px 10px 6px 10px;&quot;&gt;</p><p>&lt;h3&gt; NOT FOR MANUSCRIPT&lt;/h3&gt;</p><p>&lt;p&gt;An important benefit of matrix-free operators is that we do not need to implement our own least-squares solver, but can pass <code>J</code> and the data residual <code>d_pred - d_obs</code> to a third-party optimization library. The operator <code>J</code> does not need to be an explicit matrix, since <code>lsqr</code> only uses matrix-vector products. &lt;/p&gt;</p><p>&lt;/div&gt;</p><p>In contrast to our SGD algorithm, we use all shot records in every iteration, since stochastic methods for second order algorithms are less well understood, making this approach considerably more expensive than our previous algorithm. However, as shown in figures 2 and 3, it achieves a superior result, with a considerably lower misfit compared to the known model. Furthermore, figure 3 shows that it achieves the improved result in relatively few iterations.</p><pre><code class="language-julia">figure(figsize=(15, 12))

subplot(311)
imshow(sqrt.(1f0./m0)&#39;, cmap=&quot;GnBu&quot;, extent=(0,10,3,0), vmin=1.5, vmax=5.4)
text(0.15, 0.3, &quot;Starting model&quot;, size=14, color=&quot;black&quot;)
ylabel(&quot;Depth [km]&quot;, size=12)
colorbar()
text(10.35, 1.5, &quot;Velocity [km/s]&quot;, va=&quot;center&quot;, size=12, rotation=90)

subplot(312)
imshow(sqrt.(1f0./model_SGD)&#39;, cmap=&quot;GnBu&quot;, extent=(0,10,3,0), vmin=1.5, vmax=5.4)
misfit = round(fhistory_SGD[end])
text(0.15, 0.3, &quot;Gradient descent, misfit = $misfit&quot;, size=14, color=&quot;black&quot;)
ylabel(&quot;Depth [km]&quot;, size=12)
colorbar()
text(10.35, 1.5, &quot;Velocity [km/s]&quot;, va=&quot;center&quot;, size=12, rotation=90)

subplot(313)
imshow(sqrt.(1f0./model0.m)&#39;, cmap=&quot;GnBu&quot;, extent=(0,10,3,0), vmin=1.5, vmax=5.4)
misfit = round(fhistory_GN[end])
text(0.15, 0.3, &quot;Gauss–Newton, misfit = $misfit&quot;, size=14, color=&quot;black&quot;)
xlabel(&quot;Lateral position [km]&quot;, size=12)
ylabel(&quot;Depth [km]&quot;, size=12)
colorbar()
text(10.35, 1.5, &quot;Velocity [km/s]&quot;, va=&quot;center&quot;, size=12, rotation=90)

show()</code></pre><pre><code class="language-julia">fhistory_SGD = fhistory_SGD/norm(fhistory_SGD, Inf)
fhistory_GN = fhistory_GN/norm(fhistory_GN, Inf);</code></pre><pre><code class="language-julia">figure(figsize=(8,3))
plot(1:10, fhistory_SGD, label=&quot;Gradient descent&quot;)
plot(1:10, fhistory_GN, label=&quot;Gauss–Newton&quot;)
text(9.8, 0.28, &quot;Gradient descent&quot;, ha=&quot;right&quot;, color=&quot;steelblue&quot;)
text(9.8, 0.09, &quot;Gauss–Newton&quot;, ha=&quot;right&quot;, color=&quot;chocolate&quot;)
xlabel(&quot;Iteration number&quot;, size=12)
ylabel(&quot;Misfit&quot;, size=12)
xlim(1, 10)
show()</code></pre><blockquote><p><strong>Figure 3</strong>: Normalized function values for the FWI inversion example with stochastic gradient descent and the Gauss-Newton method.</p></blockquote><p>An alternative to (Gauss–)Newton methods are quasi-Newton methods, which build up an approximation of the Hessian from previous gradients only and require no additional PDE solves or matrix inversions. Implementing an efficient and correct version of this method, such as the L-BFGS algorithm, exceeds a few lines of code and we therefore leave this exercise to the reader. Instead of implementing more complicated algorithms by hand, it is also possible to interface third-party Julia optimization libraries and an example for this is given in the notebook <strong>fwi<em>example</em>NLopt.ipynb</strong>.</p><p>Even though all examples shown here are two-dimensional, in order to make them reproducible on a laptop or desktop PC, JUDI can be used for 3D modeling and inversion without having to change the code, since the number of dimensions are automatically inferred from the velocity model and data dimensions.</p><h2 id="Conclusions"><a class="docs-heading-anchor" href="#Conclusions">Conclusions</a><a id="Conclusions-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusions" title="Permalink"></a></h2><p>In this final part of our FWI tutorial series, we demonstrated how to set up basic optimization algorithms for waveform inversion using JUDI. The methods shown here are all gradient based and differ in the way how update directions for the velocity model are computed. Our numerical examples can serve for the reader as a basis for developing more advanced FWI workflows, which usually include additional data preprocessing, frequency continuation techniques or further model constraints.</p><h2 id="Acknowledgments"><a class="docs-heading-anchor" href="#Acknowledgments">Acknowledgments</a><a id="Acknowledgments-1"></a><a class="docs-heading-anchor-permalink" href="#Acknowledgments" title="Permalink"></a></h2><p>This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>Aminzadeh, F., Brac, J., and Kunz, T., 1997. 3D Salt and Overthrust models. SEG/EAGE Modeling Series, No. 1: Distribution CD of Salt and Overthrust models, SEG Book Series Tulsa, Oklahoma.</p><p>Bezanson, J., Karpinski, S., Shah, V. B., and Edelman, A., 2012, Julia: A fast dynamic language for technical computing: CoRR. Retrieved from http://arxiv.org/abs/1209.5145</p><p>Bunks, C., Saleck, F. M., Zaleski, S., and Chavent, G., 1995, Multiscale seismic waveform inversion: GEOPHYSICS, 60, 1457–1473. doi:10.1190/1.1443880</p><p>Johnson, S., 2017, Calling python functions from the julia language: GitHub repository. https://github.com/JuliaPy/PyCall.jl; GitHub.</p><p>Lange, M., Kukreja, N., Louboutin, M., Luporini, F., Zacarias, F. V., Pandolfo, V., … Gorman, G., 2016, Devito: Towards a generic finite difference DSL using symbolic python: 6th workshop on python for high-performance and scientific computing. doi:10.1109/PyHPC.2016.9</p><p>Leeuwen, T. van, Aravkin, A. Y., Calandra, H., and Herrmann, F. J., 2013, In which domain should we measure the misfit for robust full waveform inversion? EAGE annual conference proceedings. doi:10.3997/2214-4609.20130839</p><p>Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2017, Full-waveform inversion - part 1: Forward modeling: Retrieved from https://www.slim.eos.ubc.ca/Publications/Private/Submitted/2017/louboutin2017fwi/louboutin2017fwi.html</p><p>Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2018, Full-waveform inversion - part 2: Adjoint modeling:</p><p>Nocedal, J., and Wright, S., 2009, Numerical optimization: (2nd ed.). Springer.</p><p>Paige, C. C., and Saunders, M. A., 1982, LSQR: An algorithm for sparse linear equations and sparse least squares: ACM Trans. Math. Softw., 8, 43–71. doi:10.1145/355984.355989</p><p>Peters, B., and Herrmann, F. J., 2017, Constraints versus penalties for edge-preserving full-waveform inversion: The Leading Edge, 36, 94–100. doi:10.1190/tle36010094.1</p><p>Warner, M., and Guasch, L., 2014, Adaptive waveform inversion: Theory: In SEG technical program expanded abstracts 2014 (pp. 1089–1093). doi:10.1190/segam2014-0371.1</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../03_constrained_fwi/">« FWI Example</a><a class="docs-footer-nextpage" href="../05_custom_misfit/">FWI with user provided misfit function »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 4 August 2023 15:35">Friday 4 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
