<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling and inversion with JUDI · JUDI documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JUDI documentation</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../basics/">Getting Started</a></li><li><span class="tocitem">JUDI API</span><ul><li><a class="tocitem" href="../../abstract_vectors/">Abstract vectors</a></li><li><a class="tocitem" href="../../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../linear_operators/">Linear Operators</a></li><li><a class="tocitem" href="../../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../../io/">Input/Output</a></li><li><a class="tocitem" href="../../helper/">Helper Functions</a></li></ul></li><li><a class="tocitem" href="../../inversion/">Inversion</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../01_intro/">Introduction to JUDI</a></li><li><a class="tocitem" href="../02_fwi_example_NLopt/">FWI with Quasi-Newton methods from the NLopt library</a></li><li><a class="tocitem" href="../03_constrained_fwi/">FWI Example</a></li><li><a class="tocitem" href="../04_judi_leading_edge_tutorial/">Full-Waveform Inversion - Part 3: optimization</a></li><li><a class="tocitem" href="../05_custom_misfit/">FWI with user provided misfit function</a></li><li><a class="tocitem" href="../06_automatic_differentiation/">Automatic differentiation with JUDI</a></li><li class="is-active"><a class="tocitem" href>Modeling and inversion with JUDI</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Import-JUDI,-Linear-algebra-utilities-and-Plotting"><span>Import JUDI, Linear algebra utilities and Plotting</span></a></li><li class="toplevel"><a class="tocitem" href="#Create-a-JUDI-model-structure"><span>Create a JUDI model structure</span></a></li><li><a class="tocitem" href="#Create-discrete-parameters"><span>Create discrete parameters</span></a></li><li class="toplevel"><a class="tocitem" href="#Create-acquisition-geometry"><span>Create acquisition geometry</span></a></li><li><a class="tocitem" href="#Create-source-and-receivers-positions-at-the-surface"><span>Create source and receivers positions at the surface</span></a></li><li class="toplevel"><a class="tocitem" href="#Source-judiVector"><span>Source judiVector</span></a></li><li class="toplevel"><a class="tocitem" href="#Modeling"><span>Modeling</span></a></li><li class="toplevel"><a class="tocitem" href="#Model-and-image-data"><span>Model and image data</span></a></li><li class="toplevel"><a class="tocitem" href="#Inversion"><span>Inversion</span></a></li><li><a class="tocitem" href="#Inversion-utility-functions"><span>Inversion utility functions</span></a></li><li class="toplevel"><a class="tocitem" href="#TWRI"><span>TWRI</span></a></li></ul></li><li><a class="tocitem" href="../08_imaging_conditions/">Imaging conditions in JUDI</a></li></ul></li><li><a class="tocitem" href="../../pysource/">Devito backend reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Modeling and inversion with JUDI</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modeling and inversion with JUDI</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/JUDI.jl/blob/master/docs/src/tutorials/07_quickstart.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling-and-inversion-with-JUDI"><a class="docs-heading-anchor" href="#Modeling-and-inversion-with-JUDI">Modeling and inversion with JUDI</a><a id="Modeling-and-inversion-with-JUDI-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-and-inversion-with-JUDI" title="Permalink"></a></h1><hr/><p>title: Overview of JUDI modeling and inversion usage author: Mathias Louboutin, Philipp Witte date: April 2022 –-</p><p>This example script is written using <a href="https://github.com/JunoLab/Weave.jl">Weave.jl</a> and can be converted to different format for documentation and usage This example is converted to a markdown file for the documentation.</p><h1 id="Import-JUDI,-Linear-algebra-utilities-and-Plotting"><a class="docs-heading-anchor" href="#Import-JUDI,-Linear-algebra-utilities-and-Plotting">Import JUDI, Linear algebra utilities and Plotting</a><a id="Import-JUDI,-Linear-algebra-utilities-and-Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Import-JUDI,-Linear-algebra-utilities-and-Plotting" title="Permalink"></a></h1><pre><code class="language-julia">using JUDI, PyPlot, LinearAlgebra</code></pre><h1 id="Create-a-JUDI-model-structure"><a class="docs-heading-anchor" href="#Create-a-JUDI-model-structure">Create a JUDI model structure</a><a id="Create-a-JUDI-model-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-JUDI-model-structure" title="Permalink"></a></h1><p>In JUDI, a <code>Model</code> structure contains the grid information (origin, spacing, number of gridpoints) and the physical parameters. The squared slowness is always required as the base physical parameter for propagation. In addition, JUDI supports additional physical representations. First we accept <code>density</code> that can either be a direct input <code>Model(n, d, o, m, rho)</code> or an optional keyword argument <code>Model(n,d,o,m;rho=rho)</code>. Second, we also provide VTI/TTI kernels parametrized by the THomsen parameters that can be input as keyword arguments <code>Model(n,d,o,m; rho=rho, epsilon=epsilon;delta=delta,theta=theta,phi=phi)</code>. Because the thomsen parameters are optional the propagator wil lonloy use the ones provided.  For example <code>Model(n,d,o,m; rho=rho, epsilon=epsilon;delta=delta)</code> will infer a VTI propagation</p><h2 id="Create-discrete-parameters"><a class="docs-heading-anchor" href="#Create-discrete-parameters">Create discrete parameters</a><a id="Create-discrete-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Create-discrete-parameters" title="Permalink"></a></h2><pre><code class="language-julia"># Set up model structure
n = (120, 100)   # (x,y,z) or (x,z)
d = (10., 10.)
o = (0., 0.)

# Velocity [km/s]
v = ones(Float32,n) .+ 0.5f0
v0 = ones(Float32,n) .+ 0.5f0
v[:,Int(round(end/2)):end] .= 3.5f0
rho = (v0 .+ .5f0) ./ 2

# Slowness squared [s^2/km^2]
m = (1f0 ./ v).^2
m0 = (1f0 ./ v0).^2
dm = vec(m0 - m)

# Setup model structure
nsrc = 2	# number of sources
model = Model(n, d, o, m)
model0 = Model(n, d, o, m0)</code></pre><pre><code class="language-none">Model (n=(120, 100), d=(10.0f0, 10.0f0), o=(0.0f0, 0.0f0)) with parameters 
[:m]</code></pre><h1 id="Create-acquisition-geometry"><a class="docs-heading-anchor" href="#Create-acquisition-geometry">Create acquisition geometry</a><a id="Create-acquisition-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Create-acquisition-geometry" title="Permalink"></a></h1><p>In this simple usage example, we create a simple acquisiton by hand. In practice the acquisition geometry will be defined by the dataset beeing inverted. We show in a spearate tutorial how to use <a href="https://github.com/slimgroup/SegyIO.jl">SegyIO.jl</a> to handle SEGY seismic datasets in JUDI.</p><h2 id="Create-source-and-receivers-positions-at-the-surface"><a class="docs-heading-anchor" href="#Create-source-and-receivers-positions-at-the-surface">Create source and receivers positions at the surface</a><a id="Create-source-and-receivers-positions-at-the-surface-1"></a><a class="docs-heading-anchor-permalink" href="#Create-source-and-receivers-positions-at-the-surface" title="Permalink"></a></h2><pre><code class="language-julia"># Set up receiver geometry
nxrec = 120
xrec = range(0f0, stop=(n[1]-1)*d[1], length=nxrec)
yrec = 0f0 # WE have to set the y coordiante to zero (or any number) for 2D modeling
zrec = range(d[1], stop=d[1], length=nxrec)

# receiver sampling and recording time
timeD = 1250f0   # receiver recording time [ms]
dtD = 2f0    # receiver sampling interval [ms]

# Set up receiver structure
recGeometry = Geometry(xrec, yrec, zrec; dt=dtD, t=timeD, nsrc=nsrc)</code></pre><pre><code class="language-none">GeometryIC{Float32} wiht 2 sources</code></pre><p>The source geometry is a but different. Because we want to create a survey with <code>nsrc</code> shot records, we need to convert the vector of sources postions <code>[s0, s1, ... sn]</code> into an array of array [[s0], [s1], ...] so that JUDI understands that this is a set of indepednet <code>nsrc</code></p><pre><code class="language-julia">xsrc = convertToCell(range(0f0, stop=(n[1]-1)*d[1], length=nsrc))
ysrc = convertToCell(range(0f0, stop=0f0, length=nsrc))
zsrc = convertToCell(range(d[1], stop=d[1], length=nsrc))

# Set up source structure
srcGeometry = Geometry(xsrc, ysrc, zsrc; dt=dtD, t=timeD)</code></pre><pre><code class="language-none">GeometryIC{Float32} wiht 2 sources</code></pre><h1 id="Source-judiVector"><a class="docs-heading-anchor" href="#Source-judiVector">Source judiVector</a><a id="Source-judiVector-1"></a><a class="docs-heading-anchor-permalink" href="#Source-judiVector" title="Permalink"></a></h1><p>Finally, with the geometry defined, we can create a source wavelet (a simple Ricker wavelet here) a our first <code>judiVector</code> In JUDI, a <code>judiVector</code> is the core structure that represent a acquisition-geometry based dataset. This structure encapsulate the physical locations (trace coordinates) and corrsponding data trace in a source-based structure. for a given <code>judiVector</code> <code>d</code> then <code>d[1]</code> will be the shot record for the first source, or in the case of the source term, the first source wavelet and its positon.</p><pre><code class="language-julia"># setup wavelet
f0 = 0.01f0     # kHz
wavelet = ricker_wavelet(timeD, dtD, f0)
q = judiVector(srcGeometry, wavelet)</code></pre><pre><code class="language-none">judiVector{Float32, Matrix{Float32}} with 2 sources</code></pre><h1 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h1><p>With our survey and subsurface model setup, we can now model and image seismic data. We first define a few options. In this tutorial we will choose to compute gradients/images subsampling the forward wavefield every two time steps <code>subsampling_factor=2</code> and we fix the computational time step to be <code>1ms</code> wiuth <code>dt_comp=1.0</code> know to satisfy the CFL condition for this simple example. In practice, when <code>dt_comp</code> isn&#39;t provided, JUDI will compute the CFL condition for the propagation.</p><pre><code class="language-julia"># Setup options
opt = Options(subsampling_factor=2, dt_comp=1.0)</code></pre><pre><code class="language-none">JUDIOptions(8, false, false, 1000.0, false, &quot;&quot;, &quot;shot&quot;, false, false, Any[]
, &quot;as&quot;, 2, 1, false, 1.0, 0.015f0)</code></pre><p>Linear Operators The core idea behind JUDI is to abstract seismic inverse problems in term of linear algebra. In its simplest form, seismic inversion can be formulated as</p><p class="math-container">\[\underset{\mathbf{m}}{\text{argmin}} \ \ \phi(\mathbf{m}) = \frac{1}{2} ||\mathbf{P}_r \mathbf{F}(\mathbf{m}) \mathbf{P}_s^{\top} \mathbf{q} - \mathbf{d} ||_2^2 \\
\text{   } \\
\nabla_{\mathbf{m}} \phi(\mathbf{m}) = \mathbf{J}(\mathbf{m}, \mathbf{q})^{\top} (\mathbf{P}_r \mathbf{F}(\mathbf{m}) \mathbf{P}_s^{\top} \mathbf{q} - \mathbf{d})\]</p><p>where <span>$\mathbf{P}_r$</span> is the receiver projection (measurment operator) and <span>$\mathbf{P}_s^{\top}$</span> is the source injection operator (adjoint of measurment at the source location). Therefore, we bastracted these operation to be able to define these operators</p><pre><code class="language-julia"># Setup operators
Pr = judiProjection(recGeometry)
F = judiModeling(model; options=opt)
F0 = judiModeling(model0; options=opt)
Ps = judiProjection(srcGeometry)
J = judiJacobian(Pr*F0*adjoint(Ps), q)</code></pre><pre><code class="language-none">JUDI born{Float32} propagator (z * x) -&gt; (src * rec * time)</code></pre><h1 id="Model-and-image-data"><a class="docs-heading-anchor" href="#Model-and-image-data">Model and image data</a><a id="Model-and-image-data-1"></a><a class="docs-heading-anchor-permalink" href="#Model-and-image-data" title="Permalink"></a></h1><p>We first model synthetic data using our defined source and true model </p><pre><code class="language-julia"># Nonlinear modeling
dobs = Pr*F*adjoint(Ps)*q</code></pre><pre><code class="language-none">judiVector{Float32, Matrix{Float32}} with 2 sources</code></pre><p>Plot the shot record</p><pre><code class="language-julia">fig = figure()
imshow(dobs.data[1], vmin=-1, vmax=1, cmap=&quot;PuOr&quot;, extent=[xrec[1], xrec[end], timeD/1000, 0], aspect=&quot;auto&quot;)
xlabel(&quot;Receiver position (m)&quot;)
ylabel(&quot;Time (s)&quot;)
title(&quot;Synthetic data&quot;)
display(fig)</code></pre><p><img src="../figures/modeling_basic_2D_10_1.png" alt/></p><p>Because we have abstracted the linear algebra, we can solve the adjoint wave-equation as well  where the data becomes the source. This adjoint solve will be part of the imaging procedure.</p><pre><code class="language-julia"># # Adjoint
qad = Ps*adjoint(F)*adjoint(Pr)*dobs</code></pre><pre><code class="language-none">judiVector{Float32, Matrix{Float32}} with 2 sources</code></pre><p>We can easily now test the adjointness of our operator with the standard dot test. Because we intend to conserve our linear algebra abstraction, <code>judiVector</code> implements all the necessary linear  algebra functions such as dot product or norm to be used directly.</p><pre><code class="language-julia"># &lt;x, F&#39;y&gt;
dot1 = dot(q, qad)
# &lt;F x, y&gt;
dot2 = dot(dobs, dobs)
# Compare
@show dot1, dot2, (dot2 - dot2)/(dot1 + dot2)</code></pre><pre><code class="language-none">(dot1, dot2, (dot2 - dot2) / (dot1 + dot2)) = (462909.3f0, 462909.72f0, 0.0
f0)
(462909.3f0, 462909.72f0, 0.0f0)</code></pre><h1 id="Inversion"><a class="docs-heading-anchor" href="#Inversion">Inversion</a><a id="Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion" title="Permalink"></a></h1><p>Our main goal is to provide an inversion framework for seismic inversion. To this end, as shown earlier, users can easily define the Jacobian operator and compute an RTM image (i.e FWI gradient) with a simple matrix-vector product. Once again, we provide both the Jacobian and its adjoint and we can compute Born linearized data.</p><pre><code class="language-julia"># Linearized modeling J*dm
dD = J*dm
# Adjoint jacobian, RTM image
rtm = adjoint(J)*dD</code></pre><pre><code class="language-none">PhysicalParameter{Float32} of size (120, 100) with origin (0.0, 0.0) and sp
acing (10.0, 10.0)</code></pre><p>We show the linearized data.</p><pre><code class="language-julia">fig = figure()
imshow(dD.data[1], vmin=-1, vmax=1, cmap=&quot;PuOr&quot;, extent=[xrec[1], xrec[end], timeD/1000, 0], aspect=&quot;auto&quot;)
xlabel(&quot;Receiver position (m)&quot;)
ylabel(&quot;Time (s)&quot;)
title(&quot;Linearized data&quot;)
display(fig)</code></pre><p><img src="../figures/modeling_basic_2D_14_1.png" alt/></p><p>And the RTM image</p><pre><code class="language-julia">fig = figure()
imshow(rtm&#39;, vmin=-1e2, vmax=1e2, cmap=&quot;Greys&quot;, extent=[0, (n[1]-1)*d[1], (n[2]-1)*d[2], 0 ], aspect=&quot;auto&quot;)
xlabel(&quot;Lateral position(m)&quot;)
ylabel(&quot;Depth (m)&quot;)
title(&quot;RTM image&quot;)
display(fig)</code></pre><p><img src="../figures/modeling_basic_2D_15_1.png" alt/></p><h2 id="Inversion-utility-functions"><a class="docs-heading-anchor" href="#Inversion-utility-functions">Inversion utility functions</a><a id="Inversion-utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion-utility-functions" title="Permalink"></a></h2><p>We currently introduced the lineaar operators that allow to write seismic modeling and inversion in a high-level, linear algebra way. These linear operators allow the script to closely follow the mathematics and to be readable and understandable.</p><p>However, these come with overhead. In particular, consider the following compuation on the FWI gradient:</p><pre><code class="language-julia">d_syn = F*q
r = judiJacobian(F, q)&#39; * (d_syn - d_obs)</code></pre><p>In this two lines, the forward modeling is performed twice: once to compute <code>d_syn</code> then once again to compute the Jacobian adjoint. In order to avoid this overhead for practical inversion, we provide utility function that directly comput the gradient and objective function (L2- misfit) of FWI, LSRTM and TWRI with minimum overhead.</p><p>FWI misfit and gradient</p><pre><code class="language-julia"># evaluate FWI objective function
f, g = fwi_objective(model0, q, dobs; options=opt)</code></pre><pre><code class="language-none">(21534.379f0, PhysicalParameter{Float32} of size (120, 100) with origin (0.
0f0, 0.0f0) and spacing (10.0f0, 10.0f0))</code></pre><p>Plot gradient</p><pre><code class="language-julia">fig = figure()
imshow(g&#39;, vmin=-1e2, vmax=1e2, cmap=&quot;Greys&quot;, extent=[0, (n[1]-1)*d[1], (n[2]-1)*d[2], 0 ], aspect=&quot;auto&quot;)
xlabel(&quot;Lateral position(m)&quot;)
ylabel(&quot;Depth (m)&quot;)
title(&quot;FWI gradient&quot;)
display(fig)</code></pre><p><img src="../figures/modeling_basic_2D_17_1.png" alt/></p><p>LSRTM misfit and gradient</p><pre><code class="language-julia"># evaluate LSRTM objective function
fj, gj = lsrtm_objective(model0, q, dD, dm; options=opt)
fjn, gjn = lsrtm_objective(model0, q, dobs, dm; nlind=true, options=opt)</code></pre><pre><code class="language-none">(35776.496f0, PhysicalParameter{Float32} of size (120, 100) with origin (0.
0f0, 0.0f0) and spacing (10.0f0, 10.0f0))</code></pre><p>Plot gradients</p><pre><code class="language-julia">fig = figure()
imshow(gj&#39;, vmin=-1, vmax=1, cmap=&quot;Greys&quot;, extent=[0, (n[1]-1)*d[1], (n[2]-1)*d[2], 0 ], aspect=&quot;auto&quot;)
xlabel(&quot;Lateral position(m)&quot;)
ylabel(&quot;Depth (m)&quot;)
title(&quot;LSRTM gradient&quot;)
display(fig)

fig = figure()
imshow(gjn&#39;, vmin=-1, vmax=1, cmap=&quot;Greys&quot;, extent=[0, (n[1]-1)*d[1], (n[2]-1)*d[2], 0 ], aspect=&quot;auto&quot;)
xlabel(&quot;Lateral position(m)&quot;)
ylabel(&quot;Depth (m)&quot;)
title(&quot;LSRTM gradient with background data substracted&quot;)
display(fig)</code></pre><p><img src="../figures/modeling_basic_2D_19_1.png" alt/> <img src="../figures/modeling_basic_2D_19_2.png" alt/></p><p>By extension, lsrtm<em>objective is the same as fwi</em>objecive when <code>dm</code> is zero And with computing of the residual. Small noise can be seen in the difference due to floating point roundoff errors with openMP, but running with  OMP<em>NUM</em>THREADS=1 (no parllelism) produces the exact (difference == 0) same result gjn2 == g</p><pre><code class="language-julia">fjn2, gjn2 = lsrtm_objective(model0, q, dobs, 0f0.*dm; nlind=true, options=opt)
fig = figure()</code></pre><pre><code class="language-none">PyPlot.Figure(PyObject &lt;Figure size 640x480 with 0 Axes&gt;)</code></pre><p>Plot gradient</p><pre><code class="language-julia">imshow(gjn2&#39;, vmin=-1e2, vmax=1e2, cmap=&quot;Greys&quot;, extent=[0, (n[1]-1)*d[1], (n[2]-1)*d[2], 0 ], aspect=&quot;auto&quot;)
xlabel(&quot;Lateral position(m)&quot;)
ylabel(&quot;Depth (m)&quot;)
title(&quot;LSRTM gradient with zero perturbation&quot;)
display(fig)</code></pre><p><img src="../figures/modeling_basic_2D_21_1.png" alt/></p><h1 id="TWRI"><a class="docs-heading-anchor" href="#TWRI">TWRI</a><a id="TWRI-1"></a><a class="docs-heading-anchor-permalink" href="#TWRI" title="Permalink"></a></h1><p>Finally, JUDI implements TWRI, an augmented method to tackle cycle skipping. Once again we provide a computationnally efficient wrapper function that returns the objective value and necessary gradients</p><pre><code class="language-julia">f, gm, gy = twri_objective(model0, q, dobs, nothing; options=opt, optionswri=TWRIOptions(params=:all))
# With on-the-fly DFT, experimental
f, gmf = twri_objective(model0, q, dobs, nothing; options=Options(frequencies=[[.009, .011], [.008, .012]]), optionswri=TWRIOptions(params=:m))</code></pre><pre><code class="language-none">(-2326.1436f0, PhysicalParameter{Float32} of size (120, 100) with origin (0
.0f0, 0.0f0) and spacing (10.0f0, 10.0f0))</code></pre><p>Plot gradients</p><pre><code class="language-julia">fig = figure()
imshow(gm&#39;, vmin=-1, vmax=1, cmap=&quot;Greys&quot;, extent=[0, (n[1]-1)*d[1], (n[2]-1)*d[2], 0 ], aspect=&quot;auto&quot;)
xlabel(&quot;Lateral position(m)&quot;)
ylabel(&quot;Depth (m)&quot;)
title(&quot;TWRI gradient w.r.t m&quot;)
display(fig)

fig = figure()
imshow(gy.data[1], vmin=-1e2, vmax=1e2, cmap=&quot;PuOr&quot;, extent=[xrec[1], xrec[end], timeD/1000, 0], aspect=&quot;auto&quot;)
xlabel(&quot;Receiver position (m)&quot;)
ylabel(&quot;Time (s)&quot;)
title(&quot;TWRI gradient w.r.t y&quot;)
display(fig)</code></pre><p><img src="../figures/modeling_basic_2D_22_1.png" alt/> <img src="../figures/modeling_basic_2D_22_2.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../06_automatic_differentiation/">« Automatic differentiation with JUDI</a><a class="docs-footer-nextpage" href="../08_imaging_conditions/">Imaging conditions in JUDI »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 8 May 2023 19:43">Monday 8 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
