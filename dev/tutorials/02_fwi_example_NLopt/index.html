<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FWI with Quasi-Newton methods from the NLopt library · JUDI documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JUDI documentation</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><span class="tocitem">JUDI API</span><ul><li><a class="tocitem" href="../../abstract_vectors/">Abstract vectors</a></li><li><a class="tocitem" href="../../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../linear_operators/">Linear Operators</a></li><li><a class="tocitem" href="../../io/">Input/Output</a></li><li><a class="tocitem" href="../../helper/">Helper Functions</a></li></ul></li><li><a class="tocitem" href="../../basics/">Getting Started</a></li><li><a class="tocitem" href="../../inversion/">Inversion</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../01_intro/">Introduction to JUDI</a></li><li class="is-active"><a class="tocitem" href>FWI with Quasi-Newton methods from the NLopt library</a><ul class="internal"><li><a class="tocitem" href="#Optimization"><span>Optimization</span></a></li></ul></li><li><a class="tocitem" href="../03_constrained_fwi/">FWI Example</a></li><li><a class="tocitem" href="../04_judi_leading_edge_tutorial/">Full-Waveform Inversion - Part 3: optimization</a></li></ul></li><li><a class="tocitem" href="../../pysource/">Devito backend reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>FWI with Quasi-Newton methods from the NLopt library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FWI with Quasi-Newton methods from the NLopt library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/JUDI.jl/blob/master/docs/src/tutorials/02_fwi_example_NLopt.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FWI-with-Quasi-Newton-methods-from-the-NLopt-library"><a class="docs-heading-anchor" href="#FWI-with-Quasi-Newton-methods-from-the-NLopt-library">FWI with Quasi-Newton methods from the NLopt library</a><a id="FWI-with-Quasi-Newton-methods-from-the-NLopt-library-1"></a><a class="docs-heading-anchor-permalink" href="#FWI-with-Quasi-Newton-methods-from-the-NLopt-library" title="Permalink"></a></h1><p>In this notebook, we demonstrate how to interface the NLopt optimization library for full-waveform inversion with a limited-memory Quasi-Newton (L-BFGS) algorithm. Once again, we start by adding additional workers for parallel computing and by loading all necessary modules:</p><pre><code class="language-julia">using Distributed; addprocs(2)
@everywhere using SegyIO, HDF5, PyPlot, JUDI, NLopt, Random, LinearAlgebra, Printf</code></pre><p>We load the FWI starting model from the HDF5 model file and set up the JUDI model structure:</p><pre><code class="language-julia">m0, n, d, o = read(h5open(&quot;overthrust_model.h5&quot;,&quot;r&quot;),&quot;m0&quot;,&quot;n&quot;,&quot;d&quot;,&quot;o&quot;); title(&quot;Starting model&quot;)
model0 = Model((n[1],n[2]), (d[1],d[2]), (o[1],o[2]), m0);
imshow(sqrt.(1f0./m0)&#39;, cmap=&quot;GnBu&quot;, extent=(0,10,3,0));
xlabel(&quot;Lateral position [km]&quot;);
ylabel(&quot;Depth [km]&quot;);</code></pre><p><img src="../02_fwi_example_NLopt_files/02_fwi_example_NLopt_4_0.png" alt="png"/></p><p>Then we read the SEG-Y file containing our test data set. The data was generated with a 2D excerpt from the Overthrust velocity model and consists of 31 shot records with 2 seconds recording time. We load the data and set up a JUDI seismic data vector:</p><pre><code class="language-julia">block = segy_read(&quot;overthrust_shot_records.segy&quot;);
d_obs = judiVector(block);</code></pre><pre><code class="language-none">┌ Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=7076688, maxsize=Inf, ptr=3601, mark=-1)
└ @ SegyIO /Users/mathiaslouboutin/.julia/packages/SegyIO/uw4ZW/src/read/read_file.jl:26</code></pre><pre><code class="language-julia">extent = [0, 10, 2, 0]
figure(figsize=(7, 7))
subplot(221)
imshow(d_obs.data[1], vmin=-1, vmax=1, cmap=&quot;PuOr&quot;, extent=extent, aspect=4, interpolation=&quot;hamming&quot;)
xlabel(&quot;Receiver position(km)&quot;)
ylabel(&quot;Time(s)&quot;)
subplot(222)
imshow(d_obs.data[6], vmin=-1, vmax=1, cmap=&quot;PuOr&quot;, extent=extent, aspect=4, interpolation=&quot;hamming&quot;)
xlabel(&quot;Receiver position(km)&quot;)
ylabel(&quot;Time(s)&quot;)
subplot(223)
imshow(d_obs.data[11], vmin=-1, vmax=1, cmap=&quot;PuOr&quot;, extent=extent, aspect=4, interpolation=&quot;hamming&quot;)
xlabel(&quot;Receiver position(km)&quot;)
ylabel(&quot;Time(s)&quot;)
subplot(224)
imshow(d_obs.data[16], vmin=-1, vmax=1, cmap=&quot;PuOr&quot;, extent=extent, aspect=4, interpolation=&quot;hamming&quot;)
xlabel(&quot;Receiver position(km)&quot;)
ylabel(&quot;Time(s)&quot;)
tight_layout()
</code></pre><p><img src="../02_fwi_example_NLopt_files/02_fwi_example_NLopt_7_0.png" alt="png"/></p><p>Since the SEG-Y file contains the source coordinates, but not the wavelet itself, we create a JUDI <code>Geometry</code> structure for the source and then manually set up an 8 Hz Ricker wavelet. As for the observed data, we set up a JUDI seismic data vector <code>q</code> with the source geometry and wavelet:</p><pre><code class="language-julia">src_geometry = Geometry(block; key=&quot;source&quot;);
src_data = ricker_wavelet(src_geometry.t[1], src_geometry.dt[1], 0.008f0);
q = judiVector(src_geometry, src_data);</code></pre><h2 id="Optimization"><a class="docs-heading-anchor" href="#Optimization">Optimization</a><a id="Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization" title="Permalink"></a></h2><p>Rather than implementing the L-BFGS algorithms in Julia ourselves, we interface the NLopt optimization library. This library requires objective functions with the current variable and gradient as input arguments and the function value as the only output argument. For this reason, we build a wrapper that is customized for the NLopt library around our <code>fwi_objective</code> function. The function <code>f!</code> takes a vectorized estimate of the current model as well as the (vectorized) gradient as input arguments. NLopt uses double precision for floating point variables, so the first step inside <code>f!</code> is to reshape and convert the model to single precision. Then we choose a randomized subset of sources and shot records and compute the function value <code>fval</code> and <code>gradient</code> of the FWI objective function. We then set the gradient in the water layer to zero and overwrite the input gradient <code>grad</code> with the new gradient. Furthermore, we keep track of the number of function evaluations through increasing the <code>count</code> variable, which will serve as the termination criterion for the algorithm. In Julia, we set up <code>f!</code> in the following way: </p><pre><code class="language-julia">batchsize = 8;
count = 0;

# NLopt objective function
function f!(x, grad)
    global count
    if count == 0
        @printf(&quot;%10s %15s %15s\n&quot;,&quot;Iteration&quot;,&quot;Function Val&quot;,&quot;norm(g)&quot;)
    end
    # Update model
    model0.m = Float32.(reshape(x,model0.n))

    # Seclect batch and calculate gradient
    i = randperm(d_obs.nsrc)[1:batchsize]
    fval, gradient = fwi_objective(model0, q[i], d_obs[i])

    # Reset gradient in water column to zero
    gradient = reshape(gradient, model0.n)
    gradient[:,1:21] .= 0f0
    grad[1:end] = vec(gradient)
          
    global count; count += 1
    @printf(&quot;%10d %15.5e %15.5e\n&quot;,count, fval, norm(g))
    return convert(Float64, fval)
end</code></pre><pre><code class="language-none">UndefVarError: @printf not defined</code></pre><pre><code class="language-julia">g = zeros(prod(model0.n))
f0 = f!(vec(model0.m), g)
# Reset count
global count = 0;</code></pre><pre><code class="language-none">1    255339.66398837214    262117.01773563828





255339.66398837214</code></pre><pre><code class="language-julia">imshow(reshape(g, model0.n)&#39;, vmin=-1e3, vmax=1e3, extent=(0,10,3,0), cmap=&quot;jet&quot;)
title(&quot;FWI first gradient&quot;)
xlabel(&quot;Lateral position [km]&quot;);
ylabel(&quot;Depth [km]&quot;);</code></pre><p><img src="../02_fwi_example_NLopt_files/02_fwi_example_NLopt_13_0.png" alt="png"/></p><p>As in our gradient descent and Gauss-Newton example, we define bound constraints for the squared slowness to prevent velocities from becoming negative or too large:</p><pre><code class="language-julia"># Set up bound constrains
v0 = sqrt.(1f0./model0.m)
vmin = ones(Float32, model0.n) .* 1.3f0;
vmax = ones(Float32, model0.n) .* 6.5f0;

# Convert to squared slowness
mmin = vec((1f0 ./ vmax).^2);
mmax = vec((1f0 ./ vmin).^2);</code></pre><p>The NLopt library offers a range of different optimization algorithms, from which we choose the L-BFGS method. We create an optimization object called <code>opt</code> by specifying the algorithm we want to use and the dimenions of the unknown model vector. We then set the upper and lower bounds of the variable, define <code>f!</code> as the objective function and set the termination criterion to be a maximum of 15 function evaluations:</p><pre><code class="language-julia">opt = Opt(:LD_LBFGS, prod(model0.n))
lower_bounds!(opt, mmin)
upper_bounds!(opt, mmax)
min_objective!(opt, f!)
maxeval!(opt, 15)</code></pre><p>Remark: Subsampling the number of sources should in practice never be used for second order methods such as L-BFGS. Specialized stochastic second order methods exist, but differ from standard Quasi-Newton methods. We only use source subsampling to reduce the computational cost of our example. Having set up the objective function, bound constraints and termination criterion, we can now run the inversion:</p><p>** This example requires ~200 MB of memory per gradient, i.e. 800 MB with four parallel workers. It runs for approximately 15 minutes. **</p><pre><code class="language-julia">(minf, minx, ret) = optimize(opt, vec(model0.m));</code></pre><pre><code class="language-none">2    257901.94477162338    258980.10388516955
3    172803.59079827153    302780.85054677405
4    189130.6172962864    318396.30082959705
5    206791.76877585545    375180.5596427598
6    214141.76860964662    406769.76629408816
7    364202.2299721926    359639.79808253766
8    144399.94956911763    208320.48800925835
9    115243.88926892391    196391.16164069102
10    83024.91172473418    233775.52396071967
11    79410.95713778166    217893.00687219884
12    67300.58613575318    210013.1922979365
13    51630.938175045296    108049.05286704176
14    46403.458416860216    117827.36750250543
15    43086.70610388414    94403.35456695667
16    35267.624712575205    96966.99249506553</code></pre><p>We plot the final velocity model after 15 function evaluations:</p><pre><code class="language-julia">imshow(sqrt.(1f0./reshape(minx, model0.n))&#39;, cmap=&quot;GnBu&quot;, extent=(0,10,3,0), vmin=1.5, vmax=5.4); title(&quot;FWI with L-BFGS&quot;)
xlabel(&quot;Lateral position [km]&quot;);
ylabel(&quot;Depth [km]&quot;);</code></pre><p><img src="../02_fwi_example_NLopt_files/02_fwi_example_NLopt_22_0.png" alt="png"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../01_intro/">« Introduction to JUDI</a><a class="docs-footer-nextpage" href="../03_constrained_fwi/">FWI Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 20 April 2022 20:42">Wednesday 20 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
