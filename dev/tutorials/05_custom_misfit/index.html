<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FWI with user provided misfit function · JUDI documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JUDI documentation</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../basics/">Getting Started</a></li><li><span class="tocitem">JUDI API</span><ul><li><a class="tocitem" href="../../abstract_vectors/">Abstract vectors</a></li><li><a class="tocitem" href="../../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../linear_operators/">Linear Operators</a></li><li><a class="tocitem" href="../../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../../io/">Input/Output</a></li><li><a class="tocitem" href="../../helper/">Helper Functions</a></li></ul></li><li><a class="tocitem" href="../../inversion/">Inversion</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../01_intro/">Introduction to JUDI</a></li><li><a class="tocitem" href="../02_fwi_example_NLopt/">FWI with Quasi-Newton methods from the NLopt library</a></li><li><a class="tocitem" href="../03_constrained_fwi/">FWI Example</a></li><li><a class="tocitem" href="../04_judi_leading_edge_tutorial/">Full-Waveform Inversion - Part 3: optimization</a></li><li class="is-active"><a class="tocitem" href>FWI with user provided misfit function</a><ul class="internal"><li><a class="tocitem" href="#Single-source-loss"><span>Single source loss</span></a></li><li class="toplevel"><a class="tocitem" href="#Inversion-setup"><span>Inversion setup</span></a></li><li class="toplevel"><a class="tocitem" href="#Misfit-functions"><span>Misfit functions</span></a></li><li><a class="tocitem" href="#Predefined-misfit"><span>Predefined misfit</span></a></li></ul></li><li><a class="tocitem" href="../06_automatic_differentiation/">Automatic differentiation with JUDI</a></li><li><a class="tocitem" href="../07_preconditionners/">Seismic preconditionners</a></li><li><a class="tocitem" href="../imaging_conditions/">Imaging conditions in JUDI</a></li><li><a class="tocitem" href="../quickstart/">Modeling and inversion with JUDI</a></li></ul></li><li><a class="tocitem" href="../../pysource/">Devito backend reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>FWI with user provided misfit function</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FWI with user provided misfit function</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/JUDI.jl/blob/master/docs/src/tutorials/05_custom_misfit.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FWI-with-user-provided-misfit-function"><a class="docs-heading-anchor" href="#FWI-with-user-provided-misfit-function">FWI with user provided misfit function</a><a id="FWI-with-user-provided-misfit-function-1"></a><a class="docs-heading-anchor-permalink" href="#FWI-with-user-provided-misfit-function" title="Permalink"></a></h1><p>In this notebook, we will introduce how the loss (data misifit) can be modifed to a user chosen function for seismic inversion. We will use one of <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a>&#39;s FWI example as a skeleton and illustrate the losses available in the package and how to input a custom data misfit function.</p><h2 id="Single-source-loss"><a class="docs-heading-anchor" href="#Single-source-loss">Single source loss</a><a id="Single-source-loss-1"></a><a class="docs-heading-anchor-permalink" href="#Single-source-loss" title="Permalink"></a></h2><p>In <a href="https://github.com/slimgroup/JUDI.jl">JUDI</a>, the data misfit function is defined on a single shot record basis (single source experiment) and will be automatically reduced by julia&#39;s distribution for multiple sources. Therefore, the misfit function is extremly simple and should have the form:</p><pre><code class="language-julia">
function misfit(dsyn, dobs)
    fval = ...
    adjoint_source = ...
    return fval, adjoint_source
end
</code></pre><p>Where <code>fval</code> is the misfit value for a given pair of synthetic <code>dsyn</code> and observed <code>dobs</code> shot records and <code>adjoint_source</code> is the residual to be backpropagated (adjoint wave-equation source) for the computation of the adjoint state gradient. For example the standard <span>$\ell_2$</span> loss (default misfit in JUDI) is defined as</p><pre><code class="language-julia">
function mse(dsyn, dobs)
    fval = .5f0 * norm(dsyn - dobs)^2
    adjoint_source = syn - dobs
    return fval, adjoint_source
end
</code></pre><p>With this convention defined, we will now perform FWI with a few misfit functions and highlight the flexibility of this interface, including the possibility to use Julia&#39;s automatic differentiation frameworks to compute the adjoint souce of misfit functions difficult to differentiate by hand.</p><h1 id="Inversion-setup"><a class="docs-heading-anchor" href="#Inversion-setup">Inversion setup</a><a id="Inversion-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Inversion-setup" title="Permalink"></a></h1><pre><code class="language-julia">using SegyIO, HDF5, PyPlot, JUDI, Random, LinearAlgebra, Printf, SlimPlotting, SlimOptim, Statistics</code></pre><pre><code class="language-julia"># Define some utilities for plotting
sx(d::judiVector) = d.geometry.xloc[1][1]</code></pre><pre><code class="language-none">sx (generic function with 1 method)</code></pre><p>We load the FWI starting model from the HDF5 model file and set up the JUDI model structure:</p><pre><code class="language-julia">m0, n, d, o = read(h5open(&quot;overthrust_model.h5&quot;,&quot;r&quot;),&quot;m0&quot;,&quot;n&quot;,&quot;d&quot;,&quot;o&quot;); title(&quot;Starting model&quot;)
model0 = Model((n[1],n[2]), (d[1],d[2]), (o[1],o[2]), m0)</code></pre><p><img src="../05_custom_misfit_files/05_custom_misfit_6_0.png" alt="png"/></p><pre><code class="language-none">Model (n=(401, 121), d=(25.0f0, 25.0f0), o=(0.0f0, 0.0f0)) with parameters [:m]</code></pre><pre><code class="language-julia">plot_velocity(m0&#39;.^(-.5), d)</code></pre><p><img src="../05_custom_misfit_files/05_custom_misfit_7_0.png" alt="png"/></p><p>Then we read the SEG-Y file containing our test data set. The data was generated with a 2D excerpt from the Overthrust velocity model and consists of 31 shot records with 2 seconds recording time. We load the data and set up a JUDI seismic data vector:</p><pre><code class="language-julia">block = segy_read(&quot;overthrust_shot_records.segy&quot;);
d_obs = judiVector(block);</code></pre><pre><code class="language-none">┌ Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=7076688, maxsize=Inf, ptr=3601, mark=-1)
└ @ SegyIO /Users/mathiaslouboutin/.julia/packages/SegyIO/qkvUT/src/read/read_file.jl:26</code></pre><p>Since the SEG-Y file contains the source coordinates, but not the wavelet itself, we create a JUDI <code>Geometry</code> structure for the source and then manually set up an 8 Hz Ricker wavelet. As for the observed data, we set up a JUDI seismic data vector <code>q</code> with the source geometry and wavelet:</p><pre><code class="language-julia">src_geometry = Geometry(block; key=&quot;source&quot;);
src_data = ricker_wavelet(src_geometry.t[1], src_geometry.dt[1], 0.008f0);
q = judiVector(src_geometry, src_data);</code></pre><pre><code class="language-julia">figure(figsize=(7, 7))
suptitle(&quot;Observed data&quot;)
subplot(221)
plot_sdata(d_obs[1]; new_fig=false, cmap=&quot;PuOr&quot;, name=&quot;sx=$(sx(q[1]))m&quot;)
subplot(222)
plot_sdata(d_obs[6]; new_fig=false, cmap=&quot;PuOr&quot;, name=&quot;sx=$(sx(q[6]))m&quot;)
subplot(223)
plot_sdata(d_obs[11]; new_fig=false, cmap=&quot;PuOr&quot;, name=&quot;sx=$(sx(q[11]))m&quot;)
subplot(224)
plot_sdata(d_obs[16]; new_fig=false, cmap=&quot;PuOr&quot;, name=&quot;sx=$(sx(q[16]))m&quot;)
tight_layout()</code></pre><p><img src="../05_custom_misfit_files/05_custom_misfit_12_0.png" alt="png"/></p><h1 id="Misfit-functions"><a class="docs-heading-anchor" href="#Misfit-functions">Misfit functions</a><a id="Misfit-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Misfit-functions" title="Permalink"></a></h1><p>With the data and model defined, we can now define the misfit function we will be working with. For some of the considered functions, we will modify the observed data to highlight properties of a given misfit.</p><h2 id="Predefined-misfit"><a class="docs-heading-anchor" href="#Predefined-misfit">Predefined misfit</a><a id="Predefined-misfit-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-misfit" title="Permalink"></a></h2><p>JUDI provides two predefined misfits: the standard <code>mse</code> <span>$\ell_2$</span> loss and the <code>studentst</code> misfit that correspond to the Student&#39;s T Loss that has been shown to increase robustness against outliers in the data. The Student&#39;s T loss is defined as </p><pre><code class="language-julia">
function studentst(dsyn, dobs; k=2)
    fval = sum(.5 * (k + 1) * log.(1 .+ (dsyn - dobs).^2 ./ k)
    adjoint_source = (k + 1) .* (dsyn - dobs) ./ (k .+ (dsyn - dobs).^2)
    return fval, adjoint_source
end
</code></pre><p>where <code>k</code> is the number of degree of freedom (usually 1 or 2). We can see that in this case the adjoint source is pointwise normalized (in time and receiver position) which allows to mitigate outlier in the data such as incorrect amplitudes due to geophone mis-functionment. To illustrate this property, wee create an aritifical dataset with outliers to showcase the added robustness by artificially rescaling a few traces picked at random in every shot record of the dataset</p><pre><code class="language-julia">d_outlier = deepcopy(d_obs)

## Add outliers to the data
for s=1:d_outlier.nsrc
    # wrongly scale 10 traces
    nrec = d_outlier[s].geometry.nrec[1]
    inds = rand(1:nrec, 10)
    d_outlier.data[s][:, inds] .*= 20
end</code></pre><pre><code class="language-julia">figure(figsize=(7, 7))
suptitle(&quot;Observed data with outliers&quot;)
subplot(221)
plot_sdata(d_outlier[1]; new_fig=false, cmap=&quot;PuOr&quot;, name=&quot;sx=$(sx(q[1]))m&quot;)
subplot(222)
plot_sdata(d_outlier[6]; new_fig=false, cmap=&quot;PuOr&quot;, name=&quot;sx=$(sx(q[6]))m&quot;)
subplot(223)
plot_sdata(d_outlier[11]; new_fig=false, cmap=&quot;PuOr&quot;, name=&quot;sx=$(sx(q[11]))m&quot;)
subplot(224)
plot_sdata(d_outlier[16]; new_fig=false, cmap=&quot;PuOr&quot;, name=&quot;sx=$(sx(q[16]))m&quot;)
tight_layout()</code></pre><p><img src="../05_custom_misfit_files/05_custom_misfit_16_0.png" alt="png"/></p><h3 id="Setup-inversion"><a class="docs-heading-anchor" href="#Setup-inversion">Setup inversion</a><a id="Setup-inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-inversion" title="Permalink"></a></h3><p>With the data and misfit functions defined, we can now run the inversion. For this example, we will use SlimOptim&#39;s spectral projected gradient, a simple gradient base optimization method were we impose bound constraints on the model. For practical considerations, we will also work with a stochastic objective function that only computes the gradient on a random subset of shots at each iteration. This method has been show to be efficient for seismic inversion in particualr with advanced algorithms with constraints or on simpler illustrative examples such as this one. We will use 8 shots per iteration (50% of the dataset) and run 20 iterations of the algorithm.</p><pre><code class="language-julia">g_const = 0
function objective_function(x, d_obs, misfit=mse)
    model0.m .= reshape(x,model0.n);

    # fwi function value and gradient
    i = randperm(d_obs.nsrc)[1:batchsize]
    fval, grad = fwi_objective(model0, q[i], d_obs[i]; misfit=misfit)
    # Normalize for nicer convergence
    g = grad.data
    # Mute water
    g[:, 1:20] .= 0f0
    g_const == 0 &amp;&amp; (global g_const = 1/norm(g, Inf))
    return fval, g_const .* g
end</code></pre><pre><code class="language-none">objective_function (generic function with 2 methods)</code></pre><pre><code class="language-julia"># Bound constraints based on initial velocity
mmin = .95f0 * minimum(m0) * ones(Float32, n...)
mmax = 1.1f0 * maximum(m0) * ones(Float32, n...)

# Fix water layer
mmin[:, 1:20] .= m0[1,1]
mmax[:, 1:20] .= m0[1,1]

# Bound projection
proj(x) = reshape(median([vec(mmin) vec(x) vec(mmax)]; dims=2), model0.n)</code></pre><pre><code class="language-none">proj (generic function with 1 method)</code></pre><pre><code class="language-julia">batchsize = 8
niter = 20

# Setup SPG
options = spg_options(verbose=3, maxIter=niter, memory=3)

# Compare l2 with students t on ideal data
ϕmse_ideal = x-&gt;objective_function(x, d_obs)
ϕst_ideal = x-&gt;objective_function(x, d_obs, studentst)

# Compare l2 with students t on the data with outliers
ϕmse_out = x-&gt;objective_function(x, d_outlier)
ϕst_out = x-&gt;objective_function(x, d_outlier, studentst)</code></pre><pre><code class="language-none">#7 (generic function with 1 method)</code></pre><pre><code class="language-julia"># Perform the inversion
g_const = 0
solmse_ideal = spg(ϕmse_ideal, m0, proj, options)
g_const = 0
solst_ideal = spg(ϕst_ideal, m0, proj, options)
g_const = 0
solmse_out = spg(ϕmse_out, m0, proj, options)
g_const = 0
solst_out = spg(ϕst_out, m0, proj, options)</code></pre><pre><code class="language-none">Running SPG...
Number of objective function to store: 3
Using  spectral projection : true
Maximum number of iterations: 20
SPG optimality tolerance: 1.00e-10
SPG progress tolerance: 1.00e-10
Line search: BackTracking{Float32, Int64}
 Iteration   FunEvals  GradEvals Projections     Step Length           alpha    Function Val        Opt Cond
         0          0          0          0     0.00000e+00     0.00000e+00     2.66752e+05     4.24512e-01
         1          2          2          6     1.00000e+00     4.44444e-02     1.83654e+05     3.97694e-01
         2          4          4          9     1.00000e+00     3.86448e-02     1.68483e+05     4.46593e-01
         3          6          6         12     1.00000e+00     2.37916e-02     9.82918e+04     4.21356e-01
         4          8          8         15     1.00000e+00     2.00663e-02     7.17603e+04     4.30578e-01
         5         10         10         18     1.00000e+00     1.80122e-02     5.64357e+04     1.52451e-01
         6         12         12         21     1.00000e+00     1.59804e-02     4.64412e+04     3.24789e-01
         7         14         14         24     1.00000e+00     1.49305e-02     4.02634e+04     2.00507e-01
         8         16         16         27     1.00000e+00     1.84277e-02     3.24419e+04     3.97697e-01
         9         18         18         30     1.00000e+00     1.88020e-02     3.26324e+04     1.51282e-01
        10         20         20         33     1.00000e+00     1.44802e-02     3.01499e+04     3.31139e-01
        11         22         22         36     1.00000e+00     1.05926e-02     2.65702e+04     1.77554e-01
        12         24         24         39     1.00000e+00     8.83888e-03     1.99885e+04     1.48811e-01
        13         26         26         42     1.00000e+00     1.04110e-02     2.36893e+04     1.68137e-01
        14         28         28         45     1.00000e+00     1.58912e-02     1.87623e+04     1.55777e-01
        15         30         30         48     1.00000e+00     1.88643e-02     1.78986e+04     8.86404e-02
        16         32         32         51     1.00000e+00     1.56725e-02     1.71706e+04     2.11131e-01
        17         34         34         54     1.00000e+00     1.29173e-02     1.53461e+04     7.06666e-02
        18         36         36         57     1.00000e+00     1.32459e-02     1.62717e+04     6.97212e-02
        19         38         38         60     1.00000e+00     2.35474e-02     1.33874e+04     2.31529e-01
        20         41         41         63     1.00000e-01     2.34768e-02     1.57433e+04     1.03599e-01
Running SPG...
Number of objective function to store: 3
Using  spectral projection : true
Maximum number of iterations: 20
SPG optimality tolerance: 1.00e-10
SPG progress tolerance: 1.00e-10
Line search: BackTracking{Float32, Int64}
 Iteration   FunEvals  GradEvals Projections     Step Length           alpha    Function Val        Opt Cond
         0          0          0          0     0.00000e+00     0.00000e+00     2.65220e+05     4.33497e-01
         1          2          2          6     1.00000e+00     4.44444e-02     2.63573e+05     3.96120e-01
         2          5          5          9     1.00000e-01     2.87833e-02     2.04122e+05     4.08234e-01
         3          8          8         12     1.00000e-01     1.14303e-01     1.46186e+05     4.51432e-01
         4         10         10         15     1.00000e+00     6.83298e-03     1.14790e+05     4.35991e-01
         5         12         12         18     1.00000e+00     7.10424e-03     1.09469e+05     4.49633e-01
         6         14         14         21     1.00000e+00     6.74102e-03     8.16012e+04     4.49592e-01
         7         16         16         24     1.00000e+00     5.73175e-03     7.39588e+04     4.15352e-01
         8         18         18         27     1.00000e+00     6.79955e-03     6.74752e+04     4.01064e-01
         9         20         20         30     1.00000e+00     8.90642e-03     6.10524e+04     4.09543e-01
        10         22         22         33     1.00000e+00     6.13604e-03     6.80915e+04     4.43890e-01
        11         24         24         36     1.00000e+00     4.03840e-03     4.76625e+04     3.86592e-01
        12         26         26         39     1.00000e+00     6.17972e-03     4.52775e+04     4.45348e-01
        13         28         28         42     1.00000e+00     4.58222e-03     3.83993e+04     3.40792e-01
        14         30         30         45     1.00000e+00     4.33826e-03     3.45115e+04     3.76462e-01
        15         32         32         48     1.00000e+00     7.44435e-03     3.33236e+04     4.13865e-01
        16         34         34         51     1.00000e+00     8.23616e-03     3.66736e+04     4.48623e-01
        17         36         36         54     1.00000e+00     3.59586e-03     3.03236e+04     3.60418e-01
        18         38         38         57     1.00000e+00     2.77100e-03     2.72704e+04     3.36501e-01
        19         40         40         60     1.00000e+00     3.27021e-03     2.44597e+04     3.00182e-01
        20         42         42         63     1.00000e+00     5.67399e-03     2.58941e+04     2.96022e-01
Running SPG...
Number of objective function to store: 3
Using  spectral projection : true
Maximum number of iterations: 20
SPG optimality tolerance: 1.00e-10
SPG progress tolerance: 1.00e-10
Line search: BackTracking{Float32, Int64}
 Iteration   FunEvals  GradEvals Projections     Step Length           alpha    Function Val        Opt Cond
         0          0          0          0     0.00000e+00     0.00000e+00     1.44941e+08     3.99644e-01
         1          2          2          6     1.00000e+00     4.44444e-02     1.43838e+08     3.93633e-01
         2          4          4          9     1.00000e+00     1.16882e-01     1.20535e+08     3.92942e-01
         3          6          6         12     1.00000e+00     1.56330e-01     1.00449e+08     3.48297e-01
         4          8          8         15     1.00000e+00     3.67119e-01     7.55863e+07     3.48005e-01
         5         10         10         18     1.00000e+00     3.19012e-01     1.08780e+08     3.90391e-01
         6         13         13         21     1.00000e-01     3.74207e-01     9.95976e+07     4.11056e-01
         7         15         15         24     1.00000e+00     1.00220e-01     8.43423e+07     3.17958e-01
         8         24         24         27     1.00000e-07     1.14440e-01     1.01919e+08     3.01010e-01
         9         26         26         30     1.00000e+00     1.56984e-08     8.62008e+07     3.17958e-01
        10         36         36         33     1.00000e-08     3.33508e-08     8.25621e+07     3.50130e-01
Step size: 2.98e-16 below progTol: 1.00e-10
Running SPG...
Number of objective function to store: 3
Using  spectral projection : true
Maximum number of iterations: 20
SPG optimality tolerance: 1.00e-10
SPG progress tolerance: 1.00e-10
Line search: BackTracking{Float32, Int64}
 Iteration   FunEvals  GradEvals Projections     Step Length           alpha    Function Val        Opt Cond
         0          0          0          0     0.00000e+00     0.00000e+00     5.46581e+05     4.47720e-01
         1          9          9          6     1.00000e-07     4.44444e-02     5.44028e+05     4.34094e-01
         2         12         12          9     1.00000e-01     9.44714e-08     5.32362e+05     4.26830e-01
         3         14         14         12     1.00000e+00     2.12196e-08     5.42095e+05     4.26773e-01
         4         16         16         15     1.00000e+00     1.94585e-07     5.42074e+05     4.32777e-01
         5         21         21         18     1.00000e-03     6.28857e-07     5.29497e+05     4.29520e-01
         6         25         25         21     1.00000e-02     1.00000e+00     5.06206e+05     4.23433e-01
         7         27         27         24     1.00000e+00     1.54459e-02     4.13344e+05     4.08260e-01
         8         29         29         27     1.00000e+00     2.72312e-02     4.15654e+05     4.51937e-01
         9         31         31         30     1.00000e+00     1.83427e-02     5.03455e+05     4.41503e-01
        10         40         40         33     1.00000e-07     1.39864e-02     4.97702e+05     3.91456e-01
        11         48         48         36     1.00000e-06     9.34530e-09     4.96147e+05     4.39331e-01
Step size: 1.49e-14 below progTol: 1.00e-10





result{Float32}(Float32[0.44444445 0.44444445 … 0.055672385 0.054975696; 0.44444445 0.44444445 … 0.05563018 0.05495146; … ; 0.44444445 0.44444445 … 0.05432263 0.05296257; 0.44444445 0.44444445 … 0.054288656 0.05309218], Float32[0.0 0.0 … 0.03932687 0.051932618; 0.0 0.0 … 0.03822797 0.05325304; … ; 0.0 0.0 … 0.006757668 0.0029647883; 0.0 0.0 … 0.0061980807 0.0022367856], 413343.9f0, Float32[546580.56, 544027.9, 532361.8, 542095.3, 542073.7, 529497.06, 506206.3, 413343.9, 415653.62, 503455.06, 497702.1, 496147.38], Matrix{Float32}[[0.44444445 0.44444445 … 0.05585606 0.05512348; 0.44444445 0.44444445 … 0.05584115 0.055107832; … ; 0.44444445 0.44444445 … 0.055858355 0.05516676; 0.44444445 0.44444445 … 0.05585274 0.05516145]], 36, 48, 48)</code></pre><h4 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h4><p>We can now look at the inversion results for these two datasets and two misfit functions. We show all four results below. We can see that in the case of ideal data, we invert for the velocity fairly easily in both cases as expected and obtain an accurate reconstruction.</p><p>We obsereved on the second row that, as expected from the litterature, the student&#39;s t misift provides a very robust inversion in the presence of outlier and that the inverted velocity is as good as with ideal data. On the other hand, the standard <code>mse</code> misfits fails to lead to an acceptable inverted velocity in the presence of outliers as these outliers will lead to the main contribution to the gradient. These artifacts, once present in the velocity model after the few first iteration, cannot be recovered from.</p><pre><code class="language-julia">figure(figsize=(14, 7))
suptitle(&quot;FWI result&quot;)
subplot(221)
plot_velocity(reshape(solmse_ideal.x, model0.n)&#39;.^(-.5), model0.d; new_fig=false, name=&quot;Ideal data, mse&quot;)
subplot(222)
plot_velocity(reshape(solst_ideal.x, model0.n)&#39;.^(-.5), model0.d; new_fig=false, name=&quot;Ideal data, student&#39;s t&quot;)
subplot(223)
plot_velocity(reshape(solmse_out.x, model0.n)&#39;.^(-.5), model0.d; new_fig=false, name=&quot;Data with outliers, mse&quot;)
subplot(224)
plot_velocity(reshape(solst_out.x, model0.n)&#39;.^(-.5), model0.d; new_fig=false,  name=&quot;Data with outliers, student&#39;s t&quot;)
tight_layout()</code></pre><p><img src="../05_custom_misfit_files/05_custom_misfit_23_0.png" alt="png"/></p><pre><code class="language-julia">figure()
plot(solmse_ideal.ϕ_trace ./ solmse_ideal.ϕ_trace[1], label=&quot;Ideal mse&quot;)
plot(solst_ideal.ϕ_trace ./ solst_ideal.ϕ_trace[1], label=&quot;Ideal student&#39;s t&quot;)
plot(solmse_out.ϕ_trace ./ solmse_out.ϕ_trace[1], label=&quot;Outlier mse&quot;)
plot(solst_out.ϕ_trace ./ solst_out.ϕ_trace[1], label=&quot;Outlier student&#39;s t&quot;)
xlabel(&quot;iteration&quot;)
ylabel(&quot;Normalized misfit&quot;)
title(&quot;Convergence&quot;)</code></pre><p><img src="../05_custom_misfit_files/05_custom_misfit_24_0.png" alt="png"/></p><pre><code class="language-none">PyObject Text(0.5, 1.0, &#39;Convergence&#39;)</code></pre><p>## Custom misfits</p><p>Finally, we now introduce how to use custom misfit for inversion. As illustrated above, the misfit is a simple keyword argument to the <code>fwi_objective/lsrtm_objective</code> function and consequently, any function returning the misfit value and adjoint source can be provided. In particular, users can take advantage of the extensive automatic differentiation ecosystem in Julia to define complicated misfit functions and automatically derive the corresponding adjoint source. </p><p>In the following, as an illustrative example, we define the misfit for Envelope FWI and let Zygote computes its derivative with respect to the synthetic data. We add a little bit of complexity to the misfit function by normalizing the data by its <span>$\ell_2$</span> norm as well to demonstrate how we can layer complexities in the misfit function and let the automatic differentiation infer the adjoint source.</p><pre><code class="language-julia">using FFTW, Zygote

n2(x) = x / norm(x, 2)

function Hilbert(x)
    n = size(x, 1)
    σ = sign.(-n/2+1:n/2)
    y = imag(ifft(fftshift(σ.*fftshift(fft(x, 1), 1), 1), 1))
    return y
end

HLoss(dsyn, dobs) = sum(abs2.((dsyn - dobs) .+ 1im .* Hilbert(dsyn - dobs)))

function envelope(dsyn, dobs)
    ϕ = HLoss(n2(dsyn), n2(dobs))
    g = gradient(xs -&gt; HLoss(n2(xs), n2(dobs)), dsyn)
    # Zygote always returns a tuple, in this case (g,)
    return ϕ, real.(g[1])
end</code></pre><pre><code class="language-none">┌ Info: Precompiling Zygote [e88e6eb3-aa80-5325-afca-941959d7151f]
└ @ Base loading.jl:1662
[33m[1m┌ [22m[39m[33m[1mWarning: [22m[39mModule DiffRules with build ID 773862253559751 is missing from the cache.
[33m[1m│ [22m[39mThis may mean DiffRules [b552c78f-8df3-52c6-915a-8e097449b14b] does not support precompilation but is imported by a module that does.
[33m[1m└ [22m[39m[90m@ Base loading.jl:1325[39m
┌ Info: Skipping precompilation since __precompile__(false). Importing Zygote [e88e6eb3-aa80-5325-afca-941959d7151f].
└ @ Base loading.jl:1341





envelope (generic function with 1 method)</code></pre><p>With our loss defined we can now rerun FWI with it</p><pre><code class="language-julia"># Compare l2 with students t on ideal data
ϕh_ideal = x-&gt;objective_function(x, d_obs, envelope)</code></pre><pre><code class="language-none">#11 (generic function with 1 method)</code></pre><pre><code class="language-julia">g_const = 0
solh_ideal = spg(ϕh_ideal, m0, proj, options)</code></pre><pre><code class="language-none">Running SPG...
Number of objective function to store: 3
Using  spectral projection : true
Maximum number of iterations: 20
SPG optimality tolerance: 1.00e-10
SPG progress tolerance: 1.00e-10
Line search: BackTracking{Float32, Int64}
 Iteration   FunEvals  GradEvals Projections     Step Length           alpha    Function Val        Opt Cond
         0          0          0          0     0.00000e+00     0.00000e+00     9.89023e-01     4.26088e-01
         1          2          2          6     1.00000e+00     4.44444e-02     5.96211e-01     3.97723e-01
         2          4          4          9     1.00000e+00     3.22405e-02     5.85686e-01     4.51937e-01
         3          6          6         12     1.00000e+00     2.09030e-02     3.81984e-01     4.51005e-01
         4          8          8         15     1.00000e+00     1.60157e-02     2.25568e-01     3.97775e-01
         5         10         10         18     1.00000e+00     1.59596e-02     1.75072e-01     3.59442e-01
         6         12         12         21     1.00000e+00     2.15618e-02     1.56823e-01     2.05124e-01
         7         14         14         24     1.00000e+00     2.46165e-02     1.42123e-01     3.35674e-01
         8         16         16         27     1.00000e+00     2.11885e-02     1.17001e-01     1.94726e-01
         9         18         18         30     1.00000e+00     1.20896e-02     1.11277e-01     4.14274e-01
        10         20         20         33     1.00000e+00     7.33151e-03     9.26926e-02     2.81033e-01
        11         22         22         36     1.00000e+00     6.84483e-03     7.99434e-02     3.38496e-01
        12         24         24         39     1.00000e+00     9.87291e-03     7.37838e-02     2.56689e-01
        13         26         26         42     1.00000e+00     1.70487e-02     7.32610e-02     9.64325e-02
        14         28         28         45     1.00000e+00     1.53908e-02     7.61458e-02     2.71101e-01
        15         30         30         48     1.00000e+00     1.21645e-02     5.53087e-02     1.33696e-01
        16         32         32         51     1.00000e+00     9.74719e-03     5.92018e-02     1.71851e-01
        17         34         34         54     1.00000e+00     8.90081e-03     5.74107e-02     9.27853e-02
        18         36         36         57     1.00000e+00     7.97771e-03     4.89929e-02     1.21926e-01
        19         38         38         60     1.00000e+00     8.40343e-03     5.05762e-02     8.61898e-02
        20         40         40         63     1.00000e+00     9.53746e-03     4.93289e-02     1.69757e-01





result{Float32}(Float32[0.44444445 0.44444445 … 0.053637963 0.052456174; 0.44444445 0.44444445 … 0.053673286 0.052389987; … ; 0.44444445 0.44444445 … 0.05293595 0.05135409; 0.44444445 0.44444445 … 0.052959688 0.051626943], Float32[0.0 0.0 … 0.0014253161 0.0031370732; 0.0 0.0 … 0.0007196072 0.0023543844; … ; 0.0 0.0 … 0.014447195 0.01871568; 0.0 0.0 … 0.013791027 0.017101452], 0.04899293f0, Float32[0.98902273, 0.5962111, 0.5856857, 0.38198355, 0.22556786, 0.17507246, 0.15682286, 0.14212339, 0.11700058, 0.111277334  …  0.079943426, 0.073783785, 0.073261, 0.07614578, 0.05530872, 0.059201777, 0.057410687, 0.04899293, 0.050576232, 0.04932886], Matrix{Float32}[[0.44444445 0.44444445 … 0.05585606 0.05512348; 0.44444445 0.44444445 … 0.05584115 0.055107832; … ; 0.44444445 0.44444445 … 0.055858355 0.05516676; 0.44444445 0.44444445 … 0.05585274 0.05516145]], 63, 40, 40)</code></pre><pre><code class="language-julia">suptitle(&quot;FWI result&quot;)
plot_velocity(reshape(solh_ideal.x, model0.n)&#39;.^(-.5), model0.d; new_fig=false, name=&quot;Ideal data, Envelope&quot;)</code></pre><p><img src="../05_custom_misfit_files/05_custom_misfit_30_0.png" alt="png"/></p><p>In this tutorial, we have seen how misfit functions can impact the inversion result and how JUDI provides multiple misfit functions and  a flexible interface for custom user inputs. This interface will allow for better application to real worl dataset since, as show in our example suite, JUDI already provide an interface for handling large SegY datasets and interfaces tricially with optimization frameworks</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../04_judi_leading_edge_tutorial/">« Full-Waveform Inversion - Part 3: optimization</a><a class="docs-footer-nextpage" href="../06_automatic_differentiation/">Automatic differentiation with JUDI »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 20 November 2023 03:43">Monday 20 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
