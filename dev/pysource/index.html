<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Devito backend reference · JUDI documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JUDI documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../about/">About</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../abstract_vectors/">Abstract vectors</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../linear_operators/">Linear Operators</a></li><li><a class="tocitem" href="../io/">Input/Output</a></li><li><a class="tocitem" href="../helper/">Helper Functions</a></li><li><a class="tocitem" href="../inversion/">Inversion</a></li><li><a class="tocitem" href="../tutorials/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Devito backend reference</a><ul class="internal"><li><a class="tocitem" href="#Submodules"><span>Submodules</span></a></li><li><a class="tocitem" href="#FD_utils-module"><span>FD_utils module</span></a></li><li><a class="tocitem" href="#checkpoint-module"><span>checkpoint module</span></a></li><li><a class="tocitem" href="#geom_utils-module"><span>geom_utils module</span></a></li><li><a class="tocitem" href="#interface-module"><span>interface module</span></a></li><li><a class="tocitem" href="#kernels-module"><span>kernels module</span></a></li><li><a class="tocitem" href="#models-module"><span>models module</span></a></li><li><a class="tocitem" href="#propagators-module"><span>propagators module</span></a></li><li><a class="tocitem" href="#sensitivity-module"><span>sensitivity module</span></a></li><li><a class="tocitem" href="#sources-module"><span>sources module</span></a></li><li><a class="tocitem" href="#wave_utils-module"><span>wave_utils module</span></a></li><li><a class="tocitem" href="#Module-contents"><span>Module contents</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Devito backend reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Devito backend reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/JUDI.jl/blob/master/docs/src/pysource.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="pysource-package"><a class="docs-heading-anchor" href="#pysource-package">pysource package</a><a id="pysource-package-1"></a><a class="docs-heading-anchor-permalink" href="#pysource-package" title="Permalink"></a></h1><h2 id="Submodules"><a class="docs-heading-anchor" href="#Submodules">Submodules</a><a id="Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Submodules" title="Permalink"></a></h2><h2 id="FD_utils-module"><a class="docs-heading-anchor" href="#FD_utils-module">FD_utils module</a><a id="FD_utils-module-1"></a><a class="docs-heading-anchor-permalink" href="#FD_utils-module" title="Permalink"></a></h2><h3 id="FD*utils.R*mat(model)"><a class="docs-heading-anchor" href="#FD*utils.R*mat(model)">FD<em>utils.R</em>mat(model)</a><a id="FD*utils.R*mat(model)-1"></a><a class="docs-heading-anchor-permalink" href="#FD*utils.R*mat(model)" title="Permalink"></a></h3><p>Rotation matrix according to tilt and asymut.</p><ul><li><p><strong>Parameters</strong></p><p><strong>model</strong> (<em>Model</em>) – Model structure</p></li></ul><h3 id="FD*utils.divs(func,-so*fact1,-side-1)"><a class="docs-heading-anchor" href="#FD*utils.divs(func,-so*fact1,-side-1)">FD<em>utils.divs(func, so</em>fact=1, side=- 1)</a><a id="FD*utils.divs(func,-so*fact1,-side-1)-1"></a><a class="docs-heading-anchor-permalink" href="#FD*utils.divs(func,-so*fact1,-side-1)" title="Permalink"></a></h3><p>GrDivergenceadient shifted by half a grid point, only to be used in combination with grads.</p><h3 id="FD*utils.grads(func,-so*fact1,-side1)"><a class="docs-heading-anchor" href="#FD*utils.grads(func,-so*fact1,-side1)">FD<em>utils.grads(func, so</em>fact=1, side=1)</a><a id="FD*utils.grads(func,-so*fact1,-side1)-1"></a><a class="docs-heading-anchor-permalink" href="#FD*utils.grads(func,-so*fact1,-side1)" title="Permalink"></a></h3><p>Gradient shifted by half a grid point, only to be used in combination with divs.</p><h3 id="FD_utils.laplacian(v,-irho)"><a class="docs-heading-anchor" href="#FD_utils.laplacian(v,-irho)">FD_utils.laplacian(v, irho)</a><a id="FD_utils.laplacian(v,-irho)-1"></a><a class="docs-heading-anchor-permalink" href="#FD_utils.laplacian(v,-irho)" title="Permalink"></a></h3><p>Laplacian with density div( 1/rho grad) (u)</p><h3 id="FD*utils.sa*tti(u,-v,-model)"><a class="docs-heading-anchor" href="#FD*utils.sa*tti(u,-v,-model)">FD<em>utils.sa</em>tti(u, v, model)</a><a id="FD*utils.sa*tti(u,-v,-model)-1"></a><a class="docs-heading-anchor-permalink" href="#FD*utils.sa*tti(u,-v,-model)" title="Permalink"></a></h3><p>Tensor factorized SSA TTI wave equation spatial derivatives.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction</em>) – first TTI field</li></ul></li></ul><pre><code class="language-none">* **v** (*TimeFunction*) – second TTI field


* **model** (*Model*) – Model structure</code></pre><h3 id="FD*utils.thomsen*mat(model)"><a class="docs-heading-anchor" href="#FD*utils.thomsen*mat(model)">FD<em>utils.thomsen</em>mat(model)</a><a id="FD*utils.thomsen*mat(model)-1"></a><a class="docs-heading-anchor-permalink" href="#FD*utils.thomsen*mat(model)" title="Permalink"></a></h3><p>Diagonal Matrices with Thomsen parameters for vectorial temporaries computation.</p><ul><li><p><strong>Parameters</strong></p><p><strong>model</strong> (<em>Model</em>) – Model structure</p></li></ul><h2 id="checkpoint-module"><a class="docs-heading-anchor" href="#checkpoint-module">checkpoint module</a><a id="checkpoint-module-1"></a><a class="docs-heading-anchor-permalink" href="#checkpoint-module" title="Permalink"></a></h2><h3 id="*class*-checkpoint.CheckpointOperator(op,-**kwargs)"><a class="docs-heading-anchor" href="#*class*-checkpoint.CheckpointOperator(op,-**kwargs)"><em>class</em> checkpoint.CheckpointOperator(op, **kwargs)</a><a id="*class*-checkpoint.CheckpointOperator(op,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-checkpoint.CheckpointOperator(op,-**kwargs)" title="Permalink"></a></h3><p>Devito’s concrete implementation of the ABC pyrevolve.Operator. This class wraps devito.Operator so it conforms to the pyRevolve API. pyRevolve will call apply with arguments t<em>start and t</em>end. Devito calls these arguments t<em>s and t</em>e so the following dict is used to perform the translations between different names.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>op</strong> (<em>Operator</em>) – devito.Operator object that this object will wrap.</li></ul></li></ul><pre><code class="language-none">* **args** (*dict*) – If devito.Operator.apply() expects any arguments, they can be provided
here to be cached. Any calls to CheckpointOperator.apply() will
automatically include these cached arguments in the call to the
underlying devito.Operator.apply().</code></pre><h4 id="apply(t*start,-t*end)"><a class="docs-heading-anchor" href="#apply(t*start,-t*end)">apply(t<em>start, t</em>end)</a><a id="apply(t*start,-t*end)-1"></a><a class="docs-heading-anchor-permalink" href="#apply(t*start,-t*end)" title="Permalink"></a></h4><p>If the devito operator requires some extra arguments in the call to apply they can be stored in the args property of this object so pyRevolve calls pyRevolve.Operator.apply() without caring about these extra arguments while this method passes them on correctly to devito.Operator</p><h4 id="t*arg*names(_-{&#39;t*end&#39;:-&#39;time*M&#39;,-&#39;t*start&#39;:-&#39;time*m&#39;_-)"><a class="docs-heading-anchor" href="#t*arg*names(_-{&#39;t*end&#39;:-&#39;time*M&#39;,-&#39;t*start&#39;:-&#39;time*m&#39;_-)">t<em>arg</em>names(_ = {&#39;t<em>end&#39;: &#39;time</em>M&#39;, &#39;t<em>start&#39;: &#39;time</em>m&#39;_ )</a><a id="t*arg*names(_-{&#39;t*end&#39;:-&#39;time*M&#39;,-&#39;t*start&#39;:-&#39;time*m&#39;_-)-1"></a><a class="docs-heading-anchor-permalink" href="#t*arg*names(_-{&#39;t*end&#39;:-&#39;time*M&#39;,-&#39;t*start&#39;:-&#39;time*m&#39;_-)" title="Permalink"></a></h4><h3 id="*class*-checkpoint.DevitoCheckpoint(objects)"><a class="docs-heading-anchor" href="#*class*-checkpoint.DevitoCheckpoint(objects)"><em>class</em> checkpoint.DevitoCheckpoint(objects)</a><a id="*class*-checkpoint.DevitoCheckpoint(objects)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-checkpoint.DevitoCheckpoint(objects)" title="Permalink"></a></h3><p>Devito’s concrete implementation of the Checkpoint abstract base class provided by pyRevolve. Holds a list of symbol objects that hold data.</p><h4 id="*property*-dtype()"><a class="docs-heading-anchor" href="#*property*-dtype()"><em>property</em> dtype()</a><a id="*property*-dtype()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-dtype()" title="Permalink"></a></h4><p>data type</p><h4 id="get_data(timestep)"><a class="docs-heading-anchor" href="#get_data(timestep)">get_data(timestep)</a><a id="get_data(timestep)-1"></a><a class="docs-heading-anchor-permalink" href="#get_data(timestep)" title="Permalink"></a></h4><p>returns the data (wavefield) for the time-step timestep</p><h4 id="get*data*location(timestep)"><a class="docs-heading-anchor" href="#get*data*location(timestep)">get<em>data</em>location(timestep)</a><a id="get*data*location(timestep)-1"></a><a class="docs-heading-anchor-permalink" href="#get*data*location(timestep)" title="Permalink"></a></h4><p>returns the data (wavefield) for the time-step timestep</p><h4 id="load()"><a class="docs-heading-anchor" href="#load()">load()</a><a id="load()-1"></a><a class="docs-heading-anchor-permalink" href="#load()" title="Permalink"></a></h4><p>NotImplementedError</p><h4 id="save()"><a class="docs-heading-anchor" href="#save()">save()</a><a id="save()-1"></a><a class="docs-heading-anchor-permalink" href="#save()" title="Permalink"></a></h4><p>NotImplementedError</p><h4 id="*property*-size()"><a class="docs-heading-anchor" href="#*property*-size()"><em>property</em> size()</a><a id="*property*-size()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-size()" title="Permalink"></a></h4><p>The memory consumption of the data contained in a checkpoint.</p><h3 id="checkpoint.get*symbol*data(symbol,-timestep)"><a class="docs-heading-anchor" href="#checkpoint.get*symbol*data(symbol,-timestep)">checkpoint.get<em>symbol</em>data(symbol, timestep)</a><a id="checkpoint.get*symbol*data(symbol,-timestep)-1"></a><a class="docs-heading-anchor-permalink" href="#checkpoint.get*symbol*data(symbol,-timestep)" title="Permalink"></a></h3><p>Return the symbol corresponding to the data at time-step timestep</p><h2 id="geom_utils-module"><a class="docs-heading-anchor" href="#geom_utils-module">geom_utils module</a><a id="geom_utils-module-1"></a><a class="docs-heading-anchor-permalink" href="#geom_utils-module" title="Permalink"></a></h2><h3 id="geom*utils.src*rec(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-fwTrue,-ntNone)"><a class="docs-heading-anchor" href="#geom*utils.src*rec(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-fwTrue,-ntNone)">geom<em>utils.src</em>rec(model, u, src<em>coords=None, rec</em>coords=None, wavelet=None, fw=True, nt=None)</a><a id="geom*utils.src*rec(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-fwTrue,-ntNone)-1"></a><a class="docs-heading-anchor-permalink" href="#geom*utils.src*rec(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-fwTrue,-ntNone)" title="Permalink"></a></h3><p>Generates the source injection and receiver interpolation. This function is fully abstracted and does not care whether this is a forward or adjoint wave-equation. The source is the source term of the equation The receiver is the measurment term</p><p>Therefore, for the adjoint, this function has to be called as: src<em>rec(model, v, src</em>coords=rec_coords, …) because the data is the sources</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u** (*TimeFunction** or **tuple*) – Wavefield to inject into and read from


* **src_coords** (*Array*) – Physical coordinates of the sources


* **rec_coords** (*Array*) – Physical coordinates of the receivers


* **wavelet** (*Array*) – Data for the source


* **fw=True** – Whether the direction is forward or backward in time


* **nt** (*int*) – Number of time steps</code></pre><h2 id="interface-module"><a class="docs-heading-anchor" href="#interface-module">interface module</a><a id="interface-module-1"></a><a class="docs-heading-anchor-permalink" href="#interface-module" title="Permalink"></a></h2><h3 id="interface.J*adjoint(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-checkpointingFalse,-n*checkpointsNone,-t*sub1,-return*objFalse,-freq*list[],-dft*subNone,-isicFalse,-wsNone,-f00.015,-born_fwdFalse)"><a class="docs-heading-anchor" href="#interface.J*adjoint(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-checkpointingFalse,-n*checkpointsNone,-t*sub1,-return*objFalse,-freq*list[],-dft*subNone,-isicFalse,-wsNone,-f00.015,-born_fwdFalse)">interface.J<em>adjoint(model, src</em>coords, wavelet, rec<em>coords, recin, space</em>order=8, is<em>residual=False, checkpointing=False, n</em>checkpoints=None, t<em>sub=1, return</em>obj=False, freq<em>list=[], dft</em>sub=None, isic=False, ws=None, f0=0.015, born_fwd=False)</a><a id="interface.J*adjoint(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-checkpointingFalse,-n*checkpointsNone,-t*sub1,-return*objFalse,-freq*list[],-dft*subNone,-isicFalse,-wsNone,-f00.015,-born_fwdFalse)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.J*adjoint(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-checkpointingFalse,-n*checkpointsNone,-t*sub1,-return*objFalse,-freq*list[],-dft*subNone,-isicFalse,-wsNone,-f00.015,-born_fwdFalse)" title="Permalink"></a></h3><p>Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Supports three modes: * Checkpinting * Frequency compression (on-the-fly DFT) * Standard zero lag cross correlation over time</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **src_coords** (*Array*) – Coordiantes of the source(s)


* **wavelet** (*Array*) – Source signature


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **recin** (*Array*) – Receiver data


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **checkpointing** (*Bool*) – Whether or not to use checkpointing


* **n_checkpoints** (*Int*) – Number of checkpoints for checkpointing


* **maxmem** (*Float*) – Maximum memory to use for checkpointing


* **freq_list** (*List*) – List of frequencies for on-the-fly DFT


* **dft_sub** (*Int*) – Subsampling factor for on-the-fly DFT


* **isic** (*Bool*) – Whether or not to use ISIC imaging condition


* **ws** (*Array*) – Extended source spatial distribution


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Adjoint jacobian on the input data (gradient)</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.J*adjoint*checkpointing(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-n*checkpointsNone,-born*fwdFalse,-return_objFalse,-isicFalse,-wsNone,-nlindFalse,-f00.015)"><a class="docs-heading-anchor" href="#interface.J*adjoint*checkpointing(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-n*checkpointsNone,-born*fwdFalse,-return_objFalse,-isicFalse,-wsNone,-nlindFalse,-f00.015)">interface.J<em>adjoint</em>checkpointing(model, src<em>coords, wavelet, rec</em>coords, recin, space<em>order=8, is</em>residual=False, n<em>checkpoints=None, born</em>fwd=False, return_obj=False, isic=False, ws=None, nlind=False, f0=0.015)</a><a id="interface.J*adjoint*checkpointing(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-n*checkpointsNone,-born*fwdFalse,-return_objFalse,-isicFalse,-wsNone,-nlindFalse,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.J*adjoint*checkpointing(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-n*checkpointsNone,-born*fwdFalse,-return_objFalse,-isicFalse,-wsNone,-nlindFalse,-f00.015)" title="Permalink"></a></h3><p>Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with Checkpointing.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **src_coords** (*Array*) – Coordiantes of the source(s)


* **wavelet** (*Array*) – Source signature


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **recin** (*Array*) – Receiver data


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **checkpointing** (*Bool*) – Whether or not to use checkpointing


* **n_checkpoints** (*Int*) – Number of checkpoints for checkpointing


* **maxmem** (*Float*) – Maximum memory to use for checkpointing


* **isic** (*Bool*) – Whether or not to use ISIC imaging condition


* **ws** (*Array*) – Extended source spatial distribution


* **is_residual** (*Bool*) – Whether to treat the input as the residual or as the observed data


* **born_fwd** (*Bool*) – Whether to use the forward or linearized forward modeling operator


* **nlind** (*Bool*) – Whether to remove the non linear data from the input data. This option is
only available in combination with born_fwd


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Adjoint jacobian on the input data (gradient)</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.J*adjoint*freq(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-freq*list[],-is*residualFalse,-return*objFalse,-nlindFalse,-dft*subNone,-isicFalse,-wsNone,-born*fwdFalse,-f00.015)"><a class="docs-heading-anchor" href="#interface.J*adjoint*freq(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-freq*list[],-is*residualFalse,-return*objFalse,-nlindFalse,-dft*subNone,-isicFalse,-wsNone,-born*fwdFalse,-f00.015)">interface.J<em>adjoint</em>freq(model, src<em>coords, wavelet, rec</em>coords, recin, space<em>order=8, freq</em>list=[], is<em>residual=False, return</em>obj=False, nlind=False, dft<em>sub=None, isic=False, ws=None, born</em>fwd=False, f0=0.015)</a><a id="interface.J*adjoint*freq(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-freq*list[],-is*residualFalse,-return*objFalse,-nlindFalse,-dft*subNone,-isicFalse,-wsNone,-born*fwdFalse,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.J*adjoint*freq(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-freq*list[],-is*residualFalse,-return*objFalse,-nlindFalse,-dft*subNone,-isicFalse,-wsNone,-born*fwdFalse,-f00.015)" title="Permalink"></a></h3><p>Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with Frequency compression (on-the-fly DFT).</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **src_coords** (*Array*) – Coordiantes of the source(s)


* **wavelet** (*Array*) – Source signature


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **recin** (*Array*) – Receiver data


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **freq_list** (*List*) – List of frequencies for on-the-fly DFT


* **dft_sub** (*Int*) – Subsampling factor for on-the-fly DFT


* **isic** (*Bool*) – Whether or not to use ISIC imaging condition


* **ws** (*Array*) – Extended source spatial distribution


* **is_residual** (*Bool*) – Whether to treat the input as the residual or as the observed data


* **born_fwd** (*Bool*) – Whether to use the forward or linearized forward modeling operator


* **nlind** (*Bool*) – Whether to remove the non linear data from the input data. This option is
only available in combination with born_fwd


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Adjoint jacobian on the input data (gradient)</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.J*adjoint*standard(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-return*objFalse,-born*fwdFalse,-isicFalse,-wsNone,-t_sub1,-nlindFalse,-f00.015)"><a class="docs-heading-anchor" href="#interface.J*adjoint*standard(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-return*objFalse,-born*fwdFalse,-isicFalse,-wsNone,-t_sub1,-nlindFalse,-f00.015)">interface.J<em>adjoint</em>standard(model, src<em>coords, wavelet, rec</em>coords, recin, space<em>order=8, is</em>residual=False, return<em>obj=False, born</em>fwd=False, isic=False, ws=None, t_sub=1, nlind=False, f0=0.015)</a><a id="interface.J*adjoint*standard(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-return*objFalse,-born*fwdFalse,-isicFalse,-wsNone,-t_sub1,-nlindFalse,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.J*adjoint*standard(model,-src*coords,-wavelet,-rec*coords,-recin,-space*order8,-is*residualFalse,-return*objFalse,-born*fwdFalse,-isicFalse,-wsNone,-t_sub1,-nlindFalse,-f00.015)" title="Permalink"></a></h3><p>Adjoint Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with standard zero lag cross correlation over time.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **src_coords** (*Array*) – Coordiantes of the source(s)


* **wavelet** (*Array*) – Source signature


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **recin** (*Array*) – Receiver data


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **isic** (*Bool*) – Whether or not to use ISIC imaging condition


* **ws** (*Array*) – Extended source spatial distribution


* **is_residual** (*Bool*) – Whether to treat the input as the residual or as the observed data


* **born_fwd** (*Bool*) – Whether to use the forward or linearized forward modeling operator


* **nlind** (*Bool*) – Whether to remove the non linear data from the input data. This option is
only available in combination with born_fwd


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Adjoint jacobian on the input data (gradient)</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.adjoint*no*rec(model,-rec*coords,-data,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.adjoint*no*rec(model,-rec*coords,-data,-space*order8,-f00.015)">interface.adjoint<em>no</em>rec(model, rec<em>coords, data, space</em>order=8, f0=0.015)</a><a id="interface.adjoint*no*rec(model,-rec*coords,-data,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.adjoint*no*rec(model,-rec*coords,-data,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Adjoint/backward modeling of a shot record (receivers as source) without source sampling F^T*Pr^T*d_obs.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **data** (*Array*) – Shot gather


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Adjoint wavefield</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.adjoint*rec(model,-src*coords,-rec*coords,-data,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.adjoint*rec(model,-src*coords,-rec*coords,-data,-space*order8,-f00.015)">interface.adjoint<em>rec(model, src</em>coords, rec<em>coords, data, space</em>order=8, f0=0.015)</a><a id="interface.adjoint*rec(model,-src*coords,-rec*coords,-data,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.adjoint*rec(model,-src*coords,-rec*coords,-data,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Adjoint/backward modeling of a shot record (receivers as source) Ps*F^T*Pr^T*d.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **src_coords** (*Array*) – Coordiantes of the source(s)


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **data** (*Array*) – Shot gather


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Shot record (adjoint wavefield at source position(s))</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.adjoint*w(model,-rec*coords,-data,-wavelet,-space_order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.adjoint*w(model,-rec*coords,-data,-wavelet,-space_order8,-f00.015)">interface.adjoint<em>w(model, rec</em>coords, data, wavelet, space_order=8, f0=0.015)</a><a id="interface.adjoint*w(model,-rec*coords,-data,-wavelet,-space_order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.adjoint*w(model,-rec*coords,-data,-wavelet,-space_order8,-f00.015)" title="Permalink"></a></h3><p>Adjoint/backward modeling of a shot record (receivers as source) for an extended source setup Pw*F^T*Pr^T*d_obs.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **data** (*Array*) – Shot gather


* **wavelet** (*Array*) – Time signature of the forward source for stacking along time


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>spatial distribution</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.adjoint*wf*src(model,-u,-src*coords,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.adjoint*wf*src(model,-u,-src*coords,-space*order8,-f00.015)">interface.adjoint<em>wf</em>src(model, u, src<em>coords, space</em>order=8, f0=0.015)</a><a id="interface.adjoint*wf*src(model,-u,-src*coords,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.adjoint*wf*src(model,-u,-src*coords,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Adjoint/backward modeling of a full wavefield (full wavefield as adjoint source) Ps*F^T*u.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u** (*Array** or **TimeFunction*) – Time-space dependent source


* **src_coords** (*Array*) – Source coordinates


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Shot record (sampled at source position(s))</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.adjoint*wf*src*norec(model,-u,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.adjoint*wf*src*norec(model,-u,-space*order8,-f00.015)">interface.adjoint<em>wf</em>src<em>norec(model, u, space</em>order=8, f0=0.015)</a><a id="interface.adjoint*wf*src*norec(model,-u,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.adjoint*wf*src*norec(model,-u,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Adjoint/backward modeling of a full wavefield (full wavefield as adjoint source) F^T*u.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u** (*Array** or **TimeFunction*) – Time-space dependent source


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Adjoint wavefield</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.born*rec(model,-src*coords,-wavelet,-rec*coords,-space*order8,-isicFalse,-f00.015)"><a class="docs-heading-anchor" href="#interface.born*rec(model,-src*coords,-wavelet,-rec*coords,-space*order8,-isicFalse,-f00.015)">interface.born<em>rec(model, src</em>coords, wavelet, rec<em>coords, space</em>order=8, isic=False, f0=0.015)</a><a id="interface.born*rec(model,-src*coords,-wavelet,-rec*coords,-space*order8,-isicFalse,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.born*rec(model,-src*coords,-wavelet,-rec*coords,-space*order8,-isicFalse,-f00.015)" title="Permalink"></a></h3><p>Linearized (Born) modeling of a point source for a model perturbation (square slowness) dm.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **src_coords** (*Array*) – Coordiantes of the source(s)


* **wavelet** (*Array*) – Source signature


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **isic** (*Bool*) – Whether or not to use ISIC imaging condition


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Shot record</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.born*rec*w(model,-weight,-wavelet,-rec*coords,-space*order8,-isicFalse,-f00.015)"><a class="docs-heading-anchor" href="#interface.born*rec*w(model,-weight,-wavelet,-rec*coords,-space*order8,-isicFalse,-f00.015)">interface.born<em>rec</em>w(model, weight, wavelet, rec<em>coords, space</em>order=8, isic=False, f0=0.015)</a><a id="interface.born*rec*w(model,-weight,-wavelet,-rec*coords,-space*order8,-isicFalse,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.born*rec*w(model,-weight,-wavelet,-rec*coords,-space*order8,-isicFalse,-f00.015)" title="Permalink"></a></h3><p>Linearized (Born) modeling of an extended source for a model perturbation (square slowness) dm with an extended source</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **weight** (*Array*) – Spatial distriubtion of the extended source


* **wavelet** (*Array*) – Source signature


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **isic** (*Bool*) – Whether or not to use ISIC imaging condition


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Shot record</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.forward*no*rec(model,-src*coords,-wavelet,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.forward*no*rec(model,-src*coords,-wavelet,-space*order8,-f00.015)">interface.forward<em>no</em>rec(model, src<em>coords, wavelet, space</em>order=8, f0=0.015)</a><a id="interface.forward*no*rec(model,-src*coords,-wavelet,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*no*rec(model,-src*coords,-wavelet,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Forward modeling of a point source without receiver.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **src_coords** (*Array*) – Coordiantes of the source(s)


* **wavelet** (*Array*) – Source signature


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Wavefield</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.forward*rec(model,-src*coords,-wavelet,-rec*coords,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.forward*rec(model,-src*coords,-wavelet,-rec*coords,-space*order8,-f00.015)">interface.forward<em>rec(model, src</em>coords, wavelet, rec<em>coords, space</em>order=8, f0=0.015)</a><a id="interface.forward*rec(model,-src*coords,-wavelet,-rec*coords,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*rec(model,-src*coords,-wavelet,-rec*coords,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Forward modeling of a point source with receivers Pr*F*Ps^T*q.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **src_coords** (*Array*) – Coordiantes of the source(s)


* **wavelet** (*Array*) – Source signature


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Shot record</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.forward*rec*w(model,-weight,-wavelet,-rec*coords,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.forward*rec*w(model,-weight,-wavelet,-rec*coords,-space*order8,-f00.015)">interface.forward<em>rec</em>w(model, weight, wavelet, rec<em>coords, space</em>order=8, f0=0.015)</a><a id="interface.forward*rec*w(model,-weight,-wavelet,-rec*coords,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*rec*w(model,-weight,-wavelet,-rec*coords,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Forward modeling of an extended source with receivers  Pr*F*Pw^T*w</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **weights** (*Array*) – Spatial distribution of the extended source.


* **wavelet** (*Array*) – Source signature


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Shot record</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.forward*rec*wf(model,-src*coords,-wavelet,-rec*coords,-t*sub1,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.forward*rec*wf(model,-src*coords,-wavelet,-rec*coords,-t*sub1,-space*order8,-f00.015)">interface.forward<em>rec</em>wf(model, src<em>coords, wavelet, rec</em>coords, t<em>sub=1, space</em>order=8, f0=0.015)</a><a id="interface.forward*rec*wf(model,-src*coords,-wavelet,-rec*coords,-t*sub1,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*rec*wf(model,-src*coords,-wavelet,-rec*coords,-t*sub1,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Forward modeling of a point source Pr*F*Ps^T*q and return wavefield.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **src_coords** (*Array*) – Coordiantes of the source(s)


* **wavelet** (*Array*) – Source signature


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><ul><li><em>Array</em> – Shot record</li></ul></li></ul><pre><code class="language-none">* *TimeFunction* – Wavefield</code></pre><h3 id="interface.forward*wf*src(model,-u,-rec*coords,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.forward*wf*src(model,-u,-rec*coords,-space*order8,-f00.015)">interface.forward<em>wf</em>src(model, u, rec<em>coords, space</em>order=8, f0=0.015)</a><a id="interface.forward*wf*src(model,-u,-rec*coords,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*wf*src(model,-u,-rec*coords,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Forward modeling of a full wavefield source Pr*F*u.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u** (*TimeFunction** or **Array*) – Time-space dependent wavefield


* **rec_coords** (*Array*) – Coordiantes of the receiver(s)


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Shot record</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.forward*wf*src*norec(model,-u,-space*order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.forward*wf*src*norec(model,-u,-space*order8,-f00.015)">interface.forward<em>wf</em>src<em>norec(model, u, space</em>order=8, f0=0.015)</a><a id="interface.forward*wf*src*norec(model,-u,-space*order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*wf*src*norec(model,-u,-space*order8,-f00.015)" title="Permalink"></a></h3><p>Forward modeling of a full wavefield source without receiver F*u.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u** (*TimeFunction** or **Array*) – Time-space dependent wavefield


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>Wavefield</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.grad*fwi(model,-recin,-rec*coords,-u,-space_order8,-f00.015)"><a class="docs-heading-anchor" href="#interface.grad*fwi(model,-recin,-rec*coords,-u,-space_order8,-f00.015)">interface.grad<em>fwi(model, recin, rec</em>coords, u, space_order=8, f0=0.015)</a><a id="interface.grad*fwi(model,-recin,-rec*coords,-u,-space_order8,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.grad*fwi(model,-recin,-rec*coords,-u,-space_order8,-f00.015)" title="Permalink"></a></h3><p>FWI gradient, i.e adjoint Jacobian on a data residual.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **recin** (*Array*) – Data residual


* **rec_coords** (*Array*) – Receivers coordinates


* **u** (*TimeFunction*) – Forward wavefield


* **space_order** (*Int** (**optional**)*) – Spatial discretization order, defaults to 8


* **f0** (*peak frequency*) –</code></pre><ul><li><p><strong>Returns</strong></p><p>FWI gradient</p></li></ul><ul><li><p><strong>Return type</strong></p><p>Array</p></li></ul><h3 id="interface.wri*func(model,-src*coords,-wavelet,-rec*coords,-recin,-yin,-space*order8,-isicFalse,-wsNone,-t*sub1,-grad&#39;m&#39;,-grad*corrFalse,-alpha*opFalse,-w*funNone,-eps0,-freq_list[],-wfiltNone,-f00.015)"><a class="docs-heading-anchor" href="#interface.wri*func(model,-src*coords,-wavelet,-rec*coords,-recin,-yin,-space*order8,-isicFalse,-wsNone,-t*sub1,-grad&#39;m&#39;,-grad*corrFalse,-alpha*opFalse,-w*funNone,-eps0,-freq_list[],-wfiltNone,-f00.015)">interface.wri<em>func(model, src</em>coords, wavelet, rec<em>coords, recin, yin, space</em>order=8, isic=False, ws=None, t<em>sub=1, grad=&#39;m&#39;, grad</em>corr=False, alpha<em>op=False, w</em>fun=None, eps=0, freq_list=[], wfilt=None, f0=0.015)</a><a id="interface.wri*func(model,-src*coords,-wavelet,-rec*coords,-recin,-yin,-space*order8,-isicFalse,-wsNone,-t*sub1,-grad&#39;m&#39;,-grad*corrFalse,-alpha*opFalse,-w*funNone,-eps0,-freq_list[],-wfiltNone,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.wri*func(model,-src*coords,-wavelet,-rec*coords,-recin,-yin,-space*order8,-isicFalse,-wsNone,-t*sub1,-grad&#39;m&#39;,-grad*corrFalse,-alpha*opFalse,-w*funNone,-eps0,-freq_list[],-wfiltNone,-f00.015)" title="Permalink"></a></h3><p>Time domain wavefield reconstruction inversion wrapper</p><h2 id="kernels-module"><a class="docs-heading-anchor" href="#kernels-module">kernels module</a><a id="kernels-module-1"></a><a class="docs-heading-anchor-permalink" href="#kernels-module" title="Permalink"></a></h2><h3 id="kernels.SLS*2nd*order(model,-p,-fwTrue,-qNone,-f00.015)"><a class="docs-heading-anchor" href="#kernels.SLS*2nd*order(model,-p,-fwTrue,-qNone,-f00.015)">kernels.SLS<em>2nd</em>order(model, p, fw=True, q=None, f0=0.015)</a><a id="kernels.SLS*2nd*order(model,-p,-fwTrue,-qNone,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.SLS*2nd*order(model,-p,-fwTrue,-qNone,-f00.015)" title="Permalink"></a></h3><p>Viscoacoustic 2nd SLS wave equation. <a href="https://library.seg.org/doi/10.1190/geo2013-0030.1">https://library.seg.org/doi/10.1190/geo2013-0030.1</a></p><p>Bulk modulus moved to rhs. The adjoint equation is directly derived as the discrete adjoint of the forward PDE which leads to a slightly different formulation than in the paper.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u1** (*TimeFunction*) – Pressure field


* **u2** (*TimeFunction*) – Attenuation Memory variable


* **fw** (*Bool*) – Whether forward or backward in time propagation


* **q** (*TimeFunction** or **Expr*) – Full time-space source as a tuple (one value for each component)


* **f0** (*Peak frequency*) –</code></pre><h3 id="kernels.acoustic_kernel(model,-u,-fwTrue,-qNone)"><a class="docs-heading-anchor" href="#kernels.acoustic_kernel(model,-u,-fwTrue,-qNone)">kernels.acoustic_kernel(model, u, fw=True, q=None)</a><a id="kernels.acoustic_kernel(model,-u,-fwTrue,-qNone)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.acoustic_kernel(model,-u,-fwTrue,-qNone)" title="Permalink"></a></h3><p>Acoustic wave equation time stepper</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u** (*TimeFunction** or **tuple*) – wavefield (tuple if TTI)


* **fw** (*Bool*) – Whether forward or backward in time propagation


* **q** (*TimeFunction** or **Expr*) – Full time-space source</code></pre><h3 id="kernels.tti_kernel(model,-u1,-u2,-fwTrue,-qNone)"><a class="docs-heading-anchor" href="#kernels.tti_kernel(model,-u1,-u2,-fwTrue,-qNone)">kernels.tti_kernel(model, u1, u2, fw=True, q=None)</a><a id="kernels.tti_kernel(model,-u1,-u2,-fwTrue,-qNone)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.tti_kernel(model,-u1,-u2,-fwTrue,-qNone)" title="Permalink"></a></h3><p>TTI wave equation (one from my paper) time stepper</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u1** (*TimeFunction*) – First component (pseudo-P) of the wavefield


* **u2** (*TimeFunction*) – First component (pseudo-P) of the wavefield


* **fw** (*Bool*) – Whether forward or backward in time propagation


* **q** (*TimeFunction** or **Expr*) – Full time-space source as a tuple (one value for each component)</code></pre><h3 id="kernels.wave_kernel(model,-u,-fwTrue,-qNone,-f00.015)"><a class="docs-heading-anchor" href="#kernels.wave_kernel(model,-u,-fwTrue,-qNone,-f00.015)">kernels.wave_kernel(model, u, fw=True, q=None, f0=0.015)</a><a id="kernels.wave_kernel(model,-u,-fwTrue,-qNone,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.wave_kernel(model,-u,-fwTrue,-qNone,-f00.015)" title="Permalink"></a></h3><p>Pde kernel corresponding the the model for the input wavefield</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u** (*TimeFunction** or **tuple*) – wavefield (tuple if TTI or Viscoacoustic)


* **fw** (*Bool*) – Whether forward or backward in time propagation


* **q** (*TimeFunction** or **Expr*) – Full time-space source


* **f0** (*Peak frequency*) –</code></pre><h2 id="models-module"><a class="docs-heading-anchor" href="#models-module">models module</a><a id="models-module-1"></a><a class="docs-heading-anchor-permalink" href="#models-module" title="Permalink"></a></h2><h3 id="*class*-models.Model(origin,-spacing,-shape,-m,-space_order2,-nbl40,-dtypeclass-&#39;numpy.float32&#39;,-epsilonNone,-deltaNone,-thetaNone,-phiNone,-rho1,-qpNone,-dmNone,-fsFalse,-**kwargs)"><a class="docs-heading-anchor" href="#*class*-models.Model(origin,-spacing,-shape,-m,-space_order2,-nbl40,-dtypeclass-&#39;numpy.float32&#39;,-epsilonNone,-deltaNone,-thetaNone,-phiNone,-rho1,-qpNone,-dmNone,-fsFalse,-**kwargs)"><em>class</em> models.Model(origin, spacing, shape, m, space_order=2, nbl=40, dtype=&lt;class &#39;numpy.float32&#39;&gt;, epsilon=None, delta=None, theta=None, phi=None, rho=1, qp=None, dm=None, fs=False, **kwargs)</a><a id="*class*-models.Model(origin,-spacing,-shape,-m,-space_order2,-nbl40,-dtypeclass-&#39;numpy.float32&#39;,-epsilonNone,-deltaNone,-thetaNone,-phiNone,-rho1,-qpNone,-dmNone,-fsFalse,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-models.Model(origin,-spacing,-shape,-m,-space_order2,-nbl40,-dtypeclass-&#39;numpy.float32&#39;,-epsilonNone,-deltaNone,-thetaNone,-phiNone,-rho1,-qpNone,-dmNone,-fsFalse,-**kwargs)" title="Permalink"></a></h3><p>The physical model used in seismic inversion processes.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>origin</strong> (<em>tuple of floats</em>) – Origin of the model in m as a tuple in (x,y,z) order.</li></ul></li></ul><pre><code class="language-none">* **spacing** (*tuple of floats*) – Grid size in m as a Tuple in (x,y,z) order.


* **shape** (*tuple of int*) – Number of grid points size in (x,y,z) order.


* **space_order** (*int*) – Order of the spatial stencil discretisation.


* **m** (*array_like** or **float*) – Squared slownes in s^2/km^2


* **nbl** (*int**, **optional*) – The number of absorbin layers for boundary damping.


* **dtype** (*np.float32** or **np.float64*) – Defaults to 32.


* **epsilon** (*array_like** or **float**, **optional*) – Thomsen epsilon parameter (0&lt;epsilon&lt;1).


* **delta** (*array_like** or **float*) – Thomsen delta parameter (0&lt;delta&lt;1), delta&lt;epsilon.


* **theta** (*array_like** or **float*) – Tilt angle in radian.


* **phi** (*array_like** or **float*) – Asymuth angle in radian.


* **dt** (*Float*) – User provided computational time-step</code></pre><h4 id="*property*-critical_dt()"><a class="docs-heading-anchor" href="#*property*-critical_dt()"><em>property</em> critical_dt()</a><a id="*property*-critical_dt()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-critical_dt()" title="Permalink"></a></h4><p>Critical computational time step value from the CFL condition.</p><h4 id="*property*-dm()"><a class="docs-heading-anchor" href="#*property*-dm()"><em>property</em> dm()</a><a id="*property*-dm()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-dm()" title="Permalink"></a></h4><p>Model perturbation for linearized modeling</p><h4 id="*property*-dt()"><a class="docs-heading-anchor" href="#*property*-dt()"><em>property</em> dt()</a><a id="*property*-dt()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-dt()" title="Permalink"></a></h4><p>User provided dt</p><h4 id="*property*-is_tti()"><a class="docs-heading-anchor" href="#*property*-is_tti()"><em>property</em> is_tti()</a><a id="*property*-is_tti()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-is_tti()" title="Permalink"></a></h4><p>Whether the model is TTI or isotopic</p><h4 id="*property*-is_viscoacoustic()"><a class="docs-heading-anchor" href="#*property*-is_viscoacoustic()"><em>property</em> is_viscoacoustic()</a><a id="*property*-is_viscoacoustic()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-is_viscoacoustic()" title="Permalink"></a></h4><p>Whether the model is TTI or isotopic</p><h4 id="*property*-m()"><a class="docs-heading-anchor" href="#*property*-m()"><em>property</em> m()</a><a id="*property*-m()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-m()" title="Permalink"></a></h4><p>Function holding the squared slowness in s^2/km^2.</p><h4 id="*property*-space_order()"><a class="docs-heading-anchor" href="#*property*-space_order()"><em>property</em> space_order()</a><a id="*property*-space_order()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-space_order()" title="Permalink"></a></h4><p>Spatial discretization order</p><h4 id="*property*-spacing_map()"><a class="docs-heading-anchor" href="#*property*-spacing_map()"><em>property</em> spacing_map()</a><a id="*property*-spacing_map()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-spacing_map()" title="Permalink"></a></h4><p>Map between spacing symbols and their values for each SpaceDimension.</p><h4 id="*property*-vp()"><a class="docs-heading-anchor" href="#*property*-vp()"><em>property</em> vp()</a><a id="*property*-vp()-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-vp()" title="Permalink"></a></h4><p>Symbolic representation of the velocity vp = sqrt(1 / m)</p><h2 id="propagators-module"><a class="docs-heading-anchor" href="#propagators-module">propagators module</a><a id="propagators-module-1"></a><a class="docs-heading-anchor-permalink" href="#propagators-module" title="Permalink"></a></h2><h3 id="propagators.adjoint(model,-y,-src*coords,-rcv*coords,-space*order8,-q0,-dft*subNone,-saveFalse,-wsNone,-norm*vFalse,-w*funNone,-freq_listNone,-f00.015)"><a class="docs-heading-anchor" href="#propagators.adjoint(model,-y,-src*coords,-rcv*coords,-space*order8,-q0,-dft*subNone,-saveFalse,-wsNone,-norm*vFalse,-w*funNone,-freq_listNone,-f00.015)">propagators.adjoint(model, y, src<em>coords, rcv</em>coords, space<em>order=8, q=0, dft</em>sub=None, save=False, ws=None, norm<em>v=False, w</em>fun=None, freq_list=None, f0=0.015)</a><a id="propagators.adjoint(model,-y,-src*coords,-rcv*coords,-space*order8,-q0,-dft*subNone,-saveFalse,-wsNone,-norm*vFalse,-w*funNone,-freq_listNone,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.adjoint(model,-y,-src*coords,-rcv*coords,-space*order8,-q0,-dft*subNone,-saveFalse,-wsNone,-norm*vFalse,-w*funNone,-freq_listNone,-f00.015)" title="Permalink"></a></h3><p>Low level propagator, to be used through interface.py Compute adjoint wavefield v = adjoint(F(m))*y and related quantities (||v||_w, v(xsrc))</p><h3 id="propagators.born(model,-src*coords,-rcv*coords,-wavelet,-space*order8,-saveFalse,-qNone,-return*opFalse,-isicFalse,-freq*listNone,-dft*subNone,-wsNone,-t_sub1,-nlindFalse,-f00.015)"><a class="docs-heading-anchor" href="#propagators.born(model,-src*coords,-rcv*coords,-wavelet,-space*order8,-saveFalse,-qNone,-return*opFalse,-isicFalse,-freq*listNone,-dft*subNone,-wsNone,-t_sub1,-nlindFalse,-f00.015)">propagators.born(model, src<em>coords, rcv</em>coords, wavelet, space<em>order=8, save=False, q=None, return</em>op=False, isic=False, freq<em>list=None, dft</em>sub=None, ws=None, t_sub=1, nlind=False, f0=0.015)</a><a id="propagators.born(model,-src*coords,-rcv*coords,-wavelet,-space*order8,-saveFalse,-qNone,-return*opFalse,-isicFalse,-freq*listNone,-dft*subNone,-wsNone,-t_sub1,-nlindFalse,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.born(model,-src*coords,-rcv*coords,-wavelet,-space*order8,-saveFalse,-qNone,-return*opFalse,-isicFalse,-freq*listNone,-dft*subNone,-wsNone,-t_sub1,-nlindFalse,-f00.015)" title="Permalink"></a></h3><p>Low level propagator, to be used through interface.py Compute linearized wavefield U = J(m)* δ m and related quantities.</p><h3 id="propagators.forward(model,-src*coords,-rcv*coords,-wavelet,-space*order8,-saveFalse,-qNone,-return*opFalse,-freq*listNone,-dft*subNone,-wsNone,-t_sub1,-f00.015,-**kwargs)"><a class="docs-heading-anchor" href="#propagators.forward(model,-src*coords,-rcv*coords,-wavelet,-space*order8,-saveFalse,-qNone,-return*opFalse,-freq*listNone,-dft*subNone,-wsNone,-t_sub1,-f00.015,-**kwargs)">propagators.forward(model, src<em>coords, rcv</em>coords, wavelet, space<em>order=8, save=False, q=None, return</em>op=False, freq<em>list=None, dft</em>sub=None, ws=None, t_sub=1, f0=0.015, **kwargs)</a><a id="propagators.forward(model,-src*coords,-rcv*coords,-wavelet,-space*order8,-saveFalse,-qNone,-return*opFalse,-freq*listNone,-dft*subNone,-wsNone,-t_sub1,-f00.015,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.forward(model,-src*coords,-rcv*coords,-wavelet,-space*order8,-saveFalse,-qNone,-return*opFalse,-freq*listNone,-dft*subNone,-wsNone,-t_sub1,-f00.015,-**kwargs)" title="Permalink"></a></h3><p>Low level propagator, to be used through interface.py Compute forward wavefield u = A(m)^{-1}*f and related quantities (u(xrcv))</p><h3 id="propagators.forward*grad(model,-src*coords,-rcv*coords,-wavelet,-v,-space*order8,-qNone,-wsNone,-isicFalse,-wNone,-freqNone,-f00.015,-**kwargs)"><a class="docs-heading-anchor" href="#propagators.forward*grad(model,-src*coords,-rcv*coords,-wavelet,-v,-space*order8,-qNone,-wsNone,-isicFalse,-wNone,-freqNone,-f00.015,-**kwargs)">propagators.forward<em>grad(model, src</em>coords, rcv<em>coords, wavelet, v, space</em>order=8, q=None, ws=None, isic=False, w=None, freq=None, f0=0.015, **kwargs)</a><a id="propagators.forward*grad(model,-src*coords,-rcv*coords,-wavelet,-v,-space*order8,-qNone,-wsNone,-isicFalse,-wNone,-freqNone,-f00.015,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.forward*grad(model,-src*coords,-rcv*coords,-wavelet,-v,-space*order8,-qNone,-wsNone,-isicFalse,-wNone,-freqNone,-f00.015,-**kwargs)" title="Permalink"></a></h3><p>Low level propagator, to be used through interface.py Compute forward wavefield u = A(m)^{-1}*f and related quantities (u(xrcv))</p><h3 id="propagators.gradient(model,-residual,-rcv*coords,-u,-return*opFalse,-space*order8,-wNone,-freqNone,-dft*subNone,-isicFalse,-f00.015)"><a class="docs-heading-anchor" href="#propagators.gradient(model,-residual,-rcv*coords,-u,-return*opFalse,-space*order8,-wNone,-freqNone,-dft*subNone,-isicFalse,-f00.015)">propagators.gradient(model, residual, rcv<em>coords, u, return</em>op=False, space<em>order=8, w=None, freq=None, dft</em>sub=None, isic=False, f0=0.015)</a><a id="propagators.gradient(model,-residual,-rcv*coords,-u,-return*opFalse,-space*order8,-wNone,-freqNone,-dft*subNone,-isicFalse,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.gradient(model,-residual,-rcv*coords,-u,-return*opFalse,-space*order8,-wNone,-freqNone,-dft*subNone,-isicFalse,-f00.015)" title="Permalink"></a></h3><p>Low level propagator, to be used through interface.py Compute the action of the adjoint Jacobian onto a residual J’* δ d.</p><h3 id="propagators.name(model)"><a class="docs-heading-anchor" href="#propagators.name(model)">propagators.name(model)</a><a id="propagators.name(model)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.name(model)" title="Permalink"></a></h3><h2 id="sensitivity-module"><a class="docs-heading-anchor" href="#sensitivity-module">sensitivity module</a><a id="sensitivity-module-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity-module" title="Permalink"></a></h2><h3 id="sensitivity.basic_src(model,-u,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.basic_src(model,-u,-**kwargs)">sensitivity.basic_src(model, u, **kwargs)</a><a id="sensitivity.basic_src(model,-u,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.basic_src(model,-u,-**kwargs)" title="Permalink"></a></h3><p>Basic source for linearized modeling</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><pre><code class="language-none">* **model** (*Model*) – Model containing the perturbation dm</code></pre><h3 id="sensitivity.crosscorr*freq(u,-v,-model,-freqNone,-dft*subNone,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.crosscorr*freq(u,-v,-model,-freqNone,-dft*subNone,-**kwargs)">sensitivity.crosscorr<em>freq(u, v, model, freq=None, dft</em>sub=None, **kwargs)</a><a id="sensitivity.crosscorr*freq(u,-v,-model,-freqNone,-dft*subNone,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.crosscorr*freq(u,-v,-model,-freqNone,-dft*subNone,-**kwargs)" title="Permalink"></a></h3><p>Standard cross-correlation imaging condition with on-th-fly-dft</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><pre><code class="language-none">* **v** (*TimeFunction** or **Tuple*) – Adjoint wavefield (tuple of fields for TTI)


* **model** (*Model*) – Model structure


* **freq** (*Array*) – Array of frequencies for on-the-fly DFT


* **factor** (*int*) – Subsampling factor for DFT</code></pre><h3 id="sensitivity.crosscorr_time(u,-v,-model,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.crosscorr_time(u,-v,-model,-**kwargs)">sensitivity.crosscorr_time(u, v, model, **kwargs)</a><a id="sensitivity.crosscorr_time(u,-v,-model,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.crosscorr_time(u,-v,-model,-**kwargs)" title="Permalink"></a></h3><p>Cross correlation of forward and adjoint wavefield</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><pre><code class="language-none">* **v** (*TimeFunction** or **Tuple*) – Adjoint wavefield (tuple of fields for TTI)


* **model** (*Model*) – Model structure</code></pre><h3 id="sensitivity.func_name(freqNone,-isicFalse)"><a class="docs-heading-anchor" href="#sensitivity.func_name(freqNone,-isicFalse)">sensitivity.func_name(freq=None, isic=False)</a><a id="sensitivity.func_name(freqNone,-isicFalse)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.func_name(freqNone,-isicFalse)" title="Permalink"></a></h3><p>Get key for imaging condition/linearized source function</p><h3 id="sensitivity.grad*expr(gradm,-u,-v,-model,-wNone,-freqNone,-dft*subNone,-isicFalse)"><a class="docs-heading-anchor" href="#sensitivity.grad*expr(gradm,-u,-v,-model,-wNone,-freqNone,-dft*subNone,-isicFalse)">sensitivity.grad<em>expr(gradm, u, v, model, w=None, freq=None, dft</em>sub=None, isic=False)</a><a id="sensitivity.grad*expr(gradm,-u,-v,-model,-wNone,-freqNone,-dft*subNone,-isicFalse)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.grad*expr(gradm,-u,-v,-model,-wNone,-freqNone,-dft*subNone,-isicFalse)" title="Permalink"></a></h3><p>Gradient update stencil</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><pre><code class="language-none">* **v** (*TimeFunction** or **Tuple*) – Adjoint wavefield (tuple of fields for TTI)


* **model** (*Model*) – Model structure


* **w** (*Float** or **Expr** (**optional**)*) – Weight for the gradient expression (default=1)


* **freq** (*Array*) – Array of frequencies for on-the-fly DFT


* **factor** (*int*) – Subsampling factor for DFT


* **isic** (*Bool*) – Whether or not to use inverse scattering imaging condition (not supported yet)</code></pre><h3 id="sensitivity.inner_grad(u,-v)"><a class="docs-heading-anchor" href="#sensitivity.inner_grad(u,-v)">sensitivity.inner_grad(u, v)</a><a id="sensitivity.inner_grad(u,-v)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.inner_grad(u,-v)" title="Permalink"></a></h3><p>Inner product of the gradient of two Function.</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Function</em>) – First wavefield</li></ul></li></ul><pre><code class="language-none">* **v** (*TimeFunction** or **Function*) – Second wavefield</code></pre><h3 id="sensitivity.isic_freq(u,-v,-model,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.isic_freq(u,-v,-model,-**kwargs)">sensitivity.isic_freq(u, v, model, **kwargs)</a><a id="sensitivity.isic_freq(u,-v,-model,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.isic_freq(u,-v,-model,-**kwargs)" title="Permalink"></a></h3><p>Inverse scattering imaging condition</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><pre><code class="language-none">* **v** (*TimeFunction** or **Tuple*) – Adjoint wavefield (tuple of fields for TTI)


* **model** (*Model*) – Model structure</code></pre><h3 id="sensitivity.isic_src(model,-u,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.isic_src(model,-u,-**kwargs)">sensitivity.isic_src(model, u, **kwargs)</a><a id="sensitivity.isic_src(model,-u,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.isic_src(model,-u,-**kwargs)" title="Permalink"></a></h3><p>ISIC source for linearized modeling</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><pre><code class="language-none">* **model** (*Model*) – Model containing the perturbation dm</code></pre><h3 id="sensitivity.isic_time(u,-v,-model,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.isic_time(u,-v,-model,-**kwargs)">sensitivity.isic_time(u, v, model, **kwargs)</a><a id="sensitivity.isic_time(u,-v,-model,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.isic_time(u,-v,-model,-**kwargs)" title="Permalink"></a></h3><p>Inverse scattering imaging condition</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><pre><code class="language-none">* **v** (*TimeFunction** or **Tuple*) – Adjoint wavefield (tuple of fields for TTI)


* **model** (*Model*) – Model structure</code></pre><h3 id="sensitivity.l2*loss(dsyn,-dobs,-dt,-is*residualFalse)"><a class="docs-heading-anchor" href="#sensitivity.l2*loss(dsyn,-dobs,-dt,-is*residualFalse)">sensitivity.l2<em>loss(dsyn, dobs, dt, is</em>residual=False)</a><a id="sensitivity.l2*loss(dsyn,-dobs,-dt,-is*residualFalse)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.l2*loss(dsyn,-dobs,-dt,-is*residualFalse)" title="Permalink"></a></h3><p>L2 loss and residual between the synthetic data dsyn and observed data dobs</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>dsyn</strong> (<em>SparseTimeFunction** or **tuple</em>) – Synthetic data or tuple (background, linearized) data</li></ul></li></ul><pre><code class="language-none">* **dobs** (*SparseTimeFunction*) – Observed data


* **dt** (*float*) – Time sampling rate


* **is_residual** (*bool*) – Whether input dobs is already the data residual</code></pre><h3 id="sensitivity.lin_src(model,-u,-isicFalse)"><a class="docs-heading-anchor" href="#sensitivity.lin_src(model,-u,-isicFalse)">sensitivity.lin_src(model, u, isic=False)</a><a id="sensitivity.lin_src(model,-u,-isicFalse)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.lin_src(model,-u,-isicFalse)" title="Permalink"></a></h3><p>Source for linearized modeling</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><pre><code class="language-none">* **model** (*Model*) – Model containing the perturbation dm</code></pre><h2 id="sources-module"><a class="docs-heading-anchor" href="#sources-module">sources module</a><a id="sources-module-1"></a><a class="docs-heading-anchor-permalink" href="#sources-module" title="Permalink"></a></h2><h3 id="*class*-sources.PointSource(*args,-**kwargs)"><a class="docs-heading-anchor" href="#*class*-sources.PointSource(*args,-**kwargs)"><em>class</em> sources.PointSource(*args, **kwargs)</a><a id="*class*-sources.PointSource(*args,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-sources.PointSource(*args,-**kwargs)" title="Permalink"></a></h3><p>Symbolic data object for a set of sparse point sources</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>name</strong> (<em>String</em>) – Name of the symbol representing this source</li></ul></li></ul><pre><code class="language-none">* **grid** (*Grid*) – Grid object defining the computational domain.


* **coordinates** (*Array*) – Point coordinates for this source


* **data** (*(**Optional**) **Data*) – values to initialise point data


* **ntime** (*Int** (**Optional**)*) – Number of timesteps for which to allocate data


* **npoint** (*Int** (**Optional**)*) – 


* **of sparse points represented by this source** (*Number*) – 


* **dimension** (*Dimension** (**Optional**)*) – object for representing the number of points in this source


* **either the dimensions ntime and npoint**** or ****the fully** (*Note**,*) – 


* **data array need to be provided.** (*initialised*) –</code></pre><h4 id="default*assumptions(*-{&#39;commutative&#39;:-True,-&#39;complex&#39;:-True,-&#39;extended*real&#39;:-True,-&#39;finite&#39;:-True,-&#39;hermitian&#39;:-True,-&#39;imaginary&#39;:-False,-&#39;infinite&#39;:-False,-&#39;real&#39;:-True*-)"><a class="docs-heading-anchor" href="#default*assumptions(*-{&#39;commutative&#39;:-True,-&#39;complex&#39;:-True,-&#39;extended*real&#39;:-True,-&#39;finite&#39;:-True,-&#39;hermitian&#39;:-True,-&#39;imaginary&#39;:-False,-&#39;infinite&#39;:-False,-&#39;real&#39;:-True*-)">default<em>assumptions(</em> = {&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;extended<em>real&#39;: True, &#39;finite&#39;: True, &#39;hermitian&#39;: True, &#39;imaginary&#39;: False, &#39;infinite&#39;: False, &#39;real&#39;: True</em> )</a><a id="default*assumptions(*-{&#39;commutative&#39;:-True,-&#39;complex&#39;:-True,-&#39;extended*real&#39;:-True,-&#39;finite&#39;:-True,-&#39;hermitian&#39;:-True,-&#39;imaginary&#39;:-False,-&#39;infinite&#39;:-False,-&#39;real&#39;:-True*-)-1"></a><a class="docs-heading-anchor-permalink" href="#default*assumptions(*-{&#39;commutative&#39;:-True,-&#39;complex&#39;:-True,-&#39;extended*real&#39;:-True,-&#39;finite&#39;:-True,-&#39;hermitian&#39;:-True,-&#39;imaginary&#39;:-False,-&#39;infinite&#39;:-False,-&#39;real&#39;:-True*-)" title="Permalink"></a></h4><h4 id="is*commutative(*-Tru_-)"><a class="docs-heading-anchor" href="#is*commutative(*-Tru_-)">is<em>commutative(</em> = Tru_ )</a><a id="is*commutative(*-Tru_-)-1"></a><a class="docs-heading-anchor-permalink" href="#is*commutative(*-Tru_-)" title="Permalink"></a></h4><h4 id="is*complex(*-Tru_-)"><a class="docs-heading-anchor" href="#is*complex(*-Tru_-)">is<em>complex(</em> = Tru_ )</a><a id="is*complex(*-Tru_-)-1"></a><a class="docs-heading-anchor-permalink" href="#is*complex(*-Tru_-)" title="Permalink"></a></h4><h4 id="is*extended*real(_-Tru_-)"><a class="docs-heading-anchor" href="#is*extended*real(_-Tru_-)">is<em>extended</em>real(_ = Tru_ )</a><a id="is*extended*real(_-Tru_-)-1"></a><a class="docs-heading-anchor-permalink" href="#is*extended*real(_-Tru_-)" title="Permalink"></a></h4><h4 id="is*finite(*-Tru_-)"><a class="docs-heading-anchor" href="#is*finite(*-Tru_-)">is<em>finite(</em> = Tru_ )</a><a id="is*finite(*-Tru_-)-1"></a><a class="docs-heading-anchor-permalink" href="#is*finite(*-Tru_-)" title="Permalink"></a></h4><h4 id="is*hermitian(*-Tru_-)"><a class="docs-heading-anchor" href="#is*hermitian(*-Tru_-)">is<em>hermitian(</em> = Tru_ )</a><a id="is*hermitian(*-Tru_-)-1"></a><a class="docs-heading-anchor-permalink" href="#is*hermitian(*-Tru_-)" title="Permalink"></a></h4><h4 id="is*imaginary(*-Fals_-)"><a class="docs-heading-anchor" href="#is*imaginary(*-Fals_-)">is<em>imaginary(</em> = Fals_ )</a><a id="is*imaginary(*-Fals_-)-1"></a><a class="docs-heading-anchor-permalink" href="#is*imaginary(*-Fals_-)" title="Permalink"></a></h4><h4 id="is*infinite(*-Fals_-)"><a class="docs-heading-anchor" href="#is*infinite(*-Fals_-)">is<em>infinite(</em> = Fals_ )</a><a id="is*infinite(*-Fals_-)-1"></a><a class="docs-heading-anchor-permalink" href="#is*infinite(*-Fals_-)" title="Permalink"></a></h4><h4 id="is*real(*-Tru_-)"><a class="docs-heading-anchor" href="#is*real(*-Tru_-)">is<em>real(</em> = Tru_ )</a><a id="is*real(*-Tru_-)-1"></a><a class="docs-heading-anchor-permalink" href="#is*real(*-Tru_-)" title="Permalink"></a></h4><h3 id="sources.Receiver()"><a class="docs-heading-anchor" href="#sources.Receiver()">sources.Receiver()</a><a id="sources.Receiver()-1"></a><a class="docs-heading-anchor-permalink" href="#sources.Receiver()" title="Permalink"></a></h3><p>alias of <code>sources.PointSource</code></p><h3 id="*class*-sources.RickerSource(*args,-**kwargs)"><a class="docs-heading-anchor" href="#*class*-sources.RickerSource(*args,-**kwargs)"><em>class</em> sources.RickerSource(*args, **kwargs)</a><a id="*class*-sources.RickerSource(*args,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-sources.RickerSource(*args,-**kwargs)" title="Permalink"></a></h3><p>Symbolic object that encapsulate a set of sources with a pre-defined Ricker wavelet: <a href="http://subsurfwiki.org/wiki/Ricker_wavelet">http://subsurfwiki.org/wiki/Ricker_wavelet</a> name: Name for the resulting symbol grid: <code>Grid</code> object defining the computational domain. f0: Peak frequency for Ricker wavelet in kHz time: Discretized values of time in ms</p><h4 id="default*assumptions(*-{&#39;commutative&#39;:-True,-&#39;complex&#39;:-True,-&#39;extended*real&#39;:-True,-&#39;finite&#39;:-True,-&#39;hermitian&#39;:-True,-&#39;imaginary&#39;:-False,-&#39;infinite&#39;:-False,-&#39;real&#39;:-True*-)-2"><a class="docs-heading-anchor" href="#default*assumptions(*-{&#39;commutative&#39;:-True,-&#39;complex&#39;:-True,-&#39;extended*real&#39;:-True,-&#39;finite&#39;:-True,-&#39;hermitian&#39;:-True,-&#39;imaginary&#39;:-False,-&#39;infinite&#39;:-False,-&#39;real&#39;:-True*-)-2">default<em>assumptions(</em> = {&#39;commutative&#39;: True, &#39;complex&#39;: True, &#39;extended<em>real&#39;: True, &#39;finite&#39;: True, &#39;hermitian&#39;: True, &#39;imaginary&#39;: False, &#39;infinite&#39;: False, &#39;real&#39;: True</em> )</a><a class="docs-heading-anchor-permalink" href="#default*assumptions(*-{&#39;commutative&#39;:-True,-&#39;complex&#39;:-True,-&#39;extended*real&#39;:-True,-&#39;finite&#39;:-True,-&#39;hermitian&#39;:-True,-&#39;imaginary&#39;:-False,-&#39;infinite&#39;:-False,-&#39;real&#39;:-True*-)-2" title="Permalink"></a></h4><h4 id="is*commutative(*-Tru_-)-2"><a class="docs-heading-anchor" href="#is*commutative(*-Tru_-)-2">is<em>commutative(</em> = Tru_ )</a><a class="docs-heading-anchor-permalink" href="#is*commutative(*-Tru_-)-2" title="Permalink"></a></h4><h4 id="is*complex(*-Tru_-)-2"><a class="docs-heading-anchor" href="#is*complex(*-Tru_-)-2">is<em>complex(</em> = Tru_ )</a><a class="docs-heading-anchor-permalink" href="#is*complex(*-Tru_-)-2" title="Permalink"></a></h4><h4 id="is*extended*real(_-Tru_-)-2"><a class="docs-heading-anchor" href="#is*extended*real(_-Tru_-)-2">is<em>extended</em>real(_ = Tru_ )</a><a class="docs-heading-anchor-permalink" href="#is*extended*real(_-Tru_-)-2" title="Permalink"></a></h4><h4 id="is*finite(*-Tru_-)-2"><a class="docs-heading-anchor" href="#is*finite(*-Tru_-)-2">is<em>finite(</em> = Tru_ )</a><a class="docs-heading-anchor-permalink" href="#is*finite(*-Tru_-)-2" title="Permalink"></a></h4><h4 id="is*hermitian(*-Tru_-)-2"><a class="docs-heading-anchor" href="#is*hermitian(*-Tru_-)-2">is<em>hermitian(</em> = Tru_ )</a><a class="docs-heading-anchor-permalink" href="#is*hermitian(*-Tru_-)-2" title="Permalink"></a></h4><h4 id="is*imaginary(*-Fals_-)-2"><a class="docs-heading-anchor" href="#is*imaginary(*-Fals_-)-2">is<em>imaginary(</em> = Fals_ )</a><a class="docs-heading-anchor-permalink" href="#is*imaginary(*-Fals_-)-2" title="Permalink"></a></h4><h4 id="is*infinite(*-Fals_-)-2"><a class="docs-heading-anchor" href="#is*infinite(*-Fals_-)-2">is<em>infinite(</em> = Fals_ )</a><a class="docs-heading-anchor-permalink" href="#is*infinite(*-Fals_-)-2" title="Permalink"></a></h4><h4 id="is*real(*-Tru_-)-2"><a class="docs-heading-anchor" href="#is*real(*-Tru_-)-2">is<em>real(</em> = Tru_ )</a><a class="docs-heading-anchor-permalink" href="#is*real(*-Tru_-)-2" title="Permalink"></a></h4><h4 id="wavelet(timev)"><a class="docs-heading-anchor" href="#wavelet(timev)">wavelet(timev)</a><a id="wavelet(timev)-1"></a><a class="docs-heading-anchor-permalink" href="#wavelet(timev)" title="Permalink"></a></h4><h3 id="*class*-sources.TimeAxis(startNone,-stepNone,-numNone,-stopNone)"><a class="docs-heading-anchor" href="#*class*-sources.TimeAxis(startNone,-stepNone,-numNone,-stopNone)"><em>class</em> sources.TimeAxis(start=None, step=None, num=None, stop=None)</a><a id="*class*-sources.TimeAxis(startNone,-stepNone,-numNone,-stopNone)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-sources.TimeAxis(startNone,-stepNone,-numNone,-stopNone)" title="Permalink"></a></h3><p>Data object to store the TimeAxis. Exactly three of the four key arguments must be prescribed. Because of remainder values it is not possible to create a TimeAxis that exactly adhears to the inputs therefore start, stop, step and num values should be taken from the TimeAxis object rather than relying upon the input values. The four possible cases are: * start is None: start = step*(1 - num) + stop * step is None: step = (stop - start)/(num - 1) * num is None: num = ceil((stop - start + step)/step) and because of remainder stop = step*(num - 1) + start * stop is None: stop = step*(num - 1) + start</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>start</strong> (<em>float**, **optional</em>) – Start of time axis.</li></ul></li></ul><pre><code class="language-none">* **step** (*float**, **optional*) – Time interval.


* **num** (*int**, **optional*) – Number of values (Note: this is the number of intervals + 1).
Stop value is reset to correct for remainder.


* **stop** (*float**, **optional*) – End time.</code></pre><h4 id="time_values()"><a class="docs-heading-anchor" href="#time_values()">time_values()</a><a id="time_values()-1"></a><a class="docs-heading-anchor-permalink" href="#time_values()" title="Permalink"></a></h4><h2 id="wave_utils-module"><a class="docs-heading-anchor" href="#wave_utils-module">wave_utils module</a><a id="wave_utils-module-1"></a><a class="docs-heading-anchor-permalink" href="#wave_utils-module" title="Permalink"></a></h2><h3 id="wave*utils.extended*src_weights(model,-wavelet,-v)"><a class="docs-heading-anchor" href="#wave*utils.extended*src_weights(model,-wavelet,-v)">wave<em>utils.extended</em>src_weights(model, wavelet, v)</a><a id="wave*utils.extended*src_weights(model,-wavelet,-v)-1"></a><a class="docs-heading-anchor-permalink" href="#wave*utils.extended*src_weights(model,-wavelet,-v)" title="Permalink"></a></h3><p>Adjoint of extended source. This function returns the expression to obtain the spatially varrying weights from the wavefield and time-dependent wavelet</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model structure</li></ul></li></ul><pre><code class="language-none">* **wavelet** (*Array*) – Time-serie for the time-varying source


* **v** (*TimeFunction*) – Wavefield to get the weights from</code></pre><h3 id="wave*utils.extented*src(model,-weight,-wavelet,-q0)"><a class="docs-heading-anchor" href="#wave*utils.extented*src(model,-weight,-wavelet,-q0)">wave<em>utils.extented</em>src(model, weight, wavelet, q=0)</a><a id="wave*utils.extented*src(model,-weight,-wavelet,-q0)-1"></a><a class="docs-heading-anchor-permalink" href="#wave*utils.extented*src(model,-weight,-wavelet,-q0)" title="Permalink"></a></h3><p>Extended source for modelling where the source is the outer product of a spatially varying weight and a time-dependent wavelet i.e.: u.dt2 - u.laplace = w(x)*q(t) This function returns the extended source w(x)*q(t)</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model structure</li></ul></li></ul><pre><code class="language-none">* **weight** (*Array*) – Array of weight for the spatial Function


* **wavelet** (*Array*) – Time-serie for the time-varying source


* **q** (*Symbol** or **Expr** (**optional**)*) – Previously existing source to be added to (source will be q +  w(x)\*q(t))</code></pre><h3 id="wave_utils.freesurface(model,-eq)"><a class="docs-heading-anchor" href="#wave_utils.freesurface(model,-eq)">wave_utils.freesurface(model, eq)</a><a id="wave_utils.freesurface(model,-eq)-1"></a><a class="docs-heading-anchor-permalink" href="#wave_utils.freesurface(model,-eq)" title="Permalink"></a></h3><p>Generate the stencil that mirrors the field as a free surface modeling for the acoustic wave equation</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **eq** (*Eq** or **List of Eq*) – Equation to apply mirror to</code></pre><h3 id="wave_utils.idft(v,-freqNone)"><a class="docs-heading-anchor" href="#wave_utils.idft(v,-freqNone)">wave_utils.idft(v, freq=None)</a><a id="wave_utils.idft(v,-freqNone)-1"></a><a class="docs-heading-anchor-permalink" href="#wave_utils.idft(v,-freqNone)" title="Permalink"></a></h3><p>Symbolic inverse dft of v</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>v</strong> (<em>TimeFunction** or **Tuple</em>) – Wavefield to take inverse DFT of</li></ul></li></ul><pre><code class="language-none">* **freq** (*Array*) – Array of frequencies for on-the-fly DFT</code></pre><h3 id="wave*utils.otf*dft(u,-freq,-dt,-factorNone)"><a class="docs-heading-anchor" href="#wave*utils.otf*dft(u,-freq,-dt,-factorNone)">wave<em>utils.otf</em>dft(u, freq, dt, factor=None)</a><a id="wave*utils.otf*dft(u,-freq,-dt,-factorNone)-1"></a><a class="docs-heading-anchor-permalink" href="#wave*utils.otf*dft(u,-freq,-dt,-factorNone)" title="Permalink"></a></h3><p>On the fly DFT wavefield (frequency slices) and expression</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u** (*TimeFunction** or **Tuple*) – Forward wavefield


* **freq** (*Array*) – Array of frequencies for on-the-fly DFT


* **factor** (*int*) – Subsampling factor for DFT</code></pre><h3 id="wave*utils.sub*time(time,-factor,-dt1,-freqNone)"><a class="docs-heading-anchor" href="#wave*utils.sub*time(time,-factor,-dt1,-freqNone)">wave<em>utils.sub</em>time(time, factor, dt=1, freq=None)</a><a id="wave*utils.sub*time(time,-factor,-dt1,-freqNone)-1"></a><a class="docs-heading-anchor-permalink" href="#wave*utils.sub*time(time,-factor,-dt1,-freqNone)" title="Permalink"></a></h3><p>Subsampled  time axis</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>time</strong> (<em>Dimension</em>) – time Dimension</li></ul></li></ul><pre><code class="language-none">* **factor** (*int*) – Subsampling factor</code></pre><h3 id="wave*utils.wavefield(model,-space*order,-saveFalse,-ntNone,-fwTrue,-name&#39;&#39;,-t_sub1)"><a class="docs-heading-anchor" href="#wave*utils.wavefield(model,-space*order,-saveFalse,-ntNone,-fwTrue,-name&#39;&#39;,-t_sub1)">wave<em>utils.wavefield(model, space</em>order, save=False, nt=None, fw=True, name=&#39;&#39;, t_sub=1)</a><a id="wave*utils.wavefield(model,-space*order,-saveFalse,-ntNone,-fwTrue,-name&#39;&#39;,-t_sub1)-1"></a><a class="docs-heading-anchor-permalink" href="#wave*utils.wavefield(model,-space*order,-saveFalse,-ntNone,-fwTrue,-name&#39;&#39;,-t_sub1)" title="Permalink"></a></h3><p>Create the wavefield for the wave equation</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **space_order** (*int*) – Spatial discretization order


* **save** (*Bool*) – Whether or not to save the time history


* **nt** (*int** (**optional**)*) – Number of time steps if the wavefield is saved


* **fw** (*Bool*) – Forward or backward (for naming)


* **name** (*string*) – Custom name attached to default (u+name)</code></pre><h3 id="wave*utils.wavefield*subsampled(model,-u,-nt,-t*sub,-space*order8)"><a class="docs-heading-anchor" href="#wave*utils.wavefield*subsampled(model,-u,-nt,-t*sub,-space*order8)">wave<em>utils.wavefield</em>subsampled(model, u, nt, t<em>sub, space</em>order=8)</a><a id="wave*utils.wavefield*subsampled(model,-u,-nt,-t*sub,-space*order8)-1"></a><a class="docs-heading-anchor-permalink" href="#wave*utils.wavefield*subsampled(model,-u,-nt,-t*sub,-space*order8)" title="Permalink"></a></h3><p>Create a subsampled wavefield</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model</li></ul></li></ul><pre><code class="language-none">* **u** (*TimeFunction*) – Forward wavefield for modeling


* **nt** (*int*) – Number of time steps on original time axis


* **t_sub** (*int*) – Factor for time-subsampling


* **space_order** (*int*) – Spatial discretization order</code></pre><h3 id="wave*utils.weighted*norm(u,-weightNone)"><a class="docs-heading-anchor" href="#wave*utils.weighted*norm(u,-weightNone)">wave<em>utils.weighted</em>norm(u, weight=None)</a><a id="wave*utils.weighted*norm(u,-weightNone)-1"></a><a class="docs-heading-anchor-permalink" href="#wave*utils.weighted*norm(u,-weightNone)" title="Permalink"></a></h3><p>Space-time norm of a wavefield, split into norm in time first then in space to avoid breaking loops</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>u</strong> (<em>TimeFunction** or **Tuple of TimeFunction</em>) – Wavefield to take the norm of</li></ul></li></ul><pre><code class="language-none">* **weight** (*String*) – Spacial weight to apply</code></pre><h3 id="wave*utils.wf*as*src(v,-w1,-freq*listNone)"><a class="docs-heading-anchor" href="#wave*utils.wf*as*src(v,-w1,-freq*listNone)">wave<em>utils.wf</em>as<em>src(v, w=1, freq</em>list=None)</a><a id="wave*utils.wf*as*src(v,-w1,-freq*listNone)-1"></a><a class="docs-heading-anchor-permalink" href="#wave*utils.wf*as*src(v,-w1,-freq*listNone)" title="Permalink"></a></h3><p>Weighted source as a time-space wavefield</p><ul><li><p><strong>Parameters</strong></p><ul><li><strong>model</strong> (<em>Model</em>) – Physical model structure</li></ul></li></ul><pre><code class="language-none">* **u** (*TimeFunction** or **Tuple*) – Forward wavefield (tuple of fields for TTI or dft)


* **w** (*Float** or **Expr** (**optional**)*) – Weight for the source expression (default=1)</code></pre><h2 id="Module-contents"><a class="docs-heading-anchor" href="#Module-contents">Module contents</a><a id="Module-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Module-contents" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/">« Tutorial</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 20 April 2022 17:25">Wednesday 20 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
