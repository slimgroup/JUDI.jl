<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Devito backend reference · JUDI documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JUDI documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../about/">About</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../basics/">Getting Started</a></li><li><span class="tocitem">JUDI API</span><ul><li><a class="tocitem" href="../abstract_vectors/">Abstract vectors</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../linear_operators/">Linear Operators</a></li><li><a class="tocitem" href="../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../io/">Input/Output</a></li><li><a class="tocitem" href="../helper/">Helper Functions</a></li></ul></li><li><a class="tocitem" href="../inversion/">Inversion</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/01_intro/">Introduction to JUDI</a></li><li><a class="tocitem" href="../tutorials/02_fwi_example_NLopt/">FWI with Quasi-Newton methods from the NLopt library</a></li><li><a class="tocitem" href="../tutorials/03_constrained_fwi/">FWI Example</a></li><li><a class="tocitem" href="../tutorials/04_judi_leading_edge_tutorial/">Full-Waveform Inversion - Part 3: optimization</a></li><li><a class="tocitem" href="../tutorials/05_custom_misfit/">FWI with user provided misfit function</a></li><li><a class="tocitem" href="../tutorials/06_automatic_differentiation/">Automatic differentiation with JUDI</a></li><li><a class="tocitem" href="../tutorials/07_preconditionners/">Seismic preconditionners</a></li><li><a class="tocitem" href="../tutorials/imaging_conditions/">Imaging conditions in JUDI</a></li><li><a class="tocitem" href="../tutorials/quickstart/">Modeling and inversion with JUDI</a></li></ul></li><li class="is-active"><a class="tocitem" href>Devito backend reference</a><ul class="internal"><li><a class="tocitem" href="#Submodules"><span>Submodules</span></a></li><li><a class="tocitem" href="#FD_utils-module"><span>FD_utils module</span></a></li><li><a class="tocitem" href="#checkpoint-module"><span>checkpoint module</span></a></li><li><a class="tocitem" href="#geom_utils-module"><span>geom_utils module</span></a></li><li><a class="tocitem" href="#interface-module"><span>interface module</span></a></li><li><a class="tocitem" href="#kernels-module"><span>kernels module</span></a></li><li><a class="tocitem" href="#models-module"><span>models module</span></a></li><li><a class="tocitem" href="#propagators-module"><span>propagators module</span></a></li><li><a class="tocitem" href="#sensitivity-module"><span>sensitivity module</span></a></li><li><a class="tocitem" href="#sources-module"><span>sources module</span></a></li><li><a class="tocitem" href="#wave_utils-module"><span>wave_utils module</span></a></li><li><a class="tocitem" href="#Module-contents"><span>Module contents</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Devito backend reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Devito backend reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/JUDI.jl/blob/master/docs/src/pysource.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="pysource-package"><a class="docs-heading-anchor" href="#pysource-package">pysource package</a><a id="pysource-package-1"></a><a class="docs-heading-anchor-permalink" href="#pysource-package" title="Permalink"></a></h1><h2 id="Submodules"><a class="docs-heading-anchor" href="#Submodules">Submodules</a><a id="Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Submodules" title="Permalink"></a></h2><h2 id="FD_utils-module"><a class="docs-heading-anchor" href="#FD_utils-module">FD_utils module</a><a id="FD_utils-module-1"></a><a class="docs-heading-anchor-permalink" href="#FD_utils-module" title="Permalink"></a></h2><h3 id="FD*utils.R*mat(model)"><a class="docs-heading-anchor" href="#FD*utils.R*mat(model)">FD<em>utils.R</em>mat(model)</a><a id="FD*utils.R*mat(model)-1"></a><a class="docs-heading-anchor-permalink" href="#FD*utils.R*mat(model)" title="Permalink"></a></h3><p>Rotation matrix according to tilt and asymut.</p><ul><li><strong>Parameters:</strong> <strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model structure</li></ul><h3 id="FD_utils.laplacian(v,-irho)"><a class="docs-heading-anchor" href="#FD_utils.laplacian(v,-irho)">FD_utils.laplacian(v, irho)</a><a id="FD_utils.laplacian(v,-irho)-1"></a><a class="docs-heading-anchor-permalink" href="#FD_utils.laplacian(v,-irho)" title="Permalink"></a></h3><p>Laplacian with density div( 1/rho grad) (u)</p><h3 id="FD_utils.r2(x)"><a class="docs-heading-anchor" href="#FD_utils.r2(x)">FD_utils.r2(x)</a><a id="FD_utils.r2(x)-1"></a><a class="docs-heading-anchor-permalink" href="#FD_utils.r2(x)" title="Permalink"></a></h3><h3 id="FD_utils.r3(x)"><a class="docs-heading-anchor" href="#FD_utils.r3(x)">FD_utils.r3(x)</a><a id="FD_utils.r3(x)-1"></a><a class="docs-heading-anchor-permalink" href="#FD_utils.r3(x)" title="Permalink"></a></h3><h3 id="FD*utils.sa*tti(u,-v,-model)"><a class="docs-heading-anchor" href="#FD*utils.sa*tti(u,-v,-model)">FD<em>utils.sa</em>tti(u, v, model)</a><a id="FD*utils.sa*tti(u,-v,-model)-1"></a><a class="docs-heading-anchor-permalink" href="#FD*utils.sa*tti(u,-v,-model)" title="Permalink"></a></h3><p>Tensor factorized SSA TTI wave equation spatial derivatives.</p><ul><li><strong>Parameters:</strong><ul><li><strong>u</strong> (<em>TimeFunction</em>) – first TTI field</li><li><strong>v</strong> (<em>TimeFunction</em>) – second TTI field</li><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model structure</li></ul></li></ul><h3 id="FD*utils.thomsen*mat(model)"><a class="docs-heading-anchor" href="#FD*utils.thomsen*mat(model)">FD<em>utils.thomsen</em>mat(model)</a><a id="FD*utils.thomsen*mat(model)-1"></a><a class="docs-heading-anchor-permalink" href="#FD*utils.thomsen*mat(model)" title="Permalink"></a></h3><p>Diagonal Matrices with Thomsen parameters for vectorial temporaries computation.</p><ul><li><strong>Parameters:</strong> <strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model structure</li></ul><h2 id="checkpoint-module"><a class="docs-heading-anchor" href="#checkpoint-module">checkpoint module</a><a id="checkpoint-module-1"></a><a class="docs-heading-anchor-permalink" href="#checkpoint-module" title="Permalink"></a></h2><h3 id="*class*-checkpoint.CheckpointOperator(op,-**kwargs)"><a class="docs-heading-anchor" href="#*class*-checkpoint.CheckpointOperator(op,-**kwargs)"><em>class</em> checkpoint.CheckpointOperator(op, **kwargs)</a><a id="*class*-checkpoint.CheckpointOperator(op,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-checkpoint.CheckpointOperator(op,-**kwargs)" title="Permalink"></a></h3><p>Devito’s concrete implementation of the ABC pyrevolve.Operator. This class wraps devito.Operator so it conforms to the pyRevolve API. pyRevolve will call apply with arguments t<em>start and t</em>end. Devito calls these arguments t<em>s and t</em>e so the following dict is used to perform the translations between different names.</p><ul><li><strong>Parameters:</strong><ul><li><strong>op</strong> (<em>Operator</em>) – devito.Operator object that this object will wrap.</li><li><strong>args</strong> (<em>dict</em>) – If devito.Operator.apply() expects any arguments, they can be provided here to be cached. Any calls to CheckpointOperator.apply() will automatically include these cached arguments in the call to the underlying devito.Operator.apply().</li></ul></li></ul><h4 id="apply(t*start,-t*end)"><a class="docs-heading-anchor" href="#apply(t*start,-t*end)">apply(t<em>start, t</em>end)</a><a id="apply(t*start,-t*end)-1"></a><a class="docs-heading-anchor-permalink" href="#apply(t*start,-t*end)" title="Permalink"></a></h4><p>If the devito operator requires some extra arguments in the call to apply they can be stored in the args property of this object so pyRevolve calls pyRevolve.Operator.apply() without caring about these extra arguments while this method passes them on correctly to devito.Operator</p><h4 id="t*arg*names-*-{&#39;t*end&#39;:-&#39;time*M&#39;,-&#39;t*start&#39;:-&#39;time*m&#39;}*"><a class="docs-heading-anchor" href="#t*arg*names-*-{&#39;t*end&#39;:-&#39;time*M&#39;,-&#39;t*start&#39;:-&#39;time*m&#39;}*">t<em>arg</em>names <em>= {&#39;t<em>end&#39;: &#39;time</em>M&#39;, &#39;t<em>start&#39;: &#39;time</em>m&#39;}</em></a><a id="t*arg*names-*-{&#39;t*end&#39;:-&#39;time*M&#39;,-&#39;t*start&#39;:-&#39;time*m&#39;}*-1"></a><a class="docs-heading-anchor-permalink" href="#t*arg*names-*-{&#39;t*end&#39;:-&#39;time*M&#39;,-&#39;t*start&#39;:-&#39;time*m&#39;}*" title="Permalink"></a></h4><h3 id="*class*-checkpoint.DevitoCheckpoint(objects)"><a class="docs-heading-anchor" href="#*class*-checkpoint.DevitoCheckpoint(objects)"><em>class</em> checkpoint.DevitoCheckpoint(objects)</a><a id="*class*-checkpoint.DevitoCheckpoint(objects)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-checkpoint.DevitoCheckpoint(objects)" title="Permalink"></a></h3><p>Devito’s concrete implementation of the Checkpoint abstract base class provided by pyRevolve. Holds a list of symbol objects that hold data.</p><h4 id="*property*-dtype"><a class="docs-heading-anchor" href="#*property*-dtype"><em>property</em> dtype</a><a id="*property*-dtype-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-dtype" title="Permalink"></a></h4><p>data type</p><h4 id="get_data(timestep)"><a class="docs-heading-anchor" href="#get_data(timestep)">get_data(timestep)</a><a id="get_data(timestep)-1"></a><a class="docs-heading-anchor-permalink" href="#get_data(timestep)" title="Permalink"></a></h4><p>returns the data (wavefield) for the time-step timestep</p><h4 id="get*data*location(timestep)"><a class="docs-heading-anchor" href="#get*data*location(timestep)">get<em>data</em>location(timestep)</a><a id="get*data*location(timestep)-1"></a><a class="docs-heading-anchor-permalink" href="#get*data*location(timestep)" title="Permalink"></a></h4><p>returns the data (wavefield) for the time-step timestep</p><h4 id="load()"><a class="docs-heading-anchor" href="#load()">load()</a><a id="load()-1"></a><a class="docs-heading-anchor-permalink" href="#load()" title="Permalink"></a></h4><p>NotImplementedError</p><h4 id="save()"><a class="docs-heading-anchor" href="#save()">save()</a><a id="save()-1"></a><a class="docs-heading-anchor-permalink" href="#save()" title="Permalink"></a></h4><p>NotImplementedError</p><h4 id="*property*-size"><a class="docs-heading-anchor" href="#*property*-size"><em>property</em> size</a><a id="*property*-size-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-size" title="Permalink"></a></h4><p>The memory consumption of the data contained in a checkpoint.</p><h3 id="checkpoint.get*symbol*data(symbol,-timestep)"><a class="docs-heading-anchor" href="#checkpoint.get*symbol*data(symbol,-timestep)">checkpoint.get<em>symbol</em>data(symbol, timestep)</a><a id="checkpoint.get*symbol*data(symbol,-timestep)-1"></a><a class="docs-heading-anchor-permalink" href="#checkpoint.get*symbol*data(symbol,-timestep)" title="Permalink"></a></h3><p>Return the symbol corresponding to the data at time-step timestep</p><h2 id="geom_utils-module"><a class="docs-heading-anchor" href="#geom_utils-module">geom_utils module</a><a id="geom_utils-module-1"></a><a class="docs-heading-anchor-permalink" href="#geom_utils-module" title="Permalink"></a></h2><h3 id="geom*utils.geom*expr(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-fwTrue,-ntNone)"><a class="docs-heading-anchor" href="#geom*utils.geom*expr(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-fwTrue,-ntNone)">geom<em>utils.geom</em>expr(model, u, src<em>coords=None, rec</em>coords=None, wavelet=None, fw=True, nt=None)</a><a id="geom*utils.geom*expr(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-fwTrue,-ntNone)-1"></a><a class="docs-heading-anchor-permalink" href="#geom*utils.geom*expr(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-fwTrue,-ntNone)" title="Permalink"></a></h3><p>Generates the source injection and receiver interpolation. This function is fully abstracted and does not care whether this is a forward or adjoint wave-equation. The source is the source term of the equation The receiver is the measurment term</p><p>Therefore, for the adjoint, this function has to be called as: src<em>rec(model, v, src</em>coords=rec_coords, …) because the data is the sources</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>tuple</em>) – Wavefield to inject into and read from</li><li><strong>src_coords</strong> (<em>Array</em>) – Physical coordinates of the sources</li><li><strong>rec_coords</strong> (<em>Array</em>) – Physical coordinates of the receivers</li><li><strong>wavelet</strong> (<em>Array</em>) – Data for the source</li><li><strong>fw=True</strong> – Whether the direction is forward or backward in time</li><li><strong>nt</strong> (<em>int</em>) – Number of time steps</li></ul></li></ul><h3 id="geom*utils.mirror*source(model,-src)"><a class="docs-heading-anchor" href="#geom*utils.mirror*source(model,-src)">geom<em>utils.mirror</em>source(model, src)</a><a id="geom*utils.mirror*source(model,-src)-1"></a><a class="docs-heading-anchor-permalink" href="#geom*utils.mirror*source(model,-src)" title="Permalink"></a></h3><h3 id="geom*utils.src*rec(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-ntNone)"><a class="docs-heading-anchor" href="#geom*utils.src*rec(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-ntNone)">geom<em>utils.src</em>rec(model, u, src<em>coords=None, rec</em>coords=None, wavelet=None, nt=None)</a><a id="geom*utils.src*rec(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-ntNone)-1"></a><a class="docs-heading-anchor-permalink" href="#geom*utils.src*rec(model,-u,-src*coordsNone,-rec*coordsNone,-waveletNone,-ntNone)" title="Permalink"></a></h3><h2 id="interface-module"><a class="docs-heading-anchor" href="#interface-module">interface module</a><a id="interface-module-1"></a><a class="docs-heading-anchor-permalink" href="#interface-module" title="Permalink"></a></h2><h3 id="interface.J*adjoint(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-checkpointingFalse,-n*checkpointsNone,-t*sub1,-return*objFalse,-freq*list[],-dft*subNone,-ic&#39;as&#39;,-illumFalse,-wsNone,-f00.015,-born*fwdFalse,-nlindFalse,-misfitNone,-fwTrue)"><a class="docs-heading-anchor" href="#interface.J*adjoint(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-checkpointingFalse,-n*checkpointsNone,-t*sub1,-return*objFalse,-freq*list[],-dft*subNone,-ic&#39;as&#39;,-illumFalse,-wsNone,-f00.015,-born*fwdFalse,-nlindFalse,-misfitNone,-fwTrue)">interface.J<em>adjoint(model, src</em>coords, wavelet, rec<em>coords, recin, is</em>residual=False, checkpointing=False, n<em>checkpoints=None, t</em>sub=1, return<em>obj=False, freq</em>list=[], dft<em>sub=None, ic=&#39;as&#39;, illum=False, ws=None, f0=0.015, born</em>fwd=False, nlind=False, misfit=None, fw=True)</a><a id="interface.J*adjoint(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-checkpointingFalse,-n*checkpointsNone,-t*sub1,-return*objFalse,-freq*list[],-dft*subNone,-ic&#39;as&#39;,-illumFalse,-wsNone,-f00.015,-born*fwdFalse,-nlindFalse,-misfitNone,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.J*adjoint(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-checkpointingFalse,-n*checkpointsNone,-t*sub1,-return*objFalse,-freq*list[],-dft*subNone,-ic&#39;as&#39;,-illumFalse,-wsNone,-f00.015,-born*fwdFalse,-nlindFalse,-misfitNone,-fwTrue)" title="Permalink"></a></h3><p>Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Supports three modes: * Checkpinting * Frequency compression (on-the-fly DFT) * Standard zero lag cross correlation over time</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>src_coords</strong> (<em>Array</em>) – Coordiantes of the source(s)</li><li><strong>wavelet</strong> (<em>Array</em>) – Source signature</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>recin</strong> (<em>Array</em>) – Receiver data</li><li><strong>checkpointing</strong> (<em>Bool</em>) – Whether or not to use checkpointing</li><li><strong>n_checkpoints</strong> (<em>Int</em>) – Number of checkpoints for checkpointing</li><li><strong>maxmem</strong> (<em>Float</em>) – Maximum memory to use for checkpointing</li><li><strong>freq_list</strong> (<em>List</em>) – List of frequencies for on-the-fly DFT</li><li><strong>dft_sub</strong> (<em>Int</em>) – Subsampling factor for on-the-fly DFT</li><li><strong>ic</strong> (<em>String</em>) – Imaging conditions (“as”, “isic” or “fwi”), defaults to “as”</li><li><strong>ws</strong> (<em>Array</em>) – Extended source spatial distribution</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation as base propagator</li></ul></li><li><strong>Returns:</strong> Adjoint jacobian on the input data (gradient)</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.J*adjoint*checkpointing(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-n*checkpointsNone,-born*fwdFalse,-return*objFalse,-ic&#39;as&#39;,-wsNone,-nlindFalse,-f00.015,-misfitNone,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.J*adjoint*checkpointing(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-n*checkpointsNone,-born*fwdFalse,-return*objFalse,-ic&#39;as&#39;,-wsNone,-nlindFalse,-f00.015,-misfitNone,-illumFalse,-fwTrue)">interface.J<em>adjoint</em>checkpointing(model, src<em>coords, wavelet, rec</em>coords, recin, is<em>residual=False, n</em>checkpoints=None, born<em>fwd=False, return</em>obj=False, ic=&#39;as&#39;, ws=None, nlind=False, f0=0.015, misfit=None, illum=False, fw=True)</a><a id="interface.J*adjoint*checkpointing(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-n*checkpointsNone,-born*fwdFalse,-return*objFalse,-ic&#39;as&#39;,-wsNone,-nlindFalse,-f00.015,-misfitNone,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.J*adjoint*checkpointing(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-n*checkpointsNone,-born*fwdFalse,-return*objFalse,-ic&#39;as&#39;,-wsNone,-nlindFalse,-f00.015,-misfitNone,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with Checkpointing.</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>src_coords</strong> (<em>Array</em>) – Coordiantes of the source(s)</li><li><strong>wavelet</strong> (<em>Array</em>) – Source signature</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>recin</strong> (<em>Array</em>) – Receiver data</li><li><strong>checkpointing</strong> (<em>Bool</em>) – Whether or not to use checkpointing</li><li><strong>n_checkpoints</strong> (<em>Int</em>) – Number of checkpoints for checkpointing</li><li><strong>maxmem</strong> (<em>Float</em>) – Maximum memory to use for checkpointing</li><li><strong>ic</strong> (<em>String</em>) – Imaging conditions (“as”, “isic” or “fwi”), defaults to “as”</li><li><strong>ws</strong> (<em>Array</em>) – Extended source spatial distribution</li><li><strong>is_residual</strong> (<em>Bool</em>) – Whether to treat the input as the residual or as the observed data</li><li><strong>born_fwd</strong> (<em>Bool</em>) – Whether to use the forward or linearized forward modeling operator</li><li><strong>nlind</strong> (<em>Bool</em>) – Whether to remove the non linear data from the input data. This option is only available in combination with born_fwd</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation as base propagator</li></ul></li><li><strong>Returns:</strong> Adjoint jacobian on the input data (gradient)</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.J*adjoint*freq(model,-src*coords,-wavelet,-rec*coords,-recin,-freq*list[],-is*residualFalse,-return*objFalse,-nlindFalse,-dft*subNone,-ic&#39;as&#39;,-wsNone,-born_fwdFalse,-f00.015,-misfitNone,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.J*adjoint*freq(model,-src*coords,-wavelet,-rec*coords,-recin,-freq*list[],-is*residualFalse,-return*objFalse,-nlindFalse,-dft*subNone,-ic&#39;as&#39;,-wsNone,-born_fwdFalse,-f00.015,-misfitNone,-illumFalse,-fwTrue)">interface.J<em>adjoint</em>freq(model, src<em>coords, wavelet, rec</em>coords, recin, freq<em>list=[], is</em>residual=False, return<em>obj=False, nlind=False, dft</em>sub=None, ic=&#39;as&#39;, ws=None, born_fwd=False, f0=0.015, misfit=None, illum=False, fw=True)</a><a id="interface.J*adjoint*freq(model,-src*coords,-wavelet,-rec*coords,-recin,-freq*list[],-is*residualFalse,-return*objFalse,-nlindFalse,-dft*subNone,-ic&#39;as&#39;,-wsNone,-born_fwdFalse,-f00.015,-misfitNone,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.J*adjoint*freq(model,-src*coords,-wavelet,-rec*coords,-recin,-freq*list[],-is*residualFalse,-return*objFalse,-nlindFalse,-dft*subNone,-ic&#39;as&#39;,-wsNone,-born_fwdFalse,-f00.015,-misfitNone,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with Frequency compression (on-the-fly DFT).</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>src_coords</strong> (<em>Array</em>) – Coordiantes of the source(s)</li><li><strong>wavelet</strong> (<em>Array</em>) – Source signature</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>recin</strong> (<em>Array</em>) – Receiver data</li><li><strong>freq_list</strong> (<em>List</em>) – List of frequencies for on-the-fly DFT</li><li><strong>dft_sub</strong> (<em>Int</em>) – Subsampling factor for on-the-fly DFT</li><li><strong>ic</strong> (<em>String</em>) – Imaging conditions (“as”, “isic” or “fwi”), defaults to “as”</li><li><strong>ws</strong> (<em>Array</em>) – Extended source spatial distribution</li><li><strong>is_residual</strong> (<em>Bool</em>) – Whether to treat the input as the residual or as the observed data</li><li><strong>born_fwd</strong> (<em>Bool</em>) – Whether to use the forward or linearized forward modeling operator</li><li><strong>nlind</strong> (<em>Bool</em>) – Whether to remove the non linear data from the input data. This option is only available in combination with born_fwd</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation as base propagator</li></ul></li><li><strong>Returns:</strong> Adjoint jacobian on the input data (gradient)</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.J*adjoint*standard(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-return*objFalse,-born*fwdFalse,-illumFalse,-ic&#39;as&#39;,-wsNone,-t*sub1,-nlindFalse,-f00.015,-misfitNone,-fwTrue)"><a class="docs-heading-anchor" href="#interface.J*adjoint*standard(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-return*objFalse,-born*fwdFalse,-illumFalse,-ic&#39;as&#39;,-wsNone,-t*sub1,-nlindFalse,-f00.015,-misfitNone,-fwTrue)">interface.J<em>adjoint</em>standard(model, src<em>coords, wavelet, rec</em>coords, recin, is<em>residual=False, return</em>obj=False, born<em>fwd=False, illum=False, ic=&#39;as&#39;, ws=None, t</em>sub=1, nlind=False, f0=0.015, misfit=None, fw=True)</a><a id="interface.J*adjoint*standard(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-return*objFalse,-born*fwdFalse,-illumFalse,-ic&#39;as&#39;,-wsNone,-t*sub1,-nlindFalse,-f00.015,-misfitNone,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.J*adjoint*standard(model,-src*coords,-wavelet,-rec*coords,-recin,-is*residualFalse,-return*objFalse,-born*fwdFalse,-illumFalse,-ic&#39;as&#39;,-wsNone,-t*sub1,-nlindFalse,-f00.015,-misfitNone,-fwTrue)" title="Permalink"></a></h3><p>Adjoint Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with standard zero lag cross correlation over time.</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>src_coords</strong> (<em>Array</em>) – Coordiantes of the source(s)</li><li><strong>wavelet</strong> (<em>Array</em>) – Source signature</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>recin</strong> (<em>Array</em>) – Receiver data</li><li><strong>ic</strong> (<em>String</em>) – Imaging conditions (“as”, “isic” or “fwi”), defaults to “as”</li><li><strong>ws</strong> (<em>Array</em>) – Extended source spatial distribution</li><li><strong>is_residual</strong> (<em>Bool</em>) – Whether to treat the input as the residual or as the observed data</li><li><strong>born_fwd</strong> (<em>Bool</em>) – Whether to use the forward or linearized forward modeling operator</li><li><strong>nlind</strong> (<em>Bool</em>) – Whether to remove the non linear data from the input data. This option is only available in combination with born_fwd</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation as base propagator</li></ul></li><li><strong>Returns:</strong> Adjoint jacobian on the input data (gradient)</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.adjoint*w(model,-rec*coords,-data,-wavelet,-f00.015,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.adjoint*w(model,-rec*coords,-data,-wavelet,-f00.015,-illumFalse,-fwTrue)">interface.adjoint<em>w(model, rec</em>coords, data, wavelet, f0=0.015, illum=False, fw=True)</a><a id="interface.adjoint*w(model,-rec*coords,-data,-wavelet,-f00.015,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.adjoint*w(model,-rec*coords,-data,-wavelet,-f00.015,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Adjoint/backward modeling of a shot record (receivers as source) for an extended source setup Pw*F^T*Pr^T*d_obs.</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>data</strong> (<em>Array</em>) – Shot gather</li><li><strong>wavelet</strong> (<em>Array</em>) – Time signature of the forward source for stacking along time</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation</li></ul></li><li><strong>Returns:</strong> spatial distribution</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.born*rec(model,-src*coords,-wavelet,-rec_coords,-ic&#39;as&#39;,-f00.015,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.born*rec(model,-src*coords,-wavelet,-rec_coords,-ic&#39;as&#39;,-f00.015,-illumFalse,-fwTrue)">interface.born<em>rec(model, src</em>coords, wavelet, rec_coords, ic=&#39;as&#39;, f0=0.015, illum=False, fw=True)</a><a id="interface.born*rec(model,-src*coords,-wavelet,-rec_coords,-ic&#39;as&#39;,-f00.015,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.born*rec(model,-src*coords,-wavelet,-rec_coords,-ic&#39;as&#39;,-f00.015,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Linearized (Born) modeling of a point source for a model perturbation (square slowness) dm.</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>src_coords</strong> (<em>Array</em>) – Coordiantes of the source(s)</li><li><strong>wavelet</strong> (<em>Array</em>) – Source signature</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>ic</strong> (<em>String</em>) – Imaging conditions (“as”, “isic” or “fwi”), defaults to “as”</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation</li></ul></li><li><strong>Returns:</strong> Shot record</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.born*rec*w(model,-weight,-wavelet,-rec_coords,-ic&#39;as&#39;,-f00.015,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.born*rec*w(model,-weight,-wavelet,-rec_coords,-ic&#39;as&#39;,-f00.015,-illumFalse,-fwTrue)">interface.born<em>rec</em>w(model, weight, wavelet, rec_coords, ic=&#39;as&#39;, f0=0.015, illum=False, fw=True)</a><a id="interface.born*rec*w(model,-weight,-wavelet,-rec_coords,-ic&#39;as&#39;,-f00.015,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.born*rec*w(model,-weight,-wavelet,-rec_coords,-ic&#39;as&#39;,-f00.015,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Linearized (Born) modeling of an extended source for a model perturbation (square slowness) dm with an extended source</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>weight</strong> (<em>Array</em>) – Spatial distriubtion of the extended source</li><li><strong>wavelet</strong> (<em>Array</em>) – Source signature</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>ic</strong> (<em>String</em>) – Imaging conditions (“as”, “isic” or “fwi”), defaults to “as”</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation</li></ul></li><li><strong>Returns:</strong> Shot record</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.forward*no*rec(model,-src_coords,-wavelet,-f00.015,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.forward*no*rec(model,-src_coords,-wavelet,-f00.015,-illumFalse,-fwTrue)">interface.forward<em>no</em>rec(model, src_coords, wavelet, f0=0.015, illum=False, fw=True)</a><a id="interface.forward*no*rec(model,-src_coords,-wavelet,-f00.015,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*no*rec(model,-src_coords,-wavelet,-f00.015,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Forward modeling of a point source without receiver.</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>src_coords</strong> (<em>Array</em>) – Coordiantes of the source(s)</li><li><strong>wavelet</strong> (<em>Array</em>) – Source signature</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation</li></ul></li><li><strong>Returns:</strong> Wavefield</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.forward*rec(model,-src*coords,-wavelet,-rec_coords,-f00.015,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.forward*rec(model,-src*coords,-wavelet,-rec_coords,-f00.015,-illumFalse,-fwTrue)">interface.forward<em>rec(model, src</em>coords, wavelet, rec_coords, f0=0.015, illum=False, fw=True)</a><a id="interface.forward*rec(model,-src*coords,-wavelet,-rec_coords,-f00.015,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*rec(model,-src*coords,-wavelet,-rec_coords,-f00.015,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Modeling of a point source with receivers Pr*F*Ps^T*q.</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>src_coords</strong> (<em>Array</em>) – Coordiantes of the source(s)</li><li><strong>wavelet</strong> (<em>Array</em>) – Source signature</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation</li></ul></li><li><strong>Returns:</strong> Shot record</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.forward*rec*w(model,-weight,-wavelet,-rec_coords,-f00.015,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.forward*rec*w(model,-weight,-wavelet,-rec_coords,-f00.015,-illumFalse,-fwTrue)">interface.forward<em>rec</em>w(model, weight, wavelet, rec_coords, f0=0.015, illum=False, fw=True)</a><a id="interface.forward*rec*w(model,-weight,-wavelet,-rec_coords,-f00.015,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*rec*w(model,-weight,-wavelet,-rec_coords,-f00.015,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Forward modeling of an extended source with receivers  Pr*F*Pw^T*w</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>weights</strong> (<em>Array</em>) – Spatial distribution of the extended source.</li><li><strong>wavelet</strong> (<em>Array</em>) – Source signature</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation</li></ul></li><li><strong>Returns:</strong> Shot record</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.forward*wf*src(model,-u,-rec_coords,-f00.015,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.forward*wf*src(model,-u,-rec_coords,-f00.015,-illumFalse,-fwTrue)">interface.forward<em>wf</em>src(model, u, rec_coords, f0=0.015, illum=False, fw=True)</a><a id="interface.forward*wf*src(model,-u,-rec_coords,-f00.015,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*wf*src(model,-u,-rec_coords,-f00.015,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Forward modeling of a full wavefield source Pr*F*u.</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Array</em>) – Time-space dependent wavefield</li><li><strong>rec_coords</strong> (<em>Array</em>) – Coordiantes of the receiver(s)</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation</li></ul></li><li><strong>Returns:</strong> Shot record</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.forward*wf*src_norec(model,-u,-f00.015,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#interface.forward*wf*src_norec(model,-u,-f00.015,-illumFalse,-fwTrue)">interface.forward<em>wf</em>src_norec(model, u, f0=0.015, illum=False, fw=True)</a><a id="interface.forward*wf*src_norec(model,-u,-f00.015,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.forward*wf*src_norec(model,-u,-f00.015,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Forward modeling of a full wavefield source without receiver F*u.</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Array</em>) – Time-space dependent wavefield</li><li><strong>f0</strong> (<em>float</em>) – peak frequency</li><li><strong>illum</strong> (<em>bool</em>) – Whether to compute illumination during propagation</li><li><strong>fw</strong> (<em>bool</em>) – Whether it is forward or adjoint propagation</li></ul></li><li><strong>Returns:</strong> Wavefield</li><li><strong>Return type:</strong> Array</li></ul><h3 id="interface.wri*func(model,-src*coords,-wavelet,-rec*coords,-recin,-yin,-ic&#39;as&#39;,-wsNone,-t*sub1,-grad&#39;m&#39;,-grad*corrFalse,-alpha*opFalse,-w*funNone,-eps0,-freq*list[],-wfiltNone,-f00.015)"><a class="docs-heading-anchor" href="#interface.wri*func(model,-src*coords,-wavelet,-rec*coords,-recin,-yin,-ic&#39;as&#39;,-wsNone,-t*sub1,-grad&#39;m&#39;,-grad*corrFalse,-alpha*opFalse,-w*funNone,-eps0,-freq*list[],-wfiltNone,-f00.015)">interface.wri<em>func(model, src</em>coords, wavelet, rec<em>coords, recin, yin, ic=&#39;as&#39;, ws=None, t</em>sub=1, grad=&#39;m&#39;, grad<em>corr=False, alpha</em>op=False, w<em>fun=None, eps=0, freq</em>list=[], wfilt=None, f0=0.015)</a><a id="interface.wri*func(model,-src*coords,-wavelet,-rec*coords,-recin,-yin,-ic&#39;as&#39;,-wsNone,-t*sub1,-grad&#39;m&#39;,-grad*corrFalse,-alpha*opFalse,-w*funNone,-eps0,-freq*list[],-wfiltNone,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#interface.wri*func(model,-src*coords,-wavelet,-rec*coords,-recin,-yin,-ic&#39;as&#39;,-wsNone,-t*sub1,-grad&#39;m&#39;,-grad*corrFalse,-alpha*opFalse,-w*funNone,-eps0,-freq*list[],-wfiltNone,-f00.015)" title="Permalink"></a></h3><p>Time domain wavefield reconstruction inversion wrapper</p><h2 id="kernels-module"><a class="docs-heading-anchor" href="#kernels-module">kernels module</a><a id="kernels-module-1"></a><a class="docs-heading-anchor-permalink" href="#kernels-module" title="Permalink"></a></h2><h3 id="kernels.SLS*2nd*order(model,-p,-fwTrue,-qNone,-f00.015)"><a class="docs-heading-anchor" href="#kernels.SLS*2nd*order(model,-p,-fwTrue,-qNone,-f00.015)">kernels.SLS<em>2nd</em>order(model, p, fw=True, q=None, f0=0.015)</a><a id="kernels.SLS*2nd*order(model,-p,-fwTrue,-qNone,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.SLS*2nd*order(model,-p,-fwTrue,-qNone,-f00.015)" title="Permalink"></a></h3><p>Viscoacoustic 2nd SLS wave equation. <a href="https://library.seg.org/doi/10.1190/geo2013-0030.1">https://library.seg.org/doi/10.1190/geo2013-0030.1</a></p><p>Bulk modulus moved to rhs. The adjoint equation is directly derived as the discrete adjoint of the forward PDE which leads to a slightly different formulation than in the paper.</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>u1</strong> (<em>TimeFunction</em>) – Pressure field</li><li><strong>u2</strong> (<em>TimeFunction</em>) – Attenuation Memory variable</li><li><strong>fw</strong> (<em>Bool</em>) – Whether forward or backward in time propagation</li><li><strong>q</strong> (<em>TimeFunction</em> <em>or</em> <em>Expr</em>) – Full time-space source as a tuple (one value for each component)</li><li><strong>f0</strong> (<em>Peak frequency</em>)</li></ul></li></ul><h3 id="kernels.acoustic_kernel(model,-u,-fwTrue,-qNone)"><a class="docs-heading-anchor" href="#kernels.acoustic_kernel(model,-u,-fwTrue,-qNone)">kernels.acoustic_kernel(model, u, fw=True, q=None)</a><a id="kernels.acoustic_kernel(model,-u,-fwTrue,-qNone)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.acoustic_kernel(model,-u,-fwTrue,-qNone)" title="Permalink"></a></h3><p>Acoustic wave equation time stepper</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>tuple</em>) – wavefield (tuple if TTI)</li><li><strong>fw</strong> (<em>Bool</em>) – Whether forward or backward in time propagation</li><li><strong>q</strong> (<em>TimeFunction</em> <em>or</em> <em>Expr</em>) – Full time-space source</li></ul></li></ul><h3 id="kernels.elastic_kernel(model,-v,-tau,-fwTrue,-qNone)"><a class="docs-heading-anchor" href="#kernels.elastic_kernel(model,-v,-tau,-fwTrue,-qNone)">kernels.elastic_kernel(model, v, tau, fw=True, q=None)</a><a id="kernels.elastic_kernel(model,-v,-tau,-fwTrue,-qNone)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.elastic_kernel(model,-v,-tau,-fwTrue,-qNone)" title="Permalink"></a></h3><p>Elastic wave equation time stepper</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>v</strong> (<em>VectorTimeFunction</em>) – Particle Velocity</li><li><strong>tau</strong> (<em>TensorTimeFunction</em>) – Stress tensor</li><li><strong>fw</strong> (<em>Bool</em>) – Whether forward or backward in time propagation</li><li><strong>q</strong> (<em>TimeFunction</em> <em>or</em> <em>Expr</em>) – Full time-space source as a tuple (one value for each component)</li></ul></li></ul><h3 id="kernels.tti_kernel(model,-u1,-u2,-fwTrue,-qNone)"><a class="docs-heading-anchor" href="#kernels.tti_kernel(model,-u1,-u2,-fwTrue,-qNone)">kernels.tti_kernel(model, u1, u2, fw=True, q=None)</a><a id="kernels.tti_kernel(model,-u1,-u2,-fwTrue,-qNone)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.tti_kernel(model,-u1,-u2,-fwTrue,-qNone)" title="Permalink"></a></h3><p>TTI wave equation time stepper</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>u1</strong> (<em>TimeFunction</em>) – First component (pseudo-P) of the wavefield</li><li><strong>u2</strong> (<em>TimeFunction</em>) – Second component (pseudo-S) of the wavefield</li><li><strong>fw</strong> (<em>Bool</em>) – Whether forward or backward in time propagation</li><li><strong>q</strong> (<em>TimeFunction</em> <em>or</em> <em>Expr</em>) – Full time-space source as a tuple (one value for each component)</li></ul></li></ul><h3 id="kernels.vs*mask*derivs(eq,-tau,-vs)"><a class="docs-heading-anchor" href="#kernels.vs*mask*derivs(eq,-tau,-vs)">kernels.vs<em>mask</em>derivs(eq, tau, vs)</a><a id="kernels.vs*mask*derivs(eq,-tau,-vs)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.vs*mask*derivs(eq,-tau,-vs)" title="Permalink"></a></h3><h3 id="kernels.wave_kernel(model,-u,-fwTrue,-qNone,-f00.015)"><a class="docs-heading-anchor" href="#kernels.wave_kernel(model,-u,-fwTrue,-qNone,-f00.015)">kernels.wave_kernel(model, u, fw=True, q=None, f0=0.015)</a><a id="kernels.wave_kernel(model,-u,-fwTrue,-qNone,-f00.015)-1"></a><a class="docs-heading-anchor-permalink" href="#kernels.wave_kernel(model,-u,-fwTrue,-qNone,-f00.015)" title="Permalink"></a></h3><p>Pde kernel corresponding the the model for the input wavefield</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Physical model</li><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>tuple</em>) – wavefield (tuple if TTI or Viscoacoustic)</li><li><strong>fw</strong> (<em>Bool</em>) – Whether forward or backward in time propagation</li><li><strong>q</strong> (<em>TimeFunction</em> <em>or</em> <em>Expr</em>) – Full time-space source</li><li><strong>f0</strong> (<em>Peak frequency</em>)</li></ul></li></ul><h2 id="models-module"><a class="docs-heading-anchor" href="#models-module">models module</a><a id="models-module-1"></a><a class="docs-heading-anchor-permalink" href="#models-module" title="Permalink"></a></h2><h3 id="*class*-models.Model(origin,-spacing,-shape,-space_order8,-nbl40,-dtypeclass-&#39;numpy.float32&#39;,-mNone,-epsilonNone,-deltaNone,-thetaNone,-phiNone,-rhoNone,-bNone,-qpNone,-lamNone,-muNone,-dmNone,-fsFalse,-**kwargs)"><a class="docs-heading-anchor" href="#*class*-models.Model(origin,-spacing,-shape,-space_order8,-nbl40,-dtypeclass-&#39;numpy.float32&#39;,-mNone,-epsilonNone,-deltaNone,-thetaNone,-phiNone,-rhoNone,-bNone,-qpNone,-lamNone,-muNone,-dmNone,-fsFalse,-**kwargs)"><em>class</em> models.Model(origin, spacing, shape, space_order=8, nbl=40, dtype=&lt;class &#39;numpy.float32&#39;&gt;, m=None, epsilon=None, delta=None, theta=None, phi=None, rho=None, b=None, qp=None, lam=None, mu=None, dm=None, fs=False, **kwargs)</a><a id="*class*-models.Model(origin,-spacing,-shape,-space_order8,-nbl40,-dtypeclass-&#39;numpy.float32&#39;,-mNone,-epsilonNone,-deltaNone,-thetaNone,-phiNone,-rhoNone,-bNone,-qpNone,-lamNone,-muNone,-dmNone,-fsFalse,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-models.Model(origin,-spacing,-shape,-space_order8,-nbl40,-dtypeclass-&#39;numpy.float32&#39;,-mNone,-epsilonNone,-deltaNone,-thetaNone,-phiNone,-rhoNone,-bNone,-qpNone,-lamNone,-muNone,-dmNone,-fsFalse,-**kwargs)" title="Permalink"></a></h3><p>The physical model used in seismic inversion : shape_pml = np.array(shape) + 2 * self.nbl processes.</p><ul><li><strong>Parameters:</strong><ul><li><strong>origin</strong> (<em>tuple</em> <em>of</em> <em>floats</em>) – Origin of the model in m as a tuple in (x,y,z) order.</li><li><strong>spacing</strong> (<em>tuple</em> <em>of</em> <em>floats</em>) – Grid size in m as a Tuple in (x,y,z) order.</li><li><strong>shape</strong> (<em>tuple</em> <em>of</em> <em>int</em>) – Number of grid points size in (x,y,z) order.</li><li><strong>space_order</strong> (<em>int</em>) – Order of the spatial stencil discretisation.</li><li><strong>m</strong> (<em>array_like</em> <em>or</em> <em>float</em>) – Squared slownes in s^2/km^2</li><li><strong>nbl</strong> (<em>int</em> <em>,</em> <em>optional</em>) – The number of absorbin layers for boundary damping.</li><li><strong>dtype</strong> (<em>np.float32</em> <em>or</em> <em>np.float64</em>) – Defaults to 32.</li><li><strong>epsilon</strong> (<em>array_like</em> <em>or</em> <em>float</em> <em>,</em> <em>optional</em>) – Thomsen epsilon parameter (0&lt;epsilon&lt;1).</li><li><strong>delta</strong> (<em>array_like</em> <em>or</em> <em>float</em>) – Thomsen delta parameter (0&lt;delta&lt;1), delta&lt;epsilon.</li><li><strong>theta</strong> (<em>array_like</em> <em>or</em> <em>float</em>) – Tilt angle in radian.</li><li><strong>phi</strong> (<em>array_like</em> <em>or</em> <em>float</em>) – Asymuth angle in radian.</li><li><strong>dt</strong> (<em>Float</em>) – User provided computational time-step</li><li><strong>abox</strong> (<em>Float</em>) – Whether to use the exapanding box, defaults to true</li></ul></li></ul><h4 id="abox(src,-rec,-fwTrue)"><a class="docs-heading-anchor" href="#abox(src,-rec,-fwTrue)">abox(src, rec, fw=True)</a><a id="abox(src,-rec,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#abox(src,-rec,-fwTrue)" title="Permalink"></a></h4><h4 id="*property*-critical_dt"><a class="docs-heading-anchor" href="#*property*-critical_dt"><em>property</em> critical_dt</a><a id="*property*-critical_dt-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-critical_dt" title="Permalink"></a></h4><p>Critical computational time step value from the CFL condition.</p><h4 id="*property*-dim"><a class="docs-heading-anchor" href="#*property*-dim"><em>property</em> dim</a><a id="*property*-dim-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-dim" title="Permalink"></a></h4><p>Spatial dimension of the problem and model domain.</p><h4 id="*property*-domain_size"><a class="docs-heading-anchor" href="#*property*-domain_size"><em>property</em> domain_size</a><a id="*property*-domain_size-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-domain_size" title="Permalink"></a></h4><p>Physical size of the domain as determined by shape and spacing</p><h4 id="*property*-dt"><a class="docs-heading-anchor" href="#*property*-dt"><em>property</em> dt</a><a id="*property*-dt-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-dt" title="Permalink"></a></h4><p>User provided dt</p><h4 id="*property*-dtype-2"><a class="docs-heading-anchor" href="#*property*-dtype-2"><em>property</em> dtype</a><a class="docs-heading-anchor-permalink" href="#*property*-dtype-2" title="Permalink"></a></h4><p>Data type for all assocaited data objects.</p><h4 id="*property*-fs_dim"><a class="docs-heading-anchor" href="#*property*-fs_dim"><em>property</em> fs_dim</a><a id="*property*-fs_dim-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-fs_dim" title="Permalink"></a></h4><h4 id="*property*-is_elastic"><a class="docs-heading-anchor" href="#*property*-is_elastic"><em>property</em> is_elastic</a><a id="*property*-is_elastic-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-is_elastic" title="Permalink"></a></h4><p>Whether the model is TTI or isotopic</p><h4 id="*property*-is_tti"><a class="docs-heading-anchor" href="#*property*-is_tti"><em>property</em> is_tti</a><a id="*property*-is_tti-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-is_tti" title="Permalink"></a></h4><p>Whether the model is TTI or isotopic</p><h4 id="*property*-is_viscoacoustic"><a class="docs-heading-anchor" href="#*property*-is_viscoacoustic"><em>property</em> is_viscoacoustic</a><a id="*property*-is_viscoacoustic-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-is_viscoacoustic" title="Permalink"></a></h4><p>Whether the model is TTI or isotopic</p><h4 id="*property*-padsizes"><a class="docs-heading-anchor" href="#*property*-padsizes"><em>property</em> padsizes</a><a id="*property*-padsizes-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-padsizes" title="Permalink"></a></h4><h4 id="*property*-physical"><a class="docs-heading-anchor" href="#*property*-physical"><em>property</em> physical</a><a id="*property*-physical-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-physical" title="Permalink"></a></h4><h4 id="*property*-physical_parameters"><a class="docs-heading-anchor" href="#*property*-physical_parameters"><em>property</em> physical_parameters</a><a id="*property*-physical_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-physical_parameters" title="Permalink"></a></h4><p>List of physical parameteres</p><h4 id="physical_params(**kwargs)"><a class="docs-heading-anchor" href="#physical_params(**kwargs)">physical_params(**kwargs)</a><a id="physical_params(**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#physical_params(**kwargs)" title="Permalink"></a></h4><p>Return all set physical parameters and update to input values if provided</p><h4 id="*property*-space_dimensions"><a class="docs-heading-anchor" href="#*property*-space_dimensions"><em>property</em> space_dimensions</a><a id="*property*-space_dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-space_dimensions" title="Permalink"></a></h4><p>Spatial dimensions of the grid</p><h4 id="*property*-space_order"><a class="docs-heading-anchor" href="#*property*-space_order"><em>property</em> space_order</a><a id="*property*-space_order-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-space_order" title="Permalink"></a></h4><p>Spatial discretization order</p><h4 id="*property*-spacing"><a class="docs-heading-anchor" href="#*property*-spacing"><em>property</em> spacing</a><a id="*property*-spacing-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-spacing" title="Permalink"></a></h4><p>Grid spacing for all fields in the physical model.</p><h4 id="*property*-spacing_map"><a class="docs-heading-anchor" href="#*property*-spacing_map"><em>property</em> spacing_map</a><a id="*property*-spacing_map-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-spacing_map" title="Permalink"></a></h4><p>Map between spacing symbols and their values for each SpaceDimension.</p><h4 id="*property*-vp"><a class="docs-heading-anchor" href="#*property*-vp"><em>property</em> vp</a><a id="*property*-vp-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-vp" title="Permalink"></a></h4><p>Symbolic representation of the velocity vp = sqrt(1 / m)</p><h4 id="*property*-zero_thomsen"><a class="docs-heading-anchor" href="#*property*-zero_thomsen"><em>property</em> zero_thomsen</a><a id="*property*-zero_thomsen-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-zero_thomsen" title="Permalink"></a></h4><h2 id="propagators-module"><a class="docs-heading-anchor" href="#propagators-module">propagators module</a><a id="propagators-module-1"></a><a class="docs-heading-anchor-permalink" href="#propagators-module" title="Permalink"></a></h2><h3 id="propagators.adjoint(*args,-**kwargs)"><a class="docs-heading-anchor" href="#propagators.adjoint(*args,-**kwargs)">propagators.adjoint(*args, **kwargs)</a><a id="propagators.adjoint(*args,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.adjoint(*args,-**kwargs)" title="Permalink"></a></h3><h3 id="propagators.born(model,-src*coords,-rcv*coords,-wavelet,-saveFalse,-qwfNone,-return*opFalse,-ic&#39;as&#39;,-freq*listNone,-dft*subNone,-wsNone,-t*sub1,-nlindFalse,-f00.015,-illumFalse,-fwTrue)"><a class="docs-heading-anchor" href="#propagators.born(model,-src*coords,-rcv*coords,-wavelet,-saveFalse,-qwfNone,-return*opFalse,-ic&#39;as&#39;,-freq*listNone,-dft*subNone,-wsNone,-t*sub1,-nlindFalse,-f00.015,-illumFalse,-fwTrue)">propagators.born(model, src<em>coords, rcv</em>coords, wavelet, save=False, qwf=None, return<em>op=False, ic=&#39;as&#39;, freq</em>list=None, dft<em>sub=None, ws=None, t</em>sub=1, nlind=False, f0=0.015, illum=False, fw=True)</a><a id="propagators.born(model,-src*coords,-rcv*coords,-wavelet,-saveFalse,-qwfNone,-return*opFalse,-ic&#39;as&#39;,-freq*listNone,-dft*subNone,-wsNone,-t*sub1,-nlindFalse,-f00.015,-illumFalse,-fwTrue)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.born(model,-src*coords,-rcv*coords,-wavelet,-saveFalse,-qwfNone,-return*opFalse,-ic&#39;as&#39;,-freq*listNone,-dft*subNone,-wsNone,-t*sub1,-nlindFalse,-f00.015,-illumFalse,-fwTrue)" title="Permalink"></a></h3><p>Low level propagator, to be used through interface.py Compute linearized wavefield U = J(m)* δ m and related quantities.</p><h3 id="propagators.forward(model,-src*coords,-rcv*coords,-wavelet,-saveFalse,-qwfNone,-return*opFalse,-freq*listNone,-dft*subNone,-norm*wfFalse,-w*funNone,-wsNone,-wrNone,-t*sub1,-f00.015,-illumFalse,-fwTrue,-**kwargs)"><a class="docs-heading-anchor" href="#propagators.forward(model,-src*coords,-rcv*coords,-wavelet,-saveFalse,-qwfNone,-return*opFalse,-freq*listNone,-dft*subNone,-norm*wfFalse,-w*funNone,-wsNone,-wrNone,-t*sub1,-f00.015,-illumFalse,-fwTrue,-**kwargs)">propagators.forward(model, src<em>coords, rcv</em>coords, wavelet, save=False, qwf=None, return<em>op=False, freq</em>list=None, dft<em>sub=None, norm</em>wf=False, w<em>fun=None, ws=None, wr=None, t</em>sub=1, f0=0.015, illum=False, fw=True, **kwargs)</a><a id="propagators.forward(model,-src*coords,-rcv*coords,-wavelet,-saveFalse,-qwfNone,-return*opFalse,-freq*listNone,-dft*subNone,-norm*wfFalse,-w*funNone,-wsNone,-wrNone,-t*sub1,-f00.015,-illumFalse,-fwTrue,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.forward(model,-src*coords,-rcv*coords,-wavelet,-saveFalse,-qwfNone,-return*opFalse,-freq*listNone,-dft*subNone,-norm*wfFalse,-w*funNone,-wsNone,-wrNone,-t*sub1,-f00.015,-illumFalse,-fwTrue,-**kwargs)" title="Permalink"></a></h3><p>Low level propagator, to be used through interface.py Compute forward wavefield u = A(m)^{-1}*f and related quantities (u(xrcv))</p><h3 id="propagators.forward*grad(model,-src*coords,-rcv_coords,-wavelet,-v,-qNone,-wsNone,-ic&#39;as&#39;,-wNone,-freqNone,-f00.015,-**kwargs)"><a class="docs-heading-anchor" href="#propagators.forward*grad(model,-src*coords,-rcv_coords,-wavelet,-v,-qNone,-wsNone,-ic&#39;as&#39;,-wNone,-freqNone,-f00.015,-**kwargs)">propagators.forward<em>grad(model, src</em>coords, rcv_coords, wavelet, v, q=None, ws=None, ic=&#39;as&#39;, w=None, freq=None, f0=0.015, **kwargs)</a><a id="propagators.forward*grad(model,-src*coords,-rcv_coords,-wavelet,-v,-qNone,-wsNone,-ic&#39;as&#39;,-wNone,-freqNone,-f00.015,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.forward*grad(model,-src*coords,-rcv_coords,-wavelet,-v,-qNone,-wsNone,-ic&#39;as&#39;,-wNone,-freqNone,-f00.015,-**kwargs)" title="Permalink"></a></h3><p>Low level propagator, to be used through interface.py Compute forward wavefield u = A(m)^{-1}*f and related quantities (u(xrcv))</p><h3 id="propagators.gradient(model,-residual,-rcv*coords,-u,-return*opFalse,-fwTrue,-wNone,-freqNone,-dft_subNone,-ic&#39;as&#39;,-f00.015,-saveTrue,-illumFalse)"><a class="docs-heading-anchor" href="#propagators.gradient(model,-residual,-rcv*coords,-u,-return*opFalse,-fwTrue,-wNone,-freqNone,-dft_subNone,-ic&#39;as&#39;,-f00.015,-saveTrue,-illumFalse)">propagators.gradient(model, residual, rcv<em>coords, u, return</em>op=False, fw=True, w=None, freq=None, dft_sub=None, ic=&#39;as&#39;, f0=0.015, save=True, illum=False)</a><a id="propagators.gradient(model,-residual,-rcv*coords,-u,-return*opFalse,-fwTrue,-wNone,-freqNone,-dft_subNone,-ic&#39;as&#39;,-f00.015,-saveTrue,-illumFalse)-1"></a><a class="docs-heading-anchor-permalink" href="#propagators.gradient(model,-residual,-rcv*coords,-u,-return*opFalse,-fwTrue,-wNone,-freqNone,-dft_subNone,-ic&#39;as&#39;,-f00.015,-saveTrue,-illumFalse)" title="Permalink"></a></h3><p>Low level propagator, to be used through interface.py Compute the action of the adjoint Jacobian onto a residual J’* δ d.</p><h2 id="sensitivity-module"><a class="docs-heading-anchor" href="#sensitivity-module">sensitivity module</a><a id="sensitivity-module-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity-module" title="Permalink"></a></h2><h3 id="sensitivity.Loss(dsyn,-dobs,-dt,-is_residualFalse,-misfitNone)"><a class="docs-heading-anchor" href="#sensitivity.Loss(dsyn,-dobs,-dt,-is_residualFalse,-misfitNone)">sensitivity.Loss(dsyn, dobs, dt, is_residual=False, misfit=None)</a><a id="sensitivity.Loss(dsyn,-dobs,-dt,-is_residualFalse,-misfitNone)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.Loss(dsyn,-dobs,-dt,-is_residualFalse,-misfitNone)" title="Permalink"></a></h3><p>L2 loss and residual between the synthetic data dsyn and observed data dobs</p><ul><li><strong>Parameters:</strong><ul><li><strong>dsyn</strong> (<em>SparseTimeFunction</em> <em>or</em> <em>tuple</em>) – Synthetic data or tuple (background, linearized) data</li><li><strong>dobs</strong> (<em>SparseTimeFunction</em>) – Observed data</li><li><strong>dt</strong> (<em>float</em>) – Time sampling rate</li><li><strong>is_residual</strong> (<em>bool</em>) – Whether input dobs is already the data residual</li><li><strong>misfit</strong> (<em>function</em>) – User provided function of the form: misifit(dsyn, dob) -&gt; obj, adjoint_source</li></ul></li></ul><h3 id="sensitivity.basic_src(model,-u,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.basic_src(model,-u,-**kwargs)">sensitivity.basic_src(model, u, **kwargs)</a><a id="sensitivity.basic_src(model,-u,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.basic_src(model,-u,-**kwargs)" title="Permalink"></a></h3><p>Basic source for linearized modeling</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model containing the perturbation dm</li><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><h3 id="sensitivity.crosscorr*freq(u,-v,-model,-freqNone,-dft*subNone,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.crosscorr*freq(u,-v,-model,-freqNone,-dft*subNone,-**kwargs)">sensitivity.crosscorr<em>freq(u, v, model, freq=None, dft</em>sub=None, **kwargs)</a><a id="sensitivity.crosscorr*freq(u,-v,-model,-freqNone,-dft*subNone,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.crosscorr*freq(u,-v,-model,-freqNone,-dft*subNone,-**kwargs)" title="Permalink"></a></h3><p>Standard cross-correlation imaging condition with on-th-fly-dft</p><ul><li><strong>Parameters:</strong><ul><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li><li><strong>v</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Adjoint wavefield (tuple of fields for TTI)</li><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model structure</li><li><strong>freq</strong> (<em>Array</em>) – Array of frequencies for on-the-fly DFT</li><li><strong>factor</strong> (<em>int</em>) – Subsampling factor for DFT</li></ul></li></ul><h3 id="sensitivity.crosscorr_time(u,-v,-model,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.crosscorr_time(u,-v,-model,-**kwargs)">sensitivity.crosscorr_time(u, v, model, **kwargs)</a><a id="sensitivity.crosscorr_time(u,-v,-model,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.crosscorr_time(u,-v,-model,-**kwargs)" title="Permalink"></a></h3><p>Cross correlation of forward and adjoint wavefield</p><ul><li><strong>Parameters:</strong><ul><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li><li><strong>v</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Adjoint wavefield (tuple of fields for TTI)</li><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model structure</li></ul></li></ul><h3 id="sensitivity.func_name(freqNone,-ic&#39;as&#39;)"><a class="docs-heading-anchor" href="#sensitivity.func_name(freqNone,-ic&#39;as&#39;)">sensitivity.func_name(freq=None, ic=&#39;as&#39;)</a><a id="sensitivity.func_name(freqNone,-ic&#39;as&#39;)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.func_name(freqNone,-ic&#39;as&#39;)" title="Permalink"></a></h3><p>Get key for imaging condition/linearized source function</p><h3 id="sensitivity.fwi_freq(*ar,-**kw)"><a class="docs-heading-anchor" href="#sensitivity.fwi_freq(*ar,-**kw)">sensitivity.fwi_freq(*ar, **kw)</a><a id="sensitivity.fwi_freq(*ar,-**kw)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.fwi_freq(*ar,-**kw)" title="Permalink"></a></h3><h3 id="sensitivity.fwi_src(*ar,-**kw)"><a class="docs-heading-anchor" href="#sensitivity.fwi_src(*ar,-**kw)">sensitivity.fwi_src(*ar, **kw)</a><a id="sensitivity.fwi_src(*ar,-**kw)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.fwi_src(*ar,-**kw)" title="Permalink"></a></h3><h3 id="sensitivity.fwi_time(*ar,-**kw)"><a class="docs-heading-anchor" href="#sensitivity.fwi_time(*ar,-**kw)">sensitivity.fwi_time(*ar, **kw)</a><a id="sensitivity.fwi_time(*ar,-**kw)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.fwi_time(*ar,-**kw)" title="Permalink"></a></h3><h3 id="sensitivity.grad*expr(gradm,-u,-v,-model,-wNone,-freqNone,-dft*subNone,-ic&#39;as&#39;)"><a class="docs-heading-anchor" href="#sensitivity.grad*expr(gradm,-u,-v,-model,-wNone,-freqNone,-dft*subNone,-ic&#39;as&#39;)">sensitivity.grad<em>expr(gradm, u, v, model, w=None, freq=None, dft</em>sub=None, ic=&#39;as&#39;)</a><a id="sensitivity.grad*expr(gradm,-u,-v,-model,-wNone,-freqNone,-dft*subNone,-ic&#39;as&#39;)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.grad*expr(gradm,-u,-v,-model,-wNone,-freqNone,-dft*subNone,-ic&#39;as&#39;)" title="Permalink"></a></h3><p>Gradient update stencil</p><ul><li><strong>Parameters:</strong><ul><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li><li><strong>v</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Adjoint wavefield (tuple of fields for TTI)</li><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model structure</li><li><strong>w</strong> (<em>Float</em> <em>or</em> <em>Expr</em> <em>(**optional</em> <em>)</em>) – Weight for the gradient expression (default=1)</li><li><strong>freq</strong> (<em>Array</em>) – Array of frequencies for on-the-fly DFT</li><li><strong>factor</strong> (<em>int</em>) – Subsampling factor for DFT</li><li><strong>isic</strong> (<em>Bool</em>) – Whether or not to use inverse scattering imaging condition (not supported yet)</li></ul></li></ul><h3 id="sensitivity.inner_grad(u,-v)"><a class="docs-heading-anchor" href="#sensitivity.inner_grad(u,-v)">sensitivity.inner_grad(u, v)</a><a id="sensitivity.inner_grad(u,-v)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.inner_grad(u,-v)" title="Permalink"></a></h3><p>Inner product of the gradient of two fields</p><ul><li><strong>Parameters:</strong><ul><li><strong>u</strong> (<em>TimeFunction</em>) – First field</li><li><strong>v</strong> (<em>TimeFunction</em>) – Second field</li></ul></li></ul><h3 id="sensitivity.isic_freq(u,-v,-model,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.isic_freq(u,-v,-model,-**kwargs)">sensitivity.isic_freq(u, v, model, **kwargs)</a><a id="sensitivity.isic_freq(u,-v,-model,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.isic_freq(u,-v,-model,-**kwargs)" title="Permalink"></a></h3><p>Inverse scattering imaging condition</p><ul><li><strong>Parameters:</strong><ul><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li><li><strong>v</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Adjoint wavefield (tuple of fields for TTI)</li><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model structure</li></ul></li></ul><h3 id="sensitivity.isic_src(model,-u,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.isic_src(model,-u,-**kwargs)">sensitivity.isic_src(model, u, **kwargs)</a><a id="sensitivity.isic_src(model,-u,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.isic_src(model,-u,-**kwargs)" title="Permalink"></a></h3><p>ISIC source for linearized modeling</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model containing the perturbation dm</li><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li></ul></li></ul><h3 id="sensitivity.isic_time(u,-v,-model,-**kwargs)"><a class="docs-heading-anchor" href="#sensitivity.isic_time(u,-v,-model,-**kwargs)">sensitivity.isic_time(u, v, model, **kwargs)</a><a id="sensitivity.isic_time(u,-v,-model,-**kwargs)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.isic_time(u,-v,-model,-**kwargs)" title="Permalink"></a></h3><p>Inverse scattering imaging condition</p><ul><li><strong>Parameters:</strong><ul><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li><li><strong>v</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Adjoint wavefield (tuple of fields for TTI)</li><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model structure</li></ul></li></ul><h3 id="sensitivity.lin_src(model,-u,-ic&#39;as&#39;)"><a class="docs-heading-anchor" href="#sensitivity.lin_src(model,-u,-ic&#39;as&#39;)">sensitivity.lin_src(model, u, ic=&#39;as&#39;)</a><a id="sensitivity.lin_src(model,-u,-ic&#39;as&#39;)-1"></a><a class="docs-heading-anchor-permalink" href="#sensitivity.lin_src(model,-u,-ic&#39;as&#39;)" title="Permalink"></a></h3><p>Source for linearized modeling</p><ul><li><strong>Parameters:</strong><ul><li><strong>model</strong> (<a href="#models.Model"><em>Model</em></a>) – Model containing the perturbation dm</li><li><strong>u</strong> (<em>TimeFunction</em> <em>or</em> <em>Tuple</em>) – Forward wavefield (tuple of fields for TTI or dft)</li><li><strong>ic</strong> (<em>String</em>) – Imaging condition of which we compute the linearized source</li></ul></li></ul><h2 id="sources-module"><a class="docs-heading-anchor" href="#sources-module">sources module</a><a id="sources-module-1"></a><a class="docs-heading-anchor-permalink" href="#sources-module" title="Permalink"></a></h2><h3 id="*class*-sources.PointSource(*args)"><a class="docs-heading-anchor" href="#*class*-sources.PointSource(*args)"><em>class</em> sources.PointSource(*args)</a><a id="*class*-sources.PointSource(*args)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-sources.PointSource(*args)" title="Permalink"></a></h3><p>Symbolic data object for a set of sparse point sources</p><ul><li><strong>Parameters:</strong><ul><li><strong>name</strong> (<em>String</em>) – Name of the symbol representing this source</li><li><strong>grid</strong> (<em>Grid</em>) – Grid object defining the computational domain.</li><li><strong>coordinates</strong> (<em>Array</em>) – Point coordinates for this source</li><li><strong>data</strong> ( <em>(**Optional</em> <em>)</em> <em>Data</em>) – values to initialise point data</li><li><strong>ntime</strong> (<em>Int</em> <em>(**Optional</em> <em>)</em>) – Number of timesteps for which to allocate data</li><li><strong>npoint</strong> (<em>Int</em> <em>(**Optional</em> <em>)</em>)</li><li><strong>source</strong> (<em>Number</em> <em>of</em> <em>sparse points represented by this</em>)</li><li><strong>dimension</strong> (<em>Dimension</em> <em>(**Optional</em> <em>)</em>) – object for representing the number of points in this source</li><li><strong>Note</strong></li><li><strong>fully</strong> (<em>either the dimensions ntime and npoint</em> <em>or</em> <em>the</em>)</li><li><strong>provided.</strong> (<em>initialised data array need to be</em>)</li></ul></li></ul><h4 id="default_assumptions-*:-ClassVar[StdFactKB]*-*-{&#39;commutative&#39;:-True}*"><a class="docs-heading-anchor" href="#default_assumptions-*:-ClassVar[StdFactKB]*-*-{&#39;commutative&#39;:-True}*">default_assumptions <em>: ClassVar[StdFactKB]</em> <em>= {&#39;commutative&#39;: True}</em></a><a id="default_assumptions-*:-ClassVar[StdFactKB]*-*-{&#39;commutative&#39;:-True}*-1"></a><a class="docs-heading-anchor-permalink" href="#default_assumptions-*:-ClassVar[StdFactKB]*-*-{&#39;commutative&#39;:-True}*" title="Permalink"></a></h4><h4 id="is_commutative-*:-bool-None*-*-True*"><a class="docs-heading-anchor" href="#is_commutative-*:-bool-None*-*-True*">is_commutative <em>: bool | None</em> <em>= True</em></a><a id="is_commutative-*:-bool-None*-*-True*-1"></a><a class="docs-heading-anchor-permalink" href="#is_commutative-*:-bool-None*-*-True*" title="Permalink"></a></h4><h3 id="sources.Receiver"><a class="docs-heading-anchor" href="#sources.Receiver">sources.Receiver</a><a id="sources.Receiver-1"></a><a class="docs-heading-anchor-permalink" href="#sources.Receiver" title="Permalink"></a></h3><p>alias of <a href="#sources.PointSource"><code>PointSource</code></a></p><h3 id="*class*-sources.RickerSource(*args)"><a class="docs-heading-anchor" href="#*class*-sources.RickerSource(*args)"><em>class</em> sources.RickerSource(*args)</a><a id="*class*-sources.RickerSource(*args)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-sources.RickerSource(*args)" title="Permalink"></a></h3><p>Symbolic object that encapsulate a set of sources with a pre-defined Ricker wavelet: <a href="http://subsurfwiki.org/wiki/Ricker_wavelet">http://subsurfwiki.org/wiki/Ricker_wavelet</a> name: Name for the resulting symbol grid: <code>Grid</code> object defining the computational domain. f0: Peak frequency for Ricker wavelet in kHz time: Discretized values of time in ms</p><h4 id="default_assumptions-*:-ClassVar[StdFactKB]*-*-{&#39;commutative&#39;:-True}*-2"><a class="docs-heading-anchor" href="#default_assumptions-*:-ClassVar[StdFactKB]*-*-{&#39;commutative&#39;:-True}*-2">default_assumptions <em>: ClassVar[StdFactKB]</em> <em>= {&#39;commutative&#39;: True}</em></a><a class="docs-heading-anchor-permalink" href="#default_assumptions-*:-ClassVar[StdFactKB]*-*-{&#39;commutative&#39;:-True}*-2" title="Permalink"></a></h4><h4 id="is_commutative-*:-bool-None*-*-True*-2"><a class="docs-heading-anchor" href="#is_commutative-*:-bool-None*-*-True*-2">is_commutative <em>: bool | None</em> <em>= True</em></a><a class="docs-heading-anchor-permalink" href="#is_commutative-*:-bool-None*-*-True*-2" title="Permalink"></a></h4><h4 id="wavelet(timev)"><a class="docs-heading-anchor" href="#wavelet(timev)">wavelet(timev)</a><a id="wavelet(timev)-1"></a><a class="docs-heading-anchor-permalink" href="#wavelet(timev)" title="Permalink"></a></h4><h3 id="*class*-sources.TimeAxis(startNone,-stepNone,-numNone,-stopNone)"><a class="docs-heading-anchor" href="#*class*-sources.TimeAxis(startNone,-stepNone,-numNone,-stopNone)"><em>class</em> sources.TimeAxis(start=None, step=None, num=None, stop=None)</a><a id="*class*-sources.TimeAxis(startNone,-stepNone,-numNone,-stopNone)-1"></a><a class="docs-heading-anchor-permalink" href="#*class*-sources.TimeAxis(startNone,-stepNone,-numNone,-stopNone)" title="Permalink"></a></h3><p>Data object to store the TimeAxis. Exactly three of the four key arguments must be prescribed. Because of remainder values it is not possible to create a TimeAxis that exactly adhears to the inputs therefore start, stop, step and num values should be taken from the TimeAxis object rather than relying upon the input values. The four possible cases are: * start is None: start = step*(1 - num) + stop * step is None: step = (stop - start)/(num - 1) * num is None: num = ceil((stop - start + step)/step) and because of remainder stop = step*(num - 1) + start * stop is None: stop = step*(num - 1) + start</p><ul><li><strong>Parameters:</strong><ul><li><strong>start</strong> (<em>float</em> <em>,</em> <em>optional</em>) – Start of time axis.</li><li><strong>step</strong> (<em>float</em> <em>,</em> <em>optional</em>) – Time interval.</li><li><strong>num</strong> (<em>int</em> <em>,</em> <em>optional</em>) – Number of values (Note: this is the number of intervals + 1). Stop value is reset to correct for remainder.</li><li><strong>stop</strong> (<em>float</em> <em>,</em> <em>optional</em>) – End time.</li></ul></li></ul><h4 id="*property*-time_values"><a class="docs-heading-anchor" href="#*property*-time_values"><em>property</em> time_values</a><a id="*property*-time_values-1"></a><a class="docs-heading-anchor-permalink" href="#*property*-time_values" title="Permalink"></a></h4><h2 id="wave_utils-module"><a class="docs-heading-anchor" href="#wave_utils-module">wave_utils module</a><a id="wave_utils-module-1"></a><a class="docs-heading-anchor-permalink" href="#wave_utils-module" title="Permalink"></a></h2><h2 id="Module-contents"><a class="docs-heading-anchor" href="#Module-contents">Module contents</a><a id="Module-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Module-contents" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/quickstart/">« Modeling and inversion with JUDI</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 July 2025 04:01">Wednesday 16 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
