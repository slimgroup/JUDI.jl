<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to JUDI · JUDI documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JUDI documentation</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../about/">About</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../basics/">Getting Started</a></li><li><span class="tocitem">JUDI API</span><ul><li><a class="tocitem" href="../../abstract_vectors/">Abstract vectors</a></li><li><a class="tocitem" href="../../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../../linear_operators/">Linear Operators</a></li><li><a class="tocitem" href="../../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../../io/">Input/Output</a></li><li><a class="tocitem" href="../../helper/">Helper Functions</a></li></ul></li><li><a class="tocitem" href="../../inversion/">Inversion</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Introduction to JUDI</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Physical-problem-setup"><span>Physical problem setup</span></a></li><li><a class="tocitem" href="#Grid"><span>Grid</span></a></li><li><a class="tocitem" href="#Physical-object"><span>Physical object</span></a></li><li><a class="tocitem" href="#Model"><span>Model</span></a></li><li class="toplevel"><a class="tocitem" href="#Modeling"><span>Modeling</span></a></li><li><a class="tocitem" href="#Acquisition-Geometry"><span>Acquisition Geometry</span></a></li><li><a class="tocitem" href="#judiVector"><span>judiVector</span></a></li><li class="toplevel"><a class="tocitem" href="#Linear-operator"><span>Linear operator</span></a></li><li class="toplevel"><a class="tocitem" href="#Seismic-data"><span>Seismic data</span></a></li></ul></li><li><a class="tocitem" href="../02_fwi_example_NLopt/">FWI with Quasi-Newton methods from the NLopt library</a></li><li><a class="tocitem" href="../03_constrained_fwi/">FWI Example</a></li><li><a class="tocitem" href="../04_judi_leading_edge_tutorial/">Full-Waveform Inversion - Part 3: optimization</a></li><li><a class="tocitem" href="../05_custom_misfit/">FWI with user provided misfit function</a></li><li><a class="tocitem" href="../06_automatic_differentiation/">Automatic differentiation with JUDI</a></li><li><a class="tocitem" href="../07_preconditionners/">Seismic preconditionners</a></li><li><a class="tocitem" href="../imaging_conditions/">Imaging conditions in JUDI</a></li><li><a class="tocitem" href="../quickstart/">Modeling and inversion with JUDI</a></li></ul></li><li><a class="tocitem" href="../../pysource/">Devito backend reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Introduction to JUDI</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to JUDI</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/JUDI.jl/blob/master/docs/src/tutorials/01_intro.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-JUDI"><a class="docs-heading-anchor" href="#Introduction-to-JUDI">Introduction to JUDI</a><a id="Introduction-to-JUDI-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-JUDI" title="Permalink"></a></h1><p>JUDI is a framework for large-scale seismic modeling and inversion and designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size 3D problems. The focus of the package lies on seismic modeling as well as PDE-constrained optimization such as full-waveform inversion (FWI) and imaging (LS-RTM). Wave equations in JUDI are solved with <a href="https://www.devitoproject.org">Devito</a>, a Python domain-specific language for automated finite-difference (FD) computations. JUDI&#39;s modeling operators can also be used as layers in (convolutional) neural networks to implement physics-augmented deep learning algorithms. For this, check out JUDI&#39;s deep learning extension via <a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules.jl</a> in <a href="https://github.com/slimgroup/JUDI.jl/blob/master/examples/notebooks/06_automatic_differentiation.ipynb">this tutorial</a>.</p><pre><code class="language-julia">using JUDI, PythonPlot, LinearAlgebra</code></pre><h1 id="Physical-problem-setup"><a class="docs-heading-anchor" href="#Physical-problem-setup">Physical problem setup</a><a id="Physical-problem-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-problem-setup" title="Permalink"></a></h1><h2 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h2><p>JUDI relies on a cartesian grid for modeling and inversion. We start by defining the parameters needed for a cartesian grid:</p><ul><li>A shape</li><li>A grid spacing in each direction</li><li>An origin</li></ul><pre><code class="language-julia">shape = (201, 201) # Number of gridpoints nx, nz
spacing = (10.0, 10.0) # #n meters here
origin = (0.0, 0.0) # In meters as well</code></pre><pre><code class="language-none">(0.0, 0.0)</code></pre><h2 id="Physical-object"><a class="docs-heading-anchor" href="#Physical-object">Physical object</a><a id="Physical-object-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-object" title="Permalink"></a></h2><p>JUDI defines a few basic types to handle physical object such as the velocity model. The type <code>PhyisicalParameter</code> is an abstract vector and behaves as a standard vector. A <code>PhysicalParameter</code> can be constructed in various ways but always require the origin <code>o</code> and grid spacing <code>d</code> that cannot be infered from the array.</p><pre><code class="language-none">PhysicalParameter(v::Array{vDT}, d, o) where `v` is an n-dimensional array and n=size(v)

PhysicalParameter(n, d, o; vDT=Float32) Creates a zero PhysicalParameter

PhysicalParameter(v::Array{vDT}, A::PhysicalParameter) Creates a PhysicalParameter from the Array `v` with n, d, o from `A`

PhysicalParameter(v::Array{vDT, N}, n::Tuple, d::Tuple, o::Tuple) where `v` is a vector or nd-array that is reshaped into shape `n`

PhysicalParameter(v::vDT, n::Tuple, d::Tuple, o::Tuple) Creates a constant (single number) PhyicalParameter</code></pre><p>Let&#39;s make a simple three layer velocity model</p><pre><code class="language-julia"># Define the velocity (in km/sec=m/ms)
vp = 1.5f0 * ones(Float32, shape)
vp[:, 66:end] .= 2.0f0
vp[:, 134:end] .= 2.5f0
# Create a physical parameter
VP = PhysicalParameter(vp, spacing, origin);</code></pre><p>Let&#39;s plot the velocities. Because we adopt a standad cartesian dimension ordering for generality (X, Z) in 2D and (X, Y, Z) in 3D, we plot the transpose of the velocity for proper visualization.</p><pre><code class="language-julia">figure()
subplot(121)
imshow(vp&#39;, cmap=&quot;jet&quot;)
title(&quot;vp&quot;)
subplot(122)
imshow(VP&#39;, cmap=&quot;jet&quot;)
title(&quot;vp as a physical parameter&quot;)</code></pre><p><img src="../01_intro_files/01_intro_7_0.png" alt="png"/></p><pre><code class="language-none">PyObject Text(0.5, 1.0, &#39;vp as a physical parameter&#39;)</code></pre><p>Because the physical parameter behaves as vector, we can easily perform standard operations on it.</p><pre><code class="language-julia">norm(VP), extrema(VP), 2f0 .* VP, VP .^ 2</code></pre><pre><code class="language-none">(411.6956f0, (1.5f0, 2.5f0), PhysicalParameter{Float32} of size (201, 201) with origin (0.0, 0.0) and spacing (10.0, 10.0), PhysicalParameter{Float32} of size (201, 201) with origin (0.0, 0.0) and spacing (10.0, 10.0))</code></pre><h2 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h2><p>JUDI then provide a <code>Model</code> structure that wraps multiple physical parameters toghether. A <code>Model</code> accept currently only accept standard Array as an input (<strong>to be fixed #1</strong>)</p><pre><code class="language-julia">model = Model(shape, spacing, origin, 1f0./vp.^2f0)</code></pre><pre><code class="language-none">Model (n=(201, 201), d=(10.0f0, 10.0f0), o=(0.0f0, 0.0f0)) with parameters [:m]</code></pre><h1 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h1><p>Now that we have a seismic model, we will generate a few shot records.</p><h2 id="Acquisition-Geometry"><a class="docs-heading-anchor" href="#Acquisition-Geometry">Acquisition Geometry</a><a id="Acquisition-Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Acquisition-Geometry" title="Permalink"></a></h2><p>The first thing we need is an acquisiton geometry. In JUDI there is two ways to create a Geometry.</p><ul><li>By hand, as we will show here</li><li>From a SEGY file, as we will show in a follow-up tutorial</li></ul><p>We create a split-spread geomtry with sources at the top and receivers at the ocean bottom (top of second layer).</p><p><strong>Note</strong>:</p><ul><li>JUDI currently expects all three coordinates to be inputed to setup a Geometry in 2D as well. This will be fixed in a later version of JUDI.</li></ul><pre><code class="language-julia"># Sources position
nsrc = 11
xsrc = range(0f0, (shape[1] -1)*spacing[1], length=nsrc)
ysrc = 0f0 .* xsrc # this a 2D case so we set y to zero
zsrc = 12.5f0*ones(Float32, nsrc);</code></pre><p>Now this definition creates a single Array of position, which would correspond to a single Simultenous source. Since we are interested in single source experiments here, we convert these position into an Array of Array of size <code>nsrc</code> where each sub-array is a single source position</p><pre><code class="language-julia">xsrc, ysrc, zsrc = convertToCell.([xsrc, ysrc, zsrc]);</code></pre><pre><code class="language-julia"># OBN position
nrec = 101
xrec = range(0f0, (shape[1] -1)*spacing[1], length=nrec)
yrec = 0f0 # this a 2D case so we set y to zero. This can be a single number for receivers
zrec = (66*spacing[1])*ones(Float32, nrec);</code></pre><p>The last step to be able to create and acquisiton geometry is to define a recording time and sampling rate</p><pre><code class="language-julia">record_time = 4000f0 # Recording time in ms (since we have m/ms for the velocity)
sampling_rate = 4f0; # Let&#39;s use a standard 4ms sampling rate</code></pre><p>Now we can create the source and receivers geometry</p><pre><code class="language-julia">src_geom = Geometry(xsrc, ysrc, zsrc; dt=sampling_rate, t=record_time)
# For the receiver geometry, we specify the number of source to tell JUDI to use the same receiver position for all sources
rec_geom = Geometry(xrec, yrec, zrec, dt=sampling_rate, t=record_time, nsrc=nsrc);</code></pre><p>Let&#39;s visualize the geometry onto the model</p><pre><code class="language-julia">figure();
imshow(vp&#39;, cmap=&quot;jet&quot;, extent=[0, (shape[1]-1)*spacing[1], (shape[2]-1)*spacing[2], 0])
scatter(xsrc, zsrc, label=:sources)
scatter(xrec, zrec, label=&quot;OBN&quot;)
legend()</code></pre><p><img src="../01_intro_files/01_intro_23_0.png" alt="png"/></p><pre><code class="language-none">PyObject &lt;matplotlib.legend.Legend object at 0x2bf0da200&gt;</code></pre><h3 id="Source-wavelet"><a class="docs-heading-anchor" href="#Source-wavelet">Source wavelet</a><a id="Source-wavelet-1"></a><a class="docs-heading-anchor-permalink" href="#Source-wavelet" title="Permalink"></a></h3><p>For the source wavelet, we will use a standard Ricker wavelet at 10Hz for this tutorial.In practice this wavelet would be read from a file or estimated during inversion. </p><pre><code class="language-julia">f0 = 0.010 # Since we use ms, the frequency is in KHz
wavelet = ricker_wavelet(record_time, sampling_rate, f0);
plot(wavelet)</code></pre><p><img src="../01_intro_files/01_intro_25_0.png" alt="png"/></p><pre><code class="language-none">1-element Vector{PyCall.PyObject}:
 PyObject &lt;matplotlib.lines.Line2D object at 0x2bf1896c0&gt;</code></pre><h2 id="judiVector"><a class="docs-heading-anchor" href="#judiVector">judiVector</a><a id="judiVector-1"></a><a class="docs-heading-anchor-permalink" href="#judiVector" title="Permalink"></a></h2><p>In order to represent seismic data, JUDI provide the <code>judiVector</code> type. This type wraps a geometry with the seismic data corresponding to it. Let&#39;s cretae one for the source</p><pre><code class="language-julia">q = judiVector(src_geom, wavelet)</code></pre><pre><code class="language-none">judiVector{Float32, Matrix{Float32}} with 11 sources</code></pre><h1 id="Linear-operator"><a class="docs-heading-anchor" href="#Linear-operator">Linear operator</a><a id="Linear-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-operator" title="Permalink"></a></h1><p>The last step to model our seismic data os to create the linear operator representing the discretized wave equation on the Model we defined. We also need to define the linear operator corresponding to the source injection and the receiver interpolation.</p><pre><code class="language-julia">Pr = judiProjection(rec_geom) # receiver interpolation
Ps = judiProjection(src_geom) # Source interpolation
Ainv = judiModeling(model) # Inverse of the disrete ewave equation.</code></pre><pre><code class="language-none">JUDI forward{Float32} propagator (x * z * time) -&gt; (x * z * time)</code></pre><p><strong>WARNING</strong> While these three operator are well defined in JUDI, <code>judiProjection</code> is a no-op operator and cannot be used by itself but only in combination with a <code>judiModeling</code> operator</p><h1 id="Seismic-data"><a class="docs-heading-anchor" href="#Seismic-data">Seismic data</a><a id="Seismic-data-1"></a><a class="docs-heading-anchor-permalink" href="#Seismic-data" title="Permalink"></a></h1><p>Now that we have all our operators setup we can finally generate synthetic data wit ha simple mat-vec product thanks to the abstraction</p><pre><code class="language-julia">d_obs = Pr * Ainv * Ps&#39; * q</code></pre><pre><code class="language-none">Building forward operator
Operator `forward` ran in 0.48 s
Operator `forward` ran in 0.68 s
Operator `forward` ran in 0.69 s
Operator `forward` ran in 0.68 s
Operator `forward` ran in 0.69 s
Operator `forward` ran in 0.68 s
Operator `forward` ran in 0.66 s
Operator `forward` ran in 0.68 s
Operator `forward` ran in 0.68 s
Operator `forward` ran in 0.66 s
Operator `forward` ran in 0.68 s





judiVector{Float32, Matrix{Float32}} with 11 sources</code></pre><pre><code class="language-julia">data_extent = [xrec[1], xrec[end], 1f-3*record_time, 0]
figure(figsize=(20, 5))
for i=1:5
    subplot(1, 5, i)
    imshow(d_obs.data[2*i], vmin=-1, vmax=1, cmap=&quot;Greys&quot;, extent=data_extent, aspect=&quot;auto&quot;)
    xlabel(&quot;Receiver position (m)&quot;)
    ylabel(&quot;Recording time (s)&quot;)
    title(&quot;xsrc=$(1f-3xsrc[2*i][1])km&quot;)
end
tight_layout()</code></pre><p><img src="../01_intro_files/01_intro_33_0.png" alt="png"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../inversion/">« Inversion</a><a class="docs-footer-nextpage" href="../02_fwi_example_NLopt/">FWI with Quasi-Newton methods from the NLopt library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 July 2025 04:01">Wednesday 16 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
