<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inversion · JUDI documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JUDI documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../about/">About</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../basics/">Getting Started</a></li><li><span class="tocitem">JUDI API</span><ul><li><a class="tocitem" href="../abstract_vectors/">Abstract vectors</a></li><li><a class="tocitem" href="../data_structures/">Data Structures</a></li><li><a class="tocitem" href="../linear_operators/">Linear Operators</a></li><li><a class="tocitem" href="../preconditioners/">Preconditioners</a></li><li><a class="tocitem" href="../io/">Input/Output</a></li><li><a class="tocitem" href="../helper/">Helper Functions</a></li></ul></li><li class="is-active"><a class="tocitem" href>Inversion</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#FWI"><span>FWI</span></a></li><li><a class="tocitem" href="#LSRTM"><span>LSRTM</span></a></li><li><a class="tocitem" href="#TWRI"><span>TWRI</span></a></li><li><a class="tocitem" href="#Machine-Learning"><span>Machine Learning</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/01_intro/">Introduction to JUDI</a></li><li><a class="tocitem" href="../tutorials/02_fwi_example_NLopt/">FWI with Quasi-Newton methods from the NLopt library</a></li><li><a class="tocitem" href="../tutorials/03_constrained_fwi/">FWI Example</a></li><li><a class="tocitem" href="../tutorials/04_judi_leading_edge_tutorial/">Full-Waveform Inversion - Part 3: optimization</a></li><li><a class="tocitem" href="../tutorials/05_custom_misfit/">FWI with user provided misfit function</a></li><li><a class="tocitem" href="../tutorials/06_automatic_differentiation/">Automatic differentiation with JUDI</a></li><li><a class="tocitem" href="../tutorials/07_preconditionners/">Seismic preconditionners</a></li><li><a class="tocitem" href="../tutorials/imaging_conditions/">Imaging conditions in JUDI</a></li><li><a class="tocitem" href="../tutorials/quickstart/">Modeling and inversion with JUDI</a></li></ul></li><li><a class="tocitem" href="../pysource/">Devito backend reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Inversion</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Inversion</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/slimgroup/JUDI.jl/blob/master/docs/src/inversion.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Seismic-Inversion"><a class="docs-heading-anchor" href="#Seismic-Inversion">Seismic Inversion</a><a id="Seismic-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Seismic-Inversion" title="Permalink"></a></h1><ul><li><a href="#Seismic-Inversion">Seismic Inversion</a></li><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#FWI">FWI</a></li><li><a href="#LSRTM">LSRTM</a></li><li><a href="#TWRI">TWRI</a></li><li><a href="#Machine-Learning">Machine Learning</a></li></ul></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>We currently introduced the linear operators that allow to write seismic modeling and inversion in a high-level, linear algebra way. These linear operator allow the script to closely follow the mathematics and to be readable and understandable.</p><p>However, these come with overhead. In particular, consider the following compuation on the FWI gradient:</p><pre><code class="language-julia">
d_syn = F*q
r = judiJacobian(F, q)&#39; * (d_syn - d_obs)</code></pre><p>In this two lines, the forward modeling is performed twice: once to compute <code>d_syn</code> then once again to compute the Jacobian adjoint. In order to avoid this overhead for practical inversion, we provide utility function that directly comput the gradient and objective function (L2- misfit) of FWI, LSRTM and TWRI with minimum overhead.</p><h2 id="FWI"><a class="docs-heading-anchor" href="#FWI">FWI</a><a id="FWI-1"></a><a class="docs-heading-anchor-permalink" href="#FWI" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JUDI.fwi_objective" href="#JUDI.fwi_objective"><code>JUDI.fwi_objective</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fwi_objective(model, source, dobs; options=Options())

Evaluate the full-waveform-inversion (reduced state) objective function. Returns a tuple with function value and vectorized \</code></pre><p>gradient. <code>model</code> is a <code>Model</code> structure with the current velocity model and <code>source</code> and <code>dobs</code> are the wavelets and <br/>observed data of type <code>judiVector</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">function_value, gradient = fwi_objective(model, source, dobs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JUDI.jl/blob/9d95da7b2194f1c31618135e456acd587df0720e/src/TimeModeling/Modeling/misfit_fg.jl#L137-L147">source</a></section></article><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>JUDI is designed to let you set up objective functions that can be passed to standard packages for (gradient-based) optimization. The following example demonstrates how to perform FWI on the 2D Overthrust model using a spectral projected gradient algorithm from the minConf library, which is included in the software. A small test dataset (62 MB) and the model can be downloaded from this FTP server:</p><pre><code class="language-julia">run(`wget ftp://slim.gatech.edu/data/SoftwareRelease/WaveformInversion.jl/2DFWI/overthrust_2D.segy`)
run(`wget ftp://slim.gatech.edu/data/SoftwareRelease/WaveformInversion.jl/2DFWI/overthrust_2D_initial_model.h5`)</code></pre><p>The first step is to load the velocity model and the observed data into Julia, as well as setting up bound constraints for the inversion, which prevent too high or low velocities in the final result. Furthermore, we define an 8 Hertz Ricker wavelet as the source function:</p><pre><code class="language-julia">using PyPlot, HDF5, SegyIO, JUDI, SlimOptim, Statistics, Random

# Load starting model
n, d, o, m0 = read(h5open(&quot;overthrust_2D_initial_model.h5&quot;, &quot;r&quot;), &quot;n&quot;, &quot;d&quot;, &quot;o&quot;, &quot;m0&quot;)
model0 = Model((n[1], n[2]), (d[1], d[2]), (o[1], o[2]), m0)	# need n, d, o as tuples and m0 as array

# Bound constraints
vmin = ones(Float32, model0.n) .+ 0.3f0
vmax = ones(Float32, model0.n) .+ 5.5f0
mmin = vec((1f0 ./ vmax).^2)	# convert to slowness squared [s^2/km^2]
mmax = vec((1f0 ./ vmin).^2)

# Load segy data
block = segy_read(&quot;overthrust_2D.segy&quot;)
dobs = judiVector(block)

# Set up wavelet
src_geometry = Geometry(block; key=&quot;source&quot;, segy_depth_key=&quot;SourceDepth&quot;)	# read source position geometry
wavelet = ricker_wavelet(src_geometry.t[1], src_geometry.dt[1], 0.008f0)	# 8 Hz wavelet
q = judiVector(src_geometry, wavelet)
</code></pre><p>For this FWI example, we define an objective function that can be passed to the minConf optimization library, which is included in the Julia Devito software package. We allow a maximum of 20 function evaluations using a spectral-projected gradient (SPG) algorithm. To save computational cost, each function evaluation uses a randomized subset of 20 shot records, instead of all 97 shots:</p><pre><code class="language-julia"># Optimization parameters
fevals = 20	# number of function evaluations
batchsize = 20	# number of sources per iteration
fvals = zeros(21)
opt = Options(optimal_checkpointing = false)    # set to true to enable checkpointing

# Objective function for minConf library
count = 0
function objective_function(x)
	model0.m = reshape(x, model0.n);

	# fwi function value and gradient
	i = randperm(dobs.nsrc)[1:batchsize]
	fval, grad = fwi_objective(model0, q[i], dobs[i]; options=opt)
	grad = reshape(grad, model0.n); grad[:, 1:21] .= 0f0	# reset gradient in water column to 0.
	grad = .1f0*grad/maximum(abs.(grad))	# scale gradient for line search

	global count; count += 1; fvals[count] = fval
    return fval, vec(grad.data)
end

# FWI with SPG
ProjBound(x) = median([mmin x mmax], dims=2)	# Bound projection
options = spg_options(verbose=3, maxIter=fevals, memory=3)
res = spg(objective_function, vec(m0), ProjBound, options)</code></pre><p>This example script can be run in parallel and requires roughly 220 MB of memory per source location. Execute the following code to generate figures of the initial model and the result, as well as the function values:</p><pre><code class="language-julia">figure(); imshow(sqrt.(1. /adjoint(m0))); title(&quot;Initial model&quot;)
figure(); imshow(sqrt.(1. /adjoint(reshape(x, model0.n)))); title(&quot;FWI&quot;)
figure(); plot(fvals); title(&quot;Function value&quot;)</code></pre><p><img src="../figures/fwi.png" alt="fwi"/></p><h2 id="LSRTM"><a class="docs-heading-anchor" href="#LSRTM">LSRTM</a><a id="LSRTM-1"></a><a class="docs-heading-anchor-permalink" href="#LSRTM" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JUDI.lsrtm_objective" href="#JUDI.lsrtm_objective"><code>JUDI.lsrtm_objective</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lsrtm_objective(model, source, dobs, dm; options=Options(), nlind=false)</code></pre><p>Evaluate the least-square migration objective function. Returns a tuple with function value and <br/>gradient. <code>model</code> is a <code>Model</code> structure with the current velocity model and <code>source</code> and <code>dobs</code> are the wavelets and <br/>observed data of type <code>judiVector</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">function_value, gradient = lsrtm_objective(model, source, dobs, dm)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JUDI.jl/blob/9d95da7b2194f1c31618135e456acd587df0720e/src/TimeModeling/Modeling/misfit_fg.jl#L155-L165">source</a></section></article><h3 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h3><p>JUDI includes matrix-free linear operators for modeling and linearized (Born) modeling, that let you write algorithms for migration that follow the mathematical notation of standard least squares problems. This example demonstrates how to use Julia Devito to perform least-squares reverse-time migration on the 2D Marmousi model. Start by downloading the test data set (1.1 GB) and the model:</p><pre><code class="language-julia">run(`wget ftp://slim.gatech.edu/data/SoftwareRelease/Imaging.jl/2DLSRTM/marmousi_2D.segy`)
run(`wget ftp://slim.gatech.edu/data/SoftwareRelease/Imaging.jl/2DLSRTM/marmousi_migration_velocity.h5`)</code></pre><p>Once again, load the starting model and the data and set up the source wavelet. For this example, we use a Ricker wavelet with 30 Hertz peak frequency.</p><pre><code class="language-julia">using PyPlot, HDF5, JUDI, SegyIO, Random

# Load smooth migration velocity model
n,d,o,m0 = read(h5open(&quot;marmousi_migration_velocity.h5&quot;,&quot;r&quot;), &quot;n&quot;, &quot;d&quot;, &quot;o&quot;, &quot;m0&quot;)
model0 = Model((n[1],n[2]), (d[1],d[2]), (o[1],o[2]), m0)

# Load data
block = segy_read(&quot;marmousi_2D.segy&quot;)
dD = judiVector(block)

# Set up wavelet
src_geometry = Geometry(block; key=&quot;source&quot;, segy_depth_key=&quot;SourceDepth&quot;)
wavelet = ricker_wavelet(src_geometry.t[1],src_geometry.dt[1],0.03)	# 30 Hz wavelet
q = judiVector(src_geometry,wavelet)

# Set up info structure
ntComp = get_computational_nt(q.geometry,dD.geometry,model0)	# no. of computational time steps
info = Info(prod(model0.n),dD.nsrc,ntComp)</code></pre><p>To speed up the convergence of our imaging example, we set up a basic preconditioner for each the model- and the data space, consisting of mutes to suppress the ocean-bottom reflection in the data and the source/receiver imprint in the image. The operator <code>J</code> represents the linearized modeling operator and its adjoint <code>J&#39;</code> corresponds to the migration (RTM) operator. The forward and adjoint pair can be used for a basic LS-RTM example with (stochastic) gradient descent:</p><pre><code class="language-julia"># Set up matrix-free linear operators
opt = Options(optimal_checkpointing = true)    # set to false to disable optimal checkpointing
F = judiModeling(model0, q.geometry, dD.geometry; options=opt)
J = judiJacobian(F, q)

# Right-hand preconditioners (model topmute)
Mr = judiTopmute(model0; taperwidth=10)	# mute up to grid point 52, with 10 point taper
# Left-hand side preconditioners
Ml = judiDatMute(q.geometry, dD.geometry; t0=.120)	# data topmute starting at time 120ms

# Stochastic gradient
x = zeros(Float32, info.n)	# zero initial guess
batchsize = 10	# use subset of 10 shots per iteration
niter = 32
fval = zeros(Float32, niter)

for j=1:niter
	println(&quot;Iteration: &quot;, j)

	# Select batch and set up left-hand preconditioner
	i = randperm(dD.nsrc)[1:batchsize]

	# Compute residual and gradient
	r = Ml[i]*J[i]*Mr*x - Ml[i]*dD[i]
	g = adjoint(Mr)*adjoint(J[i])*adjoint(Ml[i])*r

	# Step size and update variable
	fval[j] = .5f0*norm(r)^2
	t = norm(r)^2/norm(g)^2
	global x -= t*g
end</code></pre><p><img src="../figures/lsrtm.png" alt="lsrtm"/></p><h2 id="TWRI"><a class="docs-heading-anchor" href="#TWRI">TWRI</a><a id="TWRI-1"></a><a class="docs-heading-anchor-permalink" href="#TWRI" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JUDI.twri_objective" href="#JUDI.twri_objective"><code>JUDI.twri_objective</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">twri_objective(model, source, dobs; options=Options(), optionswri=TWRIOptions())</code></pre><p>Evaluate the time domain Wavefield reconstruction inversion objective function. Returns a tuple with function value and <br/>gradient(s) w.r.t to m and/or y. <code>model</code> is a <code>Model</code> structure with the current velocity model and <code>source</code> and <code>dobs</code> are the wavelets and <br/>observed data of type <code>judiVector</code>. Example =======     function<em>value, gradient = fwi</em>objective(model, source, dobs)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JUDI.jl/blob/9d95da7b2194f1c31618135e456acd587df0720e/src/TimeModeling/Modeling/twri_objective.jl#L128-L136">source</a></section></article><p>and related TWRI options</p><article class="docstring"><header><a class="docstring-binding" id="JUDI.TWRIOptions" href="#JUDI.TWRIOptions"><code>JUDI.TWRIOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TWRIOptions
    grad_corr::Bool
    comp_alpha::Bool
    weight_fun
    eps
    params::Symbol
    Invq::String</code></pre><p>Options structure for TWRI.</p><p><code>grad_corr</code>: Whether to add the gradient correction J&#39;(m0, q)*∇_y</p><p><code>comp_alpha</code>: Whether to compute optimal alpha (alpha=1 if not)</p><p><code>weight_fun</code>: Whether to apply focusing/weighting function to F(m0)&#39;*y and its norm</p><p><code>eps</code>: Epsilon (noise level) value (default=0)</p><p><code>Invq</code>: How to compute F&#39;Y, either as full field or as a rank 1 approximation <code>w(t)*q(x)</code> using the source wavelet for w</p><p><code>param</code>: Which gradient to compute. Choices are <code>nothing</code> (objective only), <code>:m</code>, <code>:y</code> or <code>:all</code></p><p><strong>Constructor</strong></p><p>All arguments are optional keyword arguments with the following default values:</p><p>TWRIOptions(;grad<em>corr=false, comp</em>alpha=true, weight_fun=nothing, eps=0, params=:m)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/slimgroup/JUDI.jl/blob/9d95da7b2194f1c31618135e456acd587df0720e/src/TimeModeling/Modeling/twri_objective.jl#L15-L44">source</a></section></article><h2 id="Machine-Learning"><a class="docs-heading-anchor" href="#Machine-Learning">Machine Learning</a><a id="Machine-Learning-1"></a><a class="docs-heading-anchor-permalink" href="#Machine-Learning" title="Permalink"></a></h2><p><a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules.jl</a> allows integrating JUDI modeling operators into convolutional neural networks for deep learning. For example, the following code snippet shows how to create a shallow CNN consisting of two convolutional layers with a nonlinear forward modeling layer in-between them. The integration of ChainRules and JUDI enables backpropagation through Flux&#39; automatic differentiation tool, but calls the corresponding adjoint JUDI operators under the hood. For more details, please check out <a href="https://github.com/slimgroup/JUDI.jl/blob/master/examples/notebooks/06_automatic_differentiation.ipynb">this tutorial</a>.</p><pre><code class="language-julia"># Jacobian
W1 = judiJacobian(F0, q)
b1 = randn(Float32, num_samples)

# Fully connected layer
W2 = randn(Float32, n_out, num_samples)
b2 = randn(Float32, n_out)

# Network and loss
network(x) = W2*(W1*x .+ b1) .+ b2
loss(x, y) = Flux.mse(network(x), y)

# Compute gradient w/ Flux
p = params(x, y, W1, b1, b2)
gs = Tracker.gradient(() -&gt; loss(x, y), p)
gs[x]	# gradient w.r.t. to x</code></pre><p>Integration with ChainRules allows implementing physics-augmented neural networks for seismic inversion, such as loop-unrolled seismic imaging algorithms. For example, the following results are a conventional RTM image, an LS-RTM image and a loop-unrolled LS-RTM image for a single simultaneous shot record.</p><p><img src="../figures/figure1.png" alt="flux"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../helper/">« Helper Functions</a><a class="docs-footer-nextpage" href="../tutorials/01_intro/">Introduction to JUDI »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 4 August 2024 13:23">Sunday 4 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
