{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Julia Devito Inversion framework (JUDI.jl) JUDI is a framework for large-scale seismic modeling and inversion and designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size 3D problems. Wave equations in JUDI are solved with Devito , a Python domain-specific language for automated finite-difference (FD) computations. Docs overview This documentation provides an overview over JUDI's basic data structures and abstract operators: Tutorials : Shows basic functionalities and some common applications. Data structures : Explains the Model , Geometry and Info data structures and how to set up acquisition geometries. Abstract vectors : Documents JUDI's abstract vector classes judiVector , judiWavefield , judiRHS , judiWeights and judiExtendedSource . Abstract operators : Lists and explains JUDI's abstract linear operators judiModeling , judiJacobian , judiProjection and judiLRWF . Input/Output : Read SEG-Y data and set up judiVectors for shot records and sources. Read velocity models. Helper functions : API of functions that make your life easier. Preconditioners : Basic preconditioners for seismic imaging. Installation First, install Devito using pip , or see the Devito's GitHub page for installation with Conda and further information. The current release of JUDI requires Python 3 and the current Devito version. Run all of the following commands from the (bash) terminal command line (not in the Julia REPL): pip3 install --user git+https://github.com/devitocodes/devito.git For reading and writing seismic SEG-Y data, JUDI uses the SegyIO package and matrix-free linear operators are based the Julia Operator LIbrary (JOLI): julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/SegyIO.jl\"))' julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JOLI.jl\"))' Once Devito, SegyIO and JOLI are installed, you can install JUDI as follows: julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JUDI.jl\"))' Once you have JUDI installed, you need to point Julia's PyCall package to the Python version for which we previsouly installed Devito. To do this, copy-paste the following commands into the (bash) terminal: export PYTHON=$(which python3) julia -e 'using Pkg; Pkg.build(\"PyCall\")' Running with Docker If you do not want to install JUDI, you can run JUDI as a docker image. The first possibility is to run the docker container as a Jupyter notebook: docker run -p 8888:8888 philippwitte/judi:v1.3 This command downloads the image and launches a container. You will see a link that you can copy-past to your browser to access the notebooks. Alternatively, you can run a bash session, in which you can start a regular interactive Julia session and run the example scripts. Download/start the container as a bash session with: docker run -it philippwitte/judi:v1.3 /bin/bash Inside the container, all examples are located in the directory /app/judi/examples/scripts . Configure compiler and OpenMP Devito uses just-in-time compilation for the underlying wave equation solves. The default compiler is intel, but can be changed to any other specified compiler such as gnu . Either run the following command from the command line or add it to your ~/.bashrc file: export DEVITO_ARCH=gnu Devito uses shared memory OpenMP parallelism for solving PDEs. OpenMP is disabled by default, but you can enable OpenMP and define the number of threads (per PDE solve) as follows: export DEVITO_LANGUAGE=openmp # Enable OpenMP. export OMP_NUM_THREADS=4 # Number of OpenMP threads Troubleshooting For troubleshooting please raise an issue on the JUDI github page or contact Philipp Witte at pwitte3@gatech.edu or Mathias Louboutin at mlouboutin3@gatech.edu","title":"Home"},{"location":"#the-julia-devito-inversion-framework-judijl","text":"JUDI is a framework for large-scale seismic modeling and inversion and designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size 3D problems. Wave equations in JUDI are solved with Devito , a Python domain-specific language for automated finite-difference (FD) computations.","title":"The Julia Devito Inversion framework (JUDI.jl)"},{"location":"#docs-overview","text":"This documentation provides an overview over JUDI's basic data structures and abstract operators: Tutorials : Shows basic functionalities and some common applications. Data structures : Explains the Model , Geometry and Info data structures and how to set up acquisition geometries. Abstract vectors : Documents JUDI's abstract vector classes judiVector , judiWavefield , judiRHS , judiWeights and judiExtendedSource . Abstract operators : Lists and explains JUDI's abstract linear operators judiModeling , judiJacobian , judiProjection and judiLRWF . Input/Output : Read SEG-Y data and set up judiVectors for shot records and sources. Read velocity models. Helper functions : API of functions that make your life easier. Preconditioners : Basic preconditioners for seismic imaging.","title":"Docs overview"},{"location":"#installation","text":"First, install Devito using pip , or see the Devito's GitHub page for installation with Conda and further information. The current release of JUDI requires Python 3 and the current Devito version. Run all of the following commands from the (bash) terminal command line (not in the Julia REPL): pip3 install --user git+https://github.com/devitocodes/devito.git For reading and writing seismic SEG-Y data, JUDI uses the SegyIO package and matrix-free linear operators are based the Julia Operator LIbrary (JOLI): julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/SegyIO.jl\"))' julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JOLI.jl\"))' Once Devito, SegyIO and JOLI are installed, you can install JUDI as follows: julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JUDI.jl\"))' Once you have JUDI installed, you need to point Julia's PyCall package to the Python version for which we previsouly installed Devito. To do this, copy-paste the following commands into the (bash) terminal: export PYTHON=$(which python3) julia -e 'using Pkg; Pkg.build(\"PyCall\")'","title":"Installation"},{"location":"#running-with-docker","text":"If you do not want to install JUDI, you can run JUDI as a docker image. The first possibility is to run the docker container as a Jupyter notebook: docker run -p 8888:8888 philippwitte/judi:v1.3 This command downloads the image and launches a container. You will see a link that you can copy-past to your browser to access the notebooks. Alternatively, you can run a bash session, in which you can start a regular interactive Julia session and run the example scripts. Download/start the container as a bash session with: docker run -it philippwitte/judi:v1.3 /bin/bash Inside the container, all examples are located in the directory /app/judi/examples/scripts .","title":"Running with Docker"},{"location":"#configure-compiler-and-openmp","text":"Devito uses just-in-time compilation for the underlying wave equation solves. The default compiler is intel, but can be changed to any other specified compiler such as gnu . Either run the following command from the command line or add it to your ~/.bashrc file: export DEVITO_ARCH=gnu Devito uses shared memory OpenMP parallelism for solving PDEs. OpenMP is disabled by default, but you can enable OpenMP and define the number of threads (per PDE solve) as follows: export DEVITO_LANGUAGE=openmp # Enable OpenMP. export OMP_NUM_THREADS=4 # Number of OpenMP threads","title":"Configure compiler and OpenMP"},{"location":"#troubleshooting","text":"For troubleshooting please raise an issue on the JUDI github page or contact Philipp Witte at pwitte3@gatech.edu or Mathias Louboutin at mlouboutin3@gatech.edu","title":"Troubleshooting"},{"location":"about/","text":"Authors This documentation was created by Philipp A. Witte ( pwitte3@gatech.edu ) from the Georgia Institute of Technology. People involved in the development of JUDI include: Philipp A. Witte (Georgia Institute of Technology) Mathias Louboutin (Georgia Institute of Technology) Henryk Modzelewski (The Univeristy of British Columbia) Felix J. Herrmann (Georgia Institute of Technology) The research of this project was carried out at the Seismic Laboratory for Imaging and Modeling (SLIM) at the Georgia Institute of Technology, Atlanta, USA and at the University of British Columbia (UBC), in Vancouver, Canada.","title":"About"},{"location":"about/#authors","text":"This documentation was created by Philipp A. Witte ( pwitte3@gatech.edu ) from the Georgia Institute of Technology. People involved in the development of JUDI include: Philipp A. Witte (Georgia Institute of Technology) Mathias Louboutin (Georgia Institute of Technology) Henryk Modzelewski (The Univeristy of British Columbia) Felix J. Herrmann (Georgia Institute of Technology) The research of this project was carried out at the Seismic Laboratory for Imaging and Modeling (SLIM) at the Georgia Institute of Technology, Atlanta, USA and at the University of British Columbia (UBC), in Vancouver, Canada.","title":"Authors"},{"location":"abstract_vectors/","text":"Abstract JUDI vectors judiVector The class judiVector is the basic data structure for seismic shot records or seismic sources. From JUDI's perspective, both are treated the same and can be multiplied with modeling operators. Construction: In the most basic way, judiVectors are contstructed from a Geometry object (containing either source or receiver geometry) and a cell array of data: x = judiVector(geometry, data) Parameters: geometry : A Geometry object containing source or receiver geometries. data : A cell array with one cell per source location, where each cell contains a 1D/2D Julia array with either the receiver data or the source wavelet. Alternatively: pass a single Julia array which will be used for all source locations. Access fields (in-core data containers): # Access i-th shot record x.data[i] # Extract judiVector for i-th shot x1 = x[i] # Access j-th receiver location of i-th shot x.geometry.xloc[i][j] Access fields (out-of-core data containers): # Access data container of i-th shot x.data[i] # Read data from i-th shot into memory x.data[i][1].data # Access out-of-core geometry x.geometry # Load OOC geometry into memory Geometry(x.geometry) Operations: In-core judiVectors can be used like regular Julia arrays and support common operations such as: x = judiVector(geometry, data) # Size (as if all data was vectorized) size(x) # Norms norm(x) # Inner product dot(x, x) # Addition, subtraction (geometries must match) y = x + x z = x - y # Scaling \u03b1 = 2f0 y = x * \u03b1 # Concatenate y = vcat(x, x) judiWavefield Abstract vector class for wavefields. Construction: u = judiWavefield(info, dt, data) Parameters: info : An Info structure. dt : Time sampling interval of wavefield. data : Cell array with one cell per source location. Each cell contains a 3D or 4D array for a seismic wavefield. The order of dimensions is (nt, nx, nz) (2D) and (nt, nx, ny, nz) (3D), where nt is the number of time steps. Access fields: # Access wavefield from i-th shot location u.data[i] Operations: Supports some basic arithmetric operations: # Size size(u) # Norms norm(u) # Inner product dot(u, y) # Addition, subtraction v = u + u z = u - v # Absolute value abs(u) # Concatenation v = vcat(u, u) judiRHS Abstract vector class for a right-hand-side (RHS). A RHS has the size of a full wavefield, but only contains the data of the source wavelet of shot records in memory, as well as the geometry information of where the data is injected during modeling. Construction: rhs = judiRHS(info, geometry, data) A JUDI RHS can also be constructed by multplying a judiVector and the corresponding transpose of a judiProjection operator: rhs1 = Ps'*q rhs2 = Pr'*d_obs where Ps and Pr are judiProjection operators for sources and receivers respectively and q and d_obs are judiVectors with the source and receiver data. Parameters: info : An Info structure. geometry : A JUDI Geometry structure, containing the source or receiver geometry. data : A cell array with one cell per source location. Each cell contains a 1D/2D Julia array with the source or receiver data. Access fields: Accessible fields include: # Source/receiver data rhs.data # Source/receiver geometry rhs.geometry # Info structure rhs.info judiWeights Abstract vector class for extended source weights. The weights for each shot location have the dimensions of the model (namely model.n ). Construction: w = judiWeights(weights) Parameters: weights : Cell array with one cell per shot location. Each cell contains a 2D/3D Julia array with the weights for the spatially extended source. Alternatively: pass a single Julia array which will be used for all source locations. Access fields: # Access weights of i-th shot locatoin w.weights[i] Operations: Supports the same arithmetric operations as a judiVector . judiExtendedSource Abstract data vector for an extended source. This data structure is the equivalent type of judiRHS for extended source modeling. A judiExtendedSource has the dimension of the full wavefield, but only contains the 1D wavelet and the 2D/3D spatially varying weights in memory. Construction: Construction from weights and source wavelets: ex_src = judiExtendedSource(info, wavelet, weights) Construction from a judiWeights vector and a judiLRWF injection operator: ex_src = Pw'*w where Pw is a judiLRWF operator and w is a judiWeights vector. Parameters: info : An Info structure. wavelet : A cell array with one cell per source location containing a 1D Julia array with the time varying source wavelet or a single 1D Julia array, which is used for all source locations. weights : A cell array with one cell per source location containing a 2D/3D Julia array with the spatially varying source weights or a single 1D Julia array, which is used for all source locations. Access fields: # Access weights of i-th source location ex_src.weights[i] # Access wavelet of i-th source location ex_src.wavelet[i]","title":"Abstract vectors"},{"location":"abstract_vectors/#abstract-judi-vectors","text":"","title":"Abstract JUDI vectors"},{"location":"abstract_vectors/#judivector","text":"The class judiVector is the basic data structure for seismic shot records or seismic sources. From JUDI's perspective, both are treated the same and can be multiplied with modeling operators. Construction: In the most basic way, judiVectors are contstructed from a Geometry object (containing either source or receiver geometry) and a cell array of data: x = judiVector(geometry, data) Parameters: geometry : A Geometry object containing source or receiver geometries. data : A cell array with one cell per source location, where each cell contains a 1D/2D Julia array with either the receiver data or the source wavelet. Alternatively: pass a single Julia array which will be used for all source locations. Access fields (in-core data containers): # Access i-th shot record x.data[i] # Extract judiVector for i-th shot x1 = x[i] # Access j-th receiver location of i-th shot x.geometry.xloc[i][j] Access fields (out-of-core data containers): # Access data container of i-th shot x.data[i] # Read data from i-th shot into memory x.data[i][1].data # Access out-of-core geometry x.geometry # Load OOC geometry into memory Geometry(x.geometry) Operations: In-core judiVectors can be used like regular Julia arrays and support common operations such as: x = judiVector(geometry, data) # Size (as if all data was vectorized) size(x) # Norms norm(x) # Inner product dot(x, x) # Addition, subtraction (geometries must match) y = x + x z = x - y # Scaling \u03b1 = 2f0 y = x * \u03b1 # Concatenate y = vcat(x, x)","title":"judiVector"},{"location":"abstract_vectors/#judiwavefield","text":"Abstract vector class for wavefields. Construction: u = judiWavefield(info, dt, data) Parameters: info : An Info structure. dt : Time sampling interval of wavefield. data : Cell array with one cell per source location. Each cell contains a 3D or 4D array for a seismic wavefield. The order of dimensions is (nt, nx, nz) (2D) and (nt, nx, ny, nz) (3D), where nt is the number of time steps. Access fields: # Access wavefield from i-th shot location u.data[i] Operations: Supports some basic arithmetric operations: # Size size(u) # Norms norm(u) # Inner product dot(u, y) # Addition, subtraction v = u + u z = u - v # Absolute value abs(u) # Concatenation v = vcat(u, u)","title":"judiWavefield"},{"location":"abstract_vectors/#judirhs","text":"Abstract vector class for a right-hand-side (RHS). A RHS has the size of a full wavefield, but only contains the data of the source wavelet of shot records in memory, as well as the geometry information of where the data is injected during modeling. Construction: rhs = judiRHS(info, geometry, data) A JUDI RHS can also be constructed by multplying a judiVector and the corresponding transpose of a judiProjection operator: rhs1 = Ps'*q rhs2 = Pr'*d_obs where Ps and Pr are judiProjection operators for sources and receivers respectively and q and d_obs are judiVectors with the source and receiver data. Parameters: info : An Info structure. geometry : A JUDI Geometry structure, containing the source or receiver geometry. data : A cell array with one cell per source location. Each cell contains a 1D/2D Julia array with the source or receiver data. Access fields: Accessible fields include: # Source/receiver data rhs.data # Source/receiver geometry rhs.geometry # Info structure rhs.info","title":"judiRHS"},{"location":"abstract_vectors/#judiweights","text":"Abstract vector class for extended source weights. The weights for each shot location have the dimensions of the model (namely model.n ). Construction: w = judiWeights(weights) Parameters: weights : Cell array with one cell per shot location. Each cell contains a 2D/3D Julia array with the weights for the spatially extended source. Alternatively: pass a single Julia array which will be used for all source locations. Access fields: # Access weights of i-th shot locatoin w.weights[i] Operations: Supports the same arithmetric operations as a judiVector .","title":"judiWeights"},{"location":"abstract_vectors/#judiextendedsource","text":"Abstract data vector for an extended source. This data structure is the equivalent type of judiRHS for extended source modeling. A judiExtendedSource has the dimension of the full wavefield, but only contains the 1D wavelet and the 2D/3D spatially varying weights in memory. Construction: Construction from weights and source wavelets: ex_src = judiExtendedSource(info, wavelet, weights) Construction from a judiWeights vector and a judiLRWF injection operator: ex_src = Pw'*w where Pw is a judiLRWF operator and w is a judiWeights vector. Parameters: info : An Info structure. wavelet : A cell array with one cell per source location containing a 1D Julia array with the time varying source wavelet or a single 1D Julia array, which is used for all source locations. weights : A cell array with one cell per source location containing a 2D/3D Julia array with the spatially varying source weights or a single 1D Julia array, which is used for all source locations. Access fields: # Access weights of i-th source location ex_src.weights[i] # Access wavelet of i-th source location ex_src.wavelet[i]","title":"judiExtendedSource"},{"location":"data_structures/","text":"Data structures Physical Parameter Data structure for physical parameter array in JUDI. A PhysicalParameter inherits from julia AbstractVector Construction A PhysicalParameter can be constructed in various ways but always require the origin o and grid spacing d that cannot be infered from the array. p = PhysicalParameter(v::Array{vDT}, d, o) where v is an n-dimensional array and n=size(v). p = PhysicalParameter(n, d, o; vDT=Float32) Creates a zero PhysicalParameter. p = PhysicalParameter(v::Array{vDT}, A::PhysicalParameter) Creates a PhysicalParameter from the Array v with n, d, o from A . p = PhysicalParameter(v::Array{vDT, N}, n::Tuple, d::Tuple, o::Tuple) where v is a vector or nd-array that is reshaped into shape n . p = PhysicalParameter(v::vDT, n::Tuple, d::Tuple, o::Tuple) Creates a constant (single number) PhyicalParameter. Access fields: Model structure Data structure for velocity models in JUDI. Construction: Model requires the following input arguments: model = Model(n, d, o, m; nb=40, rho=1f0, epsilon=0f0, delta=0f0, theta=0f0, phi=0f0) Accessible fields include all of the above parameters p.n, p.d, p.o, p.data . Additionaly, arithmetic operation are all impemented such as addition, multiplication, broadcasting and indexing. Linear algebra operation are implemented as well but will return a standard Julia vector if the matrix used is external to JUDI. Parameters: n : Integer tuple with number of grid points in each dimension, e.g. n = (120, 100) (2D) or n = (120, 100, 80) (3D). The order of dimenions in all tuples is (x, z) for 2D and (x, y, z) for 3D . d : Real tuple with grid spacing in each dimension. o : Real tuple with coordinate origin (typically o = (0f0, 0f0) ). m : 2D or 3D array of the velocity model in squared slowness [s^2/km^2] . nb : Number of absorbing boundary points on each edge. Default is nb = 40 . rho : 2D or 3D array of the density in [g / cm^3] (default is 1) epsilon : Thomsen parameter epsilon for VTI/TTI modeling (default is 0) delta : Thomsen parameter delta for VTI/TTI modeling (default is 0) theta : Vertical tilt angle of TTI symmetry axis (default is 0) [rad] phi : Horizontal tilt angle of TTI symmetry axis (default is 0) [rad] Access fields: Accessible fields include all of the above parameters, which can be accessed as follows: # Access model model.m # Access number of grid points model.n Geometry structure JUDI's geometry structure contains the information of either the source or the receiver geometry. Construction: Construct an (in-core) geometry object for either a source or receiver set up: geometry = Geometry(xloc, yloc, zloc; dt=[], nt=[], t=[]) Parameters: xloc : Cell array, with one cell per source location. Each cell contains a 1D Julia array with the coordinates in the horizontal x direction. Coordinates are specified as distances in meters [m] relative to the model origin. yloc : Cell array for horizontal y coordinates. For 2D, set each cell entry to 0f0 . zloc : Cell array for depth coordinates (z) at each source location. dt : Cell array with the time intervals at which the data was sampled (i.e. a shot record or source wavelet was sampled). Units in milliseconds [ms] . nt : Cell array with number of time samples. t : Cell array with the recording lengths in milliseconds [ms] . From the optional arguments, you have to pass (at least) two of dt , nt and t . The third value is automatically determined and set from the two other values. Access fields: Accessible fields include all of the above parameters, which can be accessed as follows: # Access cell arrays of x coordinates: geometry.xloc # Access x coordinates of the i-th source location geometry.xloc[i] # Access j-th receiver location (in x) of the i-th source location geometry.xloc[i][j] Info structure The info structure contains some basic dimensionality information that needs to be available to any type of linear operator: Construction: info = Info(n, nsrc, nt) Parameters : n : Total number of grid points in all dimensions. Given by prod(model.n) . nsrc : Number of source/shot locations in the seismic experiment. nt : Number of computational time steps. You can automatically obtain the number of computational time steps as follows: nt = get_computational_nt(src_geometry, rec_geometry, model) where src_geometry is a Geometry object with the source geometry, rec_geometry is a Geometry object with the receiver geometry and model is a Model structure. Options structure The options structure allows setting several modeling parameters. Construction: Choose all default options: opt = Options() List of all possible options: opt = Options( space_order:: Integer space_order:: Integer free_surface:: Bool limit_m:: Bool buffer_size:: Real save_data_to_disk:: Bool save_wavefield_to_disk:: Bool file_path:: String file_name:: String sum_padding:: Bool optimal_checkpointing:: Bool num_checkpoints:: Union{Integer, Nothing} checkpoints_maxmem:: Union{Real, Nothing} frequencies:: Array subsampling_factor:: Integer dft_subsampling_factor:: Integer isic:: Bool return_array:: Bool dt_comp:: Union{Real, Nothing} ) Parameters: space_order : Finite difference space order for wave equation (default is 8 , needs to be multiple of 4). free_surface : Set to true to enable a free surface boundary condition (default is false ). limit_m : For 3D modeling, limit modeling domain to area with receivers (default is false ). buffer_size : If limit_m=true , define buffer area on each side of modeling domain (in meters) save_data_to_disk : If true , saves shot records as separate SEG-Y files (default is false ). save_wavefield_to_disk : If wavefield is return value, save wavefield to disk as pickle file (default is false ). file_path : Path to directory where data is saved. file_name : Shot records will be saved as specified file name plus its source coordinates. sum_padding : When removing the padding area of the gradient, sum values into the most outer rows/columns (default is false ). Required to pass adjoint tests. optimal_checkpointing : Use optimal wavefield checkpointing (default is false ). num_checkpoints : Number of checkpoints. If not supplied, is set to log(num_timesteps) . checkpoints_maxmem : Maximum amount of memory that can be allocated for checkpoints (MB). frequencies : Provide a cell array (one cell per shot location), where each cell contains an array of frequencies. In this case, the RTM/FWI gradient is computed for the given set of frequencies using on-the-fly Fourier transforms (default is nothing , i.e. the gradient is computed in the time domain). subsampling_factor : Compute forward wavefield on a time axis that is reduced by a given factor (default is 1 ). dft_subsampling_factor : Compute on-the-fly DFTs on a time axis that is reduced by a given factor (default is 1 ). isic : Use linearized inverse scattering imaging condition for the Jacobian (default is false ). return_array : Return data from nonlinear/linear modeling as a plain Julia array instead of as a judiVector (default is false ). dt_comp : Overwrite automatically computed computational time step (default option) with this value.","title":"Data structures"},{"location":"data_structures/#data-structures","text":"","title":"Data structures"},{"location":"data_structures/#physical-parameter","text":"Data structure for physical parameter array in JUDI. A PhysicalParameter inherits from julia AbstractVector Construction A PhysicalParameter can be constructed in various ways but always require the origin o and grid spacing d that cannot be infered from the array. p = PhysicalParameter(v::Array{vDT}, d, o) where v is an n-dimensional array and n=size(v). p = PhysicalParameter(n, d, o; vDT=Float32) Creates a zero PhysicalParameter. p = PhysicalParameter(v::Array{vDT}, A::PhysicalParameter) Creates a PhysicalParameter from the Array v with n, d, o from A . p = PhysicalParameter(v::Array{vDT, N}, n::Tuple, d::Tuple, o::Tuple) where v is a vector or nd-array that is reshaped into shape n . p = PhysicalParameter(v::vDT, n::Tuple, d::Tuple, o::Tuple) Creates a constant (single number) PhyicalParameter. Access fields:","title":"Physical Parameter"},{"location":"data_structures/#model-structure","text":"Data structure for velocity models in JUDI. Construction: Model requires the following input arguments: model = Model(n, d, o, m; nb=40, rho=1f0, epsilon=0f0, delta=0f0, theta=0f0, phi=0f0) Accessible fields include all of the above parameters p.n, p.d, p.o, p.data . Additionaly, arithmetic operation are all impemented such as addition, multiplication, broadcasting and indexing. Linear algebra operation are implemented as well but will return a standard Julia vector if the matrix used is external to JUDI. Parameters: n : Integer tuple with number of grid points in each dimension, e.g. n = (120, 100) (2D) or n = (120, 100, 80) (3D). The order of dimenions in all tuples is (x, z) for 2D and (x, y, z) for 3D . d : Real tuple with grid spacing in each dimension. o : Real tuple with coordinate origin (typically o = (0f0, 0f0) ). m : 2D or 3D array of the velocity model in squared slowness [s^2/km^2] . nb : Number of absorbing boundary points on each edge. Default is nb = 40 . rho : 2D or 3D array of the density in [g / cm^3] (default is 1) epsilon : Thomsen parameter epsilon for VTI/TTI modeling (default is 0) delta : Thomsen parameter delta for VTI/TTI modeling (default is 0) theta : Vertical tilt angle of TTI symmetry axis (default is 0) [rad] phi : Horizontal tilt angle of TTI symmetry axis (default is 0) [rad] Access fields: Accessible fields include all of the above parameters, which can be accessed as follows: # Access model model.m # Access number of grid points model.n","title":"Model structure"},{"location":"data_structures/#geometry-structure","text":"JUDI's geometry structure contains the information of either the source or the receiver geometry. Construction: Construct an (in-core) geometry object for either a source or receiver set up: geometry = Geometry(xloc, yloc, zloc; dt=[], nt=[], t=[]) Parameters: xloc : Cell array, with one cell per source location. Each cell contains a 1D Julia array with the coordinates in the horizontal x direction. Coordinates are specified as distances in meters [m] relative to the model origin. yloc : Cell array for horizontal y coordinates. For 2D, set each cell entry to 0f0 . zloc : Cell array for depth coordinates (z) at each source location. dt : Cell array with the time intervals at which the data was sampled (i.e. a shot record or source wavelet was sampled). Units in milliseconds [ms] . nt : Cell array with number of time samples. t : Cell array with the recording lengths in milliseconds [ms] . From the optional arguments, you have to pass (at least) two of dt , nt and t . The third value is automatically determined and set from the two other values. Access fields: Accessible fields include all of the above parameters, which can be accessed as follows: # Access cell arrays of x coordinates: geometry.xloc # Access x coordinates of the i-th source location geometry.xloc[i] # Access j-th receiver location (in x) of the i-th source location geometry.xloc[i][j]","title":"Geometry structure"},{"location":"data_structures/#info-structure","text":"The info structure contains some basic dimensionality information that needs to be available to any type of linear operator: Construction: info = Info(n, nsrc, nt) Parameters : n : Total number of grid points in all dimensions. Given by prod(model.n) . nsrc : Number of source/shot locations in the seismic experiment. nt : Number of computational time steps. You can automatically obtain the number of computational time steps as follows: nt = get_computational_nt(src_geometry, rec_geometry, model) where src_geometry is a Geometry object with the source geometry, rec_geometry is a Geometry object with the receiver geometry and model is a Model structure.","title":"Info structure"},{"location":"data_structures/#options-structure","text":"The options structure allows setting several modeling parameters. Construction: Choose all default options: opt = Options() List of all possible options: opt = Options( space_order:: Integer space_order:: Integer free_surface:: Bool limit_m:: Bool buffer_size:: Real save_data_to_disk:: Bool save_wavefield_to_disk:: Bool file_path:: String file_name:: String sum_padding:: Bool optimal_checkpointing:: Bool num_checkpoints:: Union{Integer, Nothing} checkpoints_maxmem:: Union{Real, Nothing} frequencies:: Array subsampling_factor:: Integer dft_subsampling_factor:: Integer isic:: Bool return_array:: Bool dt_comp:: Union{Real, Nothing} ) Parameters: space_order : Finite difference space order for wave equation (default is 8 , needs to be multiple of 4). free_surface : Set to true to enable a free surface boundary condition (default is false ). limit_m : For 3D modeling, limit modeling domain to area with receivers (default is false ). buffer_size : If limit_m=true , define buffer area on each side of modeling domain (in meters) save_data_to_disk : If true , saves shot records as separate SEG-Y files (default is false ). save_wavefield_to_disk : If wavefield is return value, save wavefield to disk as pickle file (default is false ). file_path : Path to directory where data is saved. file_name : Shot records will be saved as specified file name plus its source coordinates. sum_padding : When removing the padding area of the gradient, sum values into the most outer rows/columns (default is false ). Required to pass adjoint tests. optimal_checkpointing : Use optimal wavefield checkpointing (default is false ). num_checkpoints : Number of checkpoints. If not supplied, is set to log(num_timesteps) . checkpoints_maxmem : Maximum amount of memory that can be allocated for checkpoints (MB). frequencies : Provide a cell array (one cell per shot location), where each cell contains an array of frequencies. In this case, the RTM/FWI gradient is computed for the given set of frequencies using on-the-fly Fourier transforms (default is nothing , i.e. the gradient is computed in the time domain). subsampling_factor : Compute forward wavefield on a time axis that is reduced by a given factor (default is 1 ). dft_subsampling_factor : Compute on-the-fly DFTs on a time axis that is reduced by a given factor (default is 1 ). isic : Use linearized inverse scattering imaging condition for the Jacobian (default is false ). return_array : Return data from nonlinear/linear modeling as a plain Julia array instead of as a judiVector (default is false ). dt_comp : Overwrite automatically computed computational time step (default option) with this value.","title":"Options structure"},{"location":"helper/","text":"Helper functions Ricker wavelet Create a 1D Ricker wavelet: wavelet = ricker_wavelet(tmax, dt, f0) Parameters: tmax : Modeling time in milliseconds [ms] . dt : Sampling interval in milliseconds (can be different from dt of shot data). f0 : Peak frequency in Kilohertz [kHz] . Compute CFL time stepping interval Calculate the time stepping interval based on the CFL condition dt = calculate_dt(n, d, o, v, rho) Parameters: n : Tuple with number of grid points. d : Tuple with grid spacing. o : Tuple with coordiante system origin. v : 2D/3D Julia array with velocity in [km/s] . rho : 2D/3D Julia array with density in [g/cm^3] . Compute number of computational time steps Estimate the number of computational time steps. Required for calculating the dimensions of the matrix-free linear modeling operators: nt = get_computational_nt(src_geometry, rec_geometry, model) or (for extended source modeling, where src_geometry is not available): nt = get_computational_nt(rec_geometry, model) Parameters: src_geometry : A JUDI Geometry object with the source geometry. rec_geometry : A JUDI Geometry object with the receiver geometry. model : A JUDI Model object containing the velocity model. Set up 3D acquisition grid Helper function to create a regular acquisition grid for a 3D survey. x_coord_full, y_coord_full, z_coord_full = setup_3D_grid(x_coord, y_coord, z_coord) Parameters: x_coord : 1D julia vector of length nx , where nx is the number of distinct source/receiver locations in x direction. y_coord : 1D julia vector of length ny , where ny is the number of distinct source/receiver locations in y direction. z_coord : Single scalar for depth of sources/receivers. Returns: x_coord_full : 1D julia vector of length nx * ny with source/receiver locations in x direction. y_coord_full : 1D julia vector of length nx * ny with source/receiver locations in y direction. z_coord_full : 1D julia vector of length nx * ny with source/receiver locations in z direction. Data interpolation Time interpolation for source/receiver data using splines. For modeling, the data is interpolated automatically onto the computational time axis, so generally, these functions are not needed for users. data_interp, geometry_out = time_resample(data, geometry_in, dt_out; order=2) or : data_interp = time_resample(data, geometry_out, dt_in; order=2) Parameters: data : 2D Julia array of source/receiver data. geometry_in : A JUDI Geometry object of the input data before interpolation. dt_out : Sampling interval of interpolated shot record in milliseconds [ms] . order : Order of splines for interpolation. or: data : 2D Julia array of source/receiver data. geometry_out : A JUDI Geometry object of the data after interpolation. dt_in : Sampling interval of input shot record in milliseconds [ms] . Generate and sample from frequency distribution Create a probability distribution with the shape of the source spectrum from which we can draw random frequencies. dist = generate_distribution(q; src_no=1) Parameters: q : Source vector of type judiVector from which to create the distribution. src_no : Source number for which to create the distribution (i.e. q[src_no] ). Returns: dist : probability distribution. We can draw random samples from dist by passing it values between 0 and 1: # Draw a single random frequency f = dist(rand(1)) # Draw 10 random frequencies f = dist(rand(10)) Alternatively, we can use the function: f = select_frequencies(dist; fmin=0f0, fmax=Inf, nf=1) to draw nf number of frequencies for a given distribution dist in the frequency range of fmin to fmax (both in kHz). Read data from out of core container In the case where a judiVector is out of core (points to a segy file) it is possible to convert it or part of it into an in core judiVecor with the get_data function. d_ic = get_data(d_ooc, inds) where inds is either a single index, a list of index or a range of index.","title":"Helper functions"},{"location":"helper/#helper-functions","text":"","title":"Helper functions"},{"location":"helper/#ricker-wavelet","text":"Create a 1D Ricker wavelet: wavelet = ricker_wavelet(tmax, dt, f0) Parameters: tmax : Modeling time in milliseconds [ms] . dt : Sampling interval in milliseconds (can be different from dt of shot data). f0 : Peak frequency in Kilohertz [kHz] .","title":"Ricker wavelet"},{"location":"helper/#compute-cfl-time-stepping-interval","text":"Calculate the time stepping interval based on the CFL condition dt = calculate_dt(n, d, o, v, rho) Parameters: n : Tuple with number of grid points. d : Tuple with grid spacing. o : Tuple with coordiante system origin. v : 2D/3D Julia array with velocity in [km/s] . rho : 2D/3D Julia array with density in [g/cm^3] .","title":"Compute CFL time stepping interval"},{"location":"helper/#compute-number-of-computational-time-steps","text":"Estimate the number of computational time steps. Required for calculating the dimensions of the matrix-free linear modeling operators: nt = get_computational_nt(src_geometry, rec_geometry, model) or (for extended source modeling, where src_geometry is not available): nt = get_computational_nt(rec_geometry, model) Parameters: src_geometry : A JUDI Geometry object with the source geometry. rec_geometry : A JUDI Geometry object with the receiver geometry. model : A JUDI Model object containing the velocity model.","title":"Compute number of computational time steps"},{"location":"helper/#set-up-3d-acquisition-grid","text":"Helper function to create a regular acquisition grid for a 3D survey. x_coord_full, y_coord_full, z_coord_full = setup_3D_grid(x_coord, y_coord, z_coord) Parameters: x_coord : 1D julia vector of length nx , where nx is the number of distinct source/receiver locations in x direction. y_coord : 1D julia vector of length ny , where ny is the number of distinct source/receiver locations in y direction. z_coord : Single scalar for depth of sources/receivers. Returns: x_coord_full : 1D julia vector of length nx * ny with source/receiver locations in x direction. y_coord_full : 1D julia vector of length nx * ny with source/receiver locations in y direction. z_coord_full : 1D julia vector of length nx * ny with source/receiver locations in z direction.","title":"Set up 3D acquisition grid"},{"location":"helper/#data-interpolation","text":"Time interpolation for source/receiver data using splines. For modeling, the data is interpolated automatically onto the computational time axis, so generally, these functions are not needed for users. data_interp, geometry_out = time_resample(data, geometry_in, dt_out; order=2) or : data_interp = time_resample(data, geometry_out, dt_in; order=2) Parameters: data : 2D Julia array of source/receiver data. geometry_in : A JUDI Geometry object of the input data before interpolation. dt_out : Sampling interval of interpolated shot record in milliseconds [ms] . order : Order of splines for interpolation. or: data : 2D Julia array of source/receiver data. geometry_out : A JUDI Geometry object of the data after interpolation. dt_in : Sampling interval of input shot record in milliseconds [ms] .","title":"Data interpolation"},{"location":"helper/#generate-and-sample-from-frequency-distribution","text":"Create a probability distribution with the shape of the source spectrum from which we can draw random frequencies. dist = generate_distribution(q; src_no=1) Parameters: q : Source vector of type judiVector from which to create the distribution. src_no : Source number for which to create the distribution (i.e. q[src_no] ). Returns: dist : probability distribution. We can draw random samples from dist by passing it values between 0 and 1: # Draw a single random frequency f = dist(rand(1)) # Draw 10 random frequencies f = dist(rand(10)) Alternatively, we can use the function: f = select_frequencies(dist; fmin=0f0, fmax=Inf, nf=1) to draw nf number of frequencies for a given distribution dist in the frequency range of fmin to fmax (both in kHz).","title":"Generate and sample from frequency distribution"},{"location":"helper/#read-data-from-out-of-core-container","text":"In the case where a judiVector is out of core (points to a segy file) it is possible to convert it or part of it into an in core judiVecor with the get_data function. d_ic = get_data(d_ooc, inds) where inds is either a single index, a list of index or a range of index.","title":"Read data from out of core container"},{"location":"io/","text":"Input/Output For reading and writing SEG-Y data, JUDI uses the SegyIO.jl package. JUDI supports reading SEG-Y from disk into memory, as well as working with out-of-core (OOC) data containers. In the latter case, judiVectors contain look-up tables that allow accessing the underlying data in constant time. Reading SEG-Y files into memory To read a single SEG-Y file into memory, use the segy_read function: using SegyIO block = segy_read(\"data.segy\") From a SegyIO data block, you can create an in-core judiVector , as well as a Geometry object for the source: # judiVector for observed data d_obs = judiVector(block; segy_depth_key=\"RecGroupElevation\") # Source geometry src_geometry = Geometry(block; key=\"source\", segy_depth_key=\"SourceDepth\") The optional keyword segy_depth_key specifies which SEG-Y header stores the depth coordinate. After reading a block , you can check block.traceheaders to see which trace headers are set and where to find the depth coordinates for sources or receivers. The d_obs vector constains the receiver geometry in d_obs.geometry , so there is no need to set up a separate geometry object manually. However, in principle we can set up a receiver Geometry object as follows: rec_geometry = Geometry(block; key=\"receiver\", segy_depth_key=\"RecGroupElevation\") Writing SEG-Y files To write a judiVector as a SEG-Y file, we need a judiVector containing the receiver data and geometry, as well as a judiVector with the source coordinates. From the judiVectors , we first create a SegyIO block: block = judiVector_to_SeisBlock(d_obs, q) where d_obs and q are judiVectors for receiver and source data respectively. To save only the source q , we can do block = src_to_SeisBlock(q) Next, we can write a SEG-Y file from a SegyIO block : segy_write(\"new_file.segy\", block) # writes a SEG-Y file called new_file.segy Reading out-of-core SEG-Y files For SEG-Y files that do not fit into memory, JUDI provides the possibility to work with OOC data containers. First, SegyIO scans also available files and then creates a lookup table, including a summary of the most important SEG-Y header values. See SegyIO's documentation for more information. First we provide the path to the directory that we want to scan, as well as a string that appears in all the files we want to scan. For example, here we want to scan all files that contain the string \"bp_observed_data\" . The third argument is a list of SEG-Y headers for which we create a summary. For creating OOC judiVectors , always include the \"GroupX\" , \"GroupY\" and \"dt\" keyworkds, as well as the keywords that carry the source and receiver depth coordinates: # Specify direcotry to scan path_to_data = \"/home/username/data_directory/\" # Scan files in given directory and create OOC data container container = segy_scan(path_to_data, \"bp_observed_data\", [\"GroupX\", \"GroupY\", \"RecGroupElevation\", \"SourceDepth\", \"dt\"]) Depending of the number and size of the underlying files, this process can take multiple hours, but it only has to be executed once! Furthermore, parallel scanning is supported as well. Once we have scanned all files in the directory, we can create an OOC judiVector and source Geometry object as follows: # Create OOC judiVector d_obs = judiVector(container; segy_depth_key=\"RecGroupElevation\") # Create OOC source geometry object src_geometry = Geometry(container; key=\"source\", segy_depth_key=\"SourceDepth\") Reading and writing velocity models JUDI does not require velocity models to be read or saved in any specific format. Any file format that allows reading the velocity model as a two or three-dimensional Julia array will work. In our examples, we often use the JLD or HDF5 packages to read/write velocity models and the corresponing meta data (i.e. grid spacings and origins). If your model is a SEG-Y file, use the segy_read function from SegyIO as shown above. Create an example model to write and read: n = (120, 100) d = (10.0, 10.0) o = (0.0, 0.0) v = ones(Float32, n) .* 1.5f0 m = 1f0 ./ v.^2 Write a model as a .jld file: using JLD save(\"my_model.jld\", \"n\", n, \"d\", d, \"o\", o, \"m\", m) Read a model from a .jld file: # Returns a Julia dictionary M = load(\"my_model.jld\") n = M[\"n\"] d = M[\"d\"] o = M[\"o\"] m = M[\"m\"] # Set up a Model object model = Model(n, d, o, m)","title":"Input/Output"},{"location":"io/#inputoutput","text":"For reading and writing SEG-Y data, JUDI uses the SegyIO.jl package. JUDI supports reading SEG-Y from disk into memory, as well as working with out-of-core (OOC) data containers. In the latter case, judiVectors contain look-up tables that allow accessing the underlying data in constant time.","title":"Input/Output"},{"location":"io/#reading-seg-y-files-into-memory","text":"To read a single SEG-Y file into memory, use the segy_read function: using SegyIO block = segy_read(\"data.segy\") From a SegyIO data block, you can create an in-core judiVector , as well as a Geometry object for the source: # judiVector for observed data d_obs = judiVector(block; segy_depth_key=\"RecGroupElevation\") # Source geometry src_geometry = Geometry(block; key=\"source\", segy_depth_key=\"SourceDepth\") The optional keyword segy_depth_key specifies which SEG-Y header stores the depth coordinate. After reading a block , you can check block.traceheaders to see which trace headers are set and where to find the depth coordinates for sources or receivers. The d_obs vector constains the receiver geometry in d_obs.geometry , so there is no need to set up a separate geometry object manually. However, in principle we can set up a receiver Geometry object as follows: rec_geometry = Geometry(block; key=\"receiver\", segy_depth_key=\"RecGroupElevation\")","title":"Reading SEG-Y files into memory"},{"location":"io/#writing-seg-y-files","text":"To write a judiVector as a SEG-Y file, we need a judiVector containing the receiver data and geometry, as well as a judiVector with the source coordinates. From the judiVectors , we first create a SegyIO block: block = judiVector_to_SeisBlock(d_obs, q) where d_obs and q are judiVectors for receiver and source data respectively. To save only the source q , we can do block = src_to_SeisBlock(q) Next, we can write a SEG-Y file from a SegyIO block : segy_write(\"new_file.segy\", block) # writes a SEG-Y file called new_file.segy","title":"Writing SEG-Y files"},{"location":"io/#reading-out-of-core-seg-y-files","text":"For SEG-Y files that do not fit into memory, JUDI provides the possibility to work with OOC data containers. First, SegyIO scans also available files and then creates a lookup table, including a summary of the most important SEG-Y header values. See SegyIO's documentation for more information. First we provide the path to the directory that we want to scan, as well as a string that appears in all the files we want to scan. For example, here we want to scan all files that contain the string \"bp_observed_data\" . The third argument is a list of SEG-Y headers for which we create a summary. For creating OOC judiVectors , always include the \"GroupX\" , \"GroupY\" and \"dt\" keyworkds, as well as the keywords that carry the source and receiver depth coordinates: # Specify direcotry to scan path_to_data = \"/home/username/data_directory/\" # Scan files in given directory and create OOC data container container = segy_scan(path_to_data, \"bp_observed_data\", [\"GroupX\", \"GroupY\", \"RecGroupElevation\", \"SourceDepth\", \"dt\"]) Depending of the number and size of the underlying files, this process can take multiple hours, but it only has to be executed once! Furthermore, parallel scanning is supported as well. Once we have scanned all files in the directory, we can create an OOC judiVector and source Geometry object as follows: # Create OOC judiVector d_obs = judiVector(container; segy_depth_key=\"RecGroupElevation\") # Create OOC source geometry object src_geometry = Geometry(container; key=\"source\", segy_depth_key=\"SourceDepth\")","title":"Reading out-of-core SEG-Y files"},{"location":"io/#reading-and-writing-velocity-models","text":"JUDI does not require velocity models to be read or saved in any specific format. Any file format that allows reading the velocity model as a two or three-dimensional Julia array will work. In our examples, we often use the JLD or HDF5 packages to read/write velocity models and the corresponing meta data (i.e. grid spacings and origins). If your model is a SEG-Y file, use the segy_read function from SegyIO as shown above. Create an example model to write and read: n = (120, 100) d = (10.0, 10.0) o = (0.0, 0.0) v = ones(Float32, n) .* 1.5f0 m = 1f0 ./ v.^2 Write a model as a .jld file: using JLD save(\"my_model.jld\", \"n\", n, \"d\", d, \"o\", o, \"m\", m) Read a model from a .jld file: # Returns a Julia dictionary M = load(\"my_model.jld\") n = M[\"n\"] d = M[\"d\"] o = M[\"o\"] m = M[\"m\"] # Set up a Model object model = Model(n, d, o, m)","title":"Reading and writing velocity models"},{"location":"linear_operators/","text":"Linear Operators judiModeling Seismic modeling operator for solving a wave equation for a given right-hand-side. Construction: Construct a modeling operator without source/receiver projections: F = judiModeling(info, model; options=opt) Construct a modeling operator with source/receiver projections: F = judiModeling(info, model, src_geometry, rec_geometry) Construct a modeling operator from an existing operator without geometries and projection operators: F = Pr*F*Ps' where Ps and Pr are source/receiver projection operators of type judiProjection . Construct a modeling operator for extended source modeling : F = Pr*F*Pw' where Pw is a judiLRWF (low-rank-wavefield) projection operator. Parameters: info : A Info structure. model : A Model structure containg the velocity model and grid specifications. src_geometry : An object of type Geometry containing the source geometry. rec_geometry : An object of type Geometry containing the receiver geometry. opt : An object of type Options , specifying additional modeling parameters. Accessible fields: # Info structure F.info # Model structure F.model # Source geometry (if available) F.srcGeometry # Receiver geometry (if available) F.recGeometry # Options structure F.options Usage: # Forward modeling (F w/ geometries) d_obs = F*q # Adjoint modeling (F w/ geometries) q_ad = F'*d_obs # Forward modeling (F w/o geometries) d_obs = Pr*F*Ps'*q # Adjoint modelng (F w/o geometries) q_ad = Ps*F'*Pr'*d_obs # Extended source modeling (F w/o geometries) d_obs = Pr*F*Pw'*w # Adjoint extended source modeling (F w/o geometries) w_ad = Pw*F'*Pr'*d_obs # Forward modeling and return full wavefield (F w/o geometries) u = F*Ps'*q # Adjoint modelnig and return wavefield (F w/o geometries) v = F'*Pr'*d_obs # Forward modeling with full wavefield as source (F w/o geometries) d_obs = Pr*F*u # Adjoint modeling with full wavefield as source (F w/o geometries) q_ad = Ps*F*v judiJacobian Jacobian of a non-linear forward modeling operator. Corresponds to linearized Born modeling (forward mode) and reverse-time migration (adjoint mode). Construction: A judiJacobian operator can be create from an exisiting forward modeling operator and a source vector: J = judiJacobian(F, q) # F w/ geometries J = judiJacobian(Pr*F*Ps', q) # F w/o geometries where Ps and Pr are source/receiver projection operators of type judiProjection . A Jacobian can also be created for an extended source modeling operator: J = judiJacobian(Pr*F*Pw', w) where Pw is a judiLRWF operator and w is a judiWeights vector (or 2D/3D Julia array). Accessible fields:: # Info structure J.info # Model structure J.model # Source geometry (if available) J.srcGeometry # Receiver geometry J.recGeometry # Source wavelet J.wavelet # Weights (extended source modeling only) J.weights # Options structure J.options Usage: # Linearized modeilng d_lin = J*dm # RTM rtm = J'*d_lin # Matrix-free normal operator H = J'*J judiProjection Abstract linear operator for source/receiver projections. A (transposed) judiProjection operator symbolically injects the data with which it is multiplied during modeling. If multiplied with a forward modeling operator, it samples the wavefield at the specified source/receiver locations. Construction: P = judiProjection(info, geometry) Parameters: info : A JUDI Info structure. geometry : A JUDI Geometry structure containing either the source or receiver acquisition set up.s Accessible fields: # Info structure P.info # Source/receiver geometry P.geometry Usage: # Multiply with judiVector to create a judiRHS rhs1 = Pr'*d_obs rhs2 = Ps'*q # Sample wavefield at source/receiver location during modeling d_obs = Pr*F*Ps'*q q_ad = Ps*F*Pr'*d_obs judiLRWF Abstract linear operator for sampling a seismic wavefield as a sum over all time steps, weighted by a time-varying wavelet. Its transpose injects a time-varying wavelet at every grid point in the model. Construction: P = judiLRWF(info, wavelet) Parameters: info : A JUDI Info structure. wavelet : A cell array with one cell per source location, where each cell contains a 1D Julia array of the source wavelet or a single Julia array which will be used for all source location. Accessible fields: # Info structure P.info # Wavelet of i-th source location P.wavelet[i] Usage: # Multiply with a judiWeight vector to create a judiExtendedSource ex_src = Pw'*w # Sample wavefield as a sum over time, weighted by the source u_ex = Pw*F'*Pr'*d_obs","title":"Linear operators"},{"location":"linear_operators/#linear-operators","text":"","title":"Linear Operators"},{"location":"linear_operators/#judimodeling","text":"Seismic modeling operator for solving a wave equation for a given right-hand-side. Construction: Construct a modeling operator without source/receiver projections: F = judiModeling(info, model; options=opt) Construct a modeling operator with source/receiver projections: F = judiModeling(info, model, src_geometry, rec_geometry) Construct a modeling operator from an existing operator without geometries and projection operators: F = Pr*F*Ps' where Ps and Pr are source/receiver projection operators of type judiProjection . Construct a modeling operator for extended source modeling : F = Pr*F*Pw' where Pw is a judiLRWF (low-rank-wavefield) projection operator. Parameters: info : A Info structure. model : A Model structure containg the velocity model and grid specifications. src_geometry : An object of type Geometry containing the source geometry. rec_geometry : An object of type Geometry containing the receiver geometry. opt : An object of type Options , specifying additional modeling parameters. Accessible fields: # Info structure F.info # Model structure F.model # Source geometry (if available) F.srcGeometry # Receiver geometry (if available) F.recGeometry # Options structure F.options Usage: # Forward modeling (F w/ geometries) d_obs = F*q # Adjoint modeling (F w/ geometries) q_ad = F'*d_obs # Forward modeling (F w/o geometries) d_obs = Pr*F*Ps'*q # Adjoint modelng (F w/o geometries) q_ad = Ps*F'*Pr'*d_obs # Extended source modeling (F w/o geometries) d_obs = Pr*F*Pw'*w # Adjoint extended source modeling (F w/o geometries) w_ad = Pw*F'*Pr'*d_obs # Forward modeling and return full wavefield (F w/o geometries) u = F*Ps'*q # Adjoint modelnig and return wavefield (F w/o geometries) v = F'*Pr'*d_obs # Forward modeling with full wavefield as source (F w/o geometries) d_obs = Pr*F*u # Adjoint modeling with full wavefield as source (F w/o geometries) q_ad = Ps*F*v","title":"judiModeling"},{"location":"linear_operators/#judijacobian","text":"Jacobian of a non-linear forward modeling operator. Corresponds to linearized Born modeling (forward mode) and reverse-time migration (adjoint mode). Construction: A judiJacobian operator can be create from an exisiting forward modeling operator and a source vector: J = judiJacobian(F, q) # F w/ geometries J = judiJacobian(Pr*F*Ps', q) # F w/o geometries where Ps and Pr are source/receiver projection operators of type judiProjection . A Jacobian can also be created for an extended source modeling operator: J = judiJacobian(Pr*F*Pw', w) where Pw is a judiLRWF operator and w is a judiWeights vector (or 2D/3D Julia array). Accessible fields:: # Info structure J.info # Model structure J.model # Source geometry (if available) J.srcGeometry # Receiver geometry J.recGeometry # Source wavelet J.wavelet # Weights (extended source modeling only) J.weights # Options structure J.options Usage: # Linearized modeilng d_lin = J*dm # RTM rtm = J'*d_lin # Matrix-free normal operator H = J'*J","title":"judiJacobian"},{"location":"linear_operators/#judiprojection","text":"Abstract linear operator for source/receiver projections. A (transposed) judiProjection operator symbolically injects the data with which it is multiplied during modeling. If multiplied with a forward modeling operator, it samples the wavefield at the specified source/receiver locations. Construction: P = judiProjection(info, geometry) Parameters: info : A JUDI Info structure. geometry : A JUDI Geometry structure containing either the source or receiver acquisition set up.s Accessible fields: # Info structure P.info # Source/receiver geometry P.geometry Usage: # Multiply with judiVector to create a judiRHS rhs1 = Pr'*d_obs rhs2 = Ps'*q # Sample wavefield at source/receiver location during modeling d_obs = Pr*F*Ps'*q q_ad = Ps*F*Pr'*d_obs","title":"judiProjection"},{"location":"linear_operators/#judilrwf","text":"Abstract linear operator for sampling a seismic wavefield as a sum over all time steps, weighted by a time-varying wavelet. Its transpose injects a time-varying wavelet at every grid point in the model. Construction: P = judiLRWF(info, wavelet) Parameters: info : A JUDI Info structure. wavelet : A cell array with one cell per source location, where each cell contains a 1D Julia array of the source wavelet or a single Julia array which will be used for all source location. Accessible fields: # Info structure P.info # Wavelet of i-th source location P.wavelet[i] Usage: # Multiply with a judiWeight vector to create a judiExtendedSource ex_src = Pw'*w # Sample wavefield as a sum over time, weighted by the source u_ex = Pw*F'*Pr'*d_obs","title":"judiLRWF"},{"location":"preconditioners/","text":"Seismic preconditioners Model topmute Create a linear operator for a 2D model topmute, i.e. for muting the water column: Mr = judiTopmute(n, mute_start, length) Parameters: n : Tuple of model dimensions (e.g. from model.n ) mute_start : First grid point in z-direction from where on to mute the image. Can be a single integer or a vector of length nx , where nx is the number of grid points in x direction. length : The mask is created with a linear taper from 0 to 1. The width of the taper is length . Usage: # Forward m_mute = Mr*vec(m) # Adjoint m_mute = Mr'*vec(m) As Mr is self adjoint, Mr is equal to Mr' . Model depth scaling Create a 2D model depth scaling: Mr = judiDepthScaling(model) Parameters: model : JUDI Model structure. Data topmute (experimental) Create a data topmute for a 2D marine shot record (i.e. for a shot record with an end-on-spread acquisition geometry). Ml = judiMarineTopmute2D(muteStart, geometry; flipmask=false) Parameters: muteStart : Vertical index of the apex of the shot record (i.e. the earliest point from where to mute). geometry : A JUDI Geometry object with the receiver geometry. flipmask : If the source is on the left side, set to false (default). If the source is on the right side, set to true .","title":"Preconditioners"},{"location":"preconditioners/#seismic-preconditioners","text":"","title":"Seismic preconditioners"},{"location":"preconditioners/#model-topmute","text":"Create a linear operator for a 2D model topmute, i.e. for muting the water column: Mr = judiTopmute(n, mute_start, length) Parameters: n : Tuple of model dimensions (e.g. from model.n ) mute_start : First grid point in z-direction from where on to mute the image. Can be a single integer or a vector of length nx , where nx is the number of grid points in x direction. length : The mask is created with a linear taper from 0 to 1. The width of the taper is length . Usage: # Forward m_mute = Mr*vec(m) # Adjoint m_mute = Mr'*vec(m) As Mr is self adjoint, Mr is equal to Mr' .","title":"Model topmute"},{"location":"preconditioners/#model-depth-scaling","text":"Create a 2D model depth scaling: Mr = judiDepthScaling(model) Parameters: model : JUDI Model structure.","title":"Model depth scaling"},{"location":"preconditioners/#data-topmute-experimental","text":"Create a data topmute for a 2D marine shot record (i.e. for a shot record with an end-on-spread acquisition geometry). Ml = judiMarineTopmute2D(muteStart, geometry; flipmask=false) Parameters: muteStart : Vertical index of the apex of the shot record (i.e. the earliest point from where to mute). geometry : A JUDI Geometry object with the receiver geometry. flipmask : If the source is on the left side, set to false (default). If the source is on the right side, set to true .","title":"Data topmute (experimental)"},{"location":"pysource/","text":"pysource package Submodules FD_utils module FD_utils.R_mat(model) Rotation matrix according to tilt and asymut. Parameters model ( Model ) \u2013 Model structure FD_utils.divs(func, so_fact=1, side=- 1) GrDivergenceadient shifted by half a grid point, only to be used in combination with grads. FD_utils.grads(func, so_fact=1, side=1) Gradient shifted by half a grid point, only to be used in combination with divs. FD_utils.laplacian(v, irho) Laplacian with density div( 1/rho grad) (u) FD_utils.sa_tti(u, v, model) Tensor factorized SSA TTI wave equation spatial derivatives. Parameters u ( TimeFunction ) \u2013 first TTI field v ( TimeFunction ) \u2013 second TTI field model ( Model ) \u2013 Model structure FD_utils.thomsen_mat(model) Diagonal Matrices with Thomsen parameters for vectorial temporaries computation. Parameters model ( Model ) \u2013 Model structure checkpoint module class checkpoint.CheckpointOperator(op, **kwargs) Devito\u2019s concrete implementation of the ABC pyrevolve.Operator. This class wraps devito.Operator so it conforms to the pyRevolve API. pyRevolve will call apply with arguments t_start and t_end. Devito calls these arguments t_s and t_e so the following dict is used to perform the translations between different names. Parameters op ( Operator ) \u2013 devito.Operator object that this object will wrap. args ( dict ) \u2013 If devito.Operator.apply() expects any arguments, they can be provided here to be cached. Any calls to CheckpointOperator.apply() will automatically include these cached arguments in the call to the underlying devito.Operator.apply(). apply(t_start, t_end) If the devito operator requires some extra arguments in the call to apply they can be stored in the args property of this object so pyRevolve calls pyRevolve.Operator.apply() without caring about these extra arguments while this method passes them on correctly to devito.Operator t_arg_names( = {'t_end': 'time_M', 't_start': 'time_m' ) class checkpoint.DevitoCheckpoint(objects) Devito\u2019s concrete implementation of the Checkpoint abstract base class provided by pyRevolve. Holds a list of symbol objects that hold data. property dtype() data type get_data(timestep) returns the data (wavefield) for the time-step timestep get_data_location(timestep) returns the data (wavefield) for the time-step timestep load() NotImplementedError save() NotImplementedError property size() The memory consumption of the data contained in a checkpoint. checkpoint.get_symbol_data(symbol, timestep) Return the symbol corresponding to the data at time-step timestep geom_utils module geom_utils.src_rec(model, u, src_coords=None, rec_coords=None, wavelet=None, fw=True, nt=None) Generates the source injection and receiver interpolation. This function is fully abstracted and does not care whether this is a forward or adjoint wave-equation. The source is the source term of the equation The receiver is the measurment term Therefore, for the adjoint, this function has to be called as: src_rec(model, v, src_coords=rec_coords, \u2026) because the data is the sources Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or tuple ) \u2013 Wavefield to inject into and read from src_coords ( Array ) \u2013 Physical coordinates of the sources rec_coords ( Array ) \u2013 Physical coordinates of the receivers wavelet ( Array ) \u2013 Data for the source fw=True \u2013 Whether the direction is forward or backward in time nt ( int ) \u2013 Number of time steps interface module interface.J_adjoint(model, src_coords, wavelet, rec_coords, recin, space_order=8, checkpointing=False, n_checkpoints=None, t_sub=1, maxmem=None, freq_list=[], dft_sub=None, isic=False, ws=None) Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Supports three modes: * Checkpinting * Frequency compression (on-the-fly DFT) * Standard zero lag cross correlation over time Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) recin ( Array ) \u2013 Receiver data space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 checkpointing ( Bool ) \u2013 Whether or not to use checkpointing n_checkpoints ( Int ) \u2013 Number of checkpoints for checkpointing maxmem ( Float ) \u2013 Maximum memory to use for checkpointing freq_list ( List ) \u2013 List of frequencies for on-the-fly DFT dft_sub ( Int ) \u2013 Subsampling factor for on-the-fly DFT isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition ws ( Array ) \u2013 Extended source spatial distribution Returns Adjoint jacobian on the input data (gradient) Return type Array interface.J_adjoint_checkpointing(model, src_coords, wavelet, rec_coords, recin, space_order=8, is_residual=False, n_checkpoints=None, born_fwd=False, maxmem=None, return_obj=False, isic=False, ws=None, t_sub=1, nlind=False) Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with Checkpointing. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) recin ( Array ) \u2013 Receiver data space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 checkpointing ( Bool ) \u2013 Whether or not to use checkpointing n_checkpoints ( Int ) \u2013 Number of checkpoints for checkpointing maxmem ( Float ) \u2013 Maximum memory to use for checkpointing isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition ws ( Array ) \u2013 Extended source spatial distribution is_residual ( Bool ) \u2013 Whether to treat the input as the residual or as the observed data born_fwd ( Bool ) \u2013 Whether to use the forward or linearized forward modeling operator nlind ( Bool ) \u2013 Whether to remove the non linear data from the input data. This option is only available in combination with born_fwd Returns Adjoint jacobian on the input data (gradient) Return type Array interface.J_adjoint_freq(model, src_coords, wavelet, rec_coords, recin, space_order=8, freq_list=[], is_residual=False, return_obj=False, nlind=False, dft_sub=None, isic=False, ws=None, t_sub=1, born_fwd=False) Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with Frequency compression (on-the-fly DFT). Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) recin ( Array ) \u2013 Receiver data space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 freq_list ( List ) \u2013 List of frequencies for on-the-fly DFT dft_sub ( Int ) \u2013 Subsampling factor for on-the-fly DFT isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition ws ( Array ) \u2013 Extended source spatial distribution is_residual ( Bool ) \u2013 Whether to treat the input as the residual or as the observed data born_fwd ( Bool ) \u2013 Whether to use the forward or linearized forward modeling operator nlind ( Bool ) \u2013 Whether to remove the non linear data from the input data. This option is only available in combination with born_fwd Returns Adjoint jacobian on the input data (gradient) Return type Array interface.J_adjoint_standard(model, src_coords, wavelet, rec_coords, recin, space_order=8, is_residual=False, return_obj=False, born_fwd=False, isic=False, ws=None, t_sub=1, nlind=False) Adjoint Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with standard zero lag cross correlation over time. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) recin ( Array ) \u2013 Receiver data space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition ws ( Array ) \u2013 Extended source spatial distribution is_residual ( Bool ) \u2013 Whether to treat the input as the residual or as the observed data born_fwd ( Bool ) \u2013 Whether to use the forward or linearized forward modeling operator nlind ( Bool ) \u2013 Whether to remove the non linear data from the input data. This option is only available in combination with born_fwd Returns Adjoint jacobian on the input data (gradient) Return type Array interface.adjoint_no_rec(model, rec_coords, data, space_order=8) Adjoint/backward modeling of a shot record (receivers as source) without source sampling F^T*Pr^T*d_obs. Parameters model ( Model ) \u2013 Physical model rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) data ( Array ) \u2013 Shot gather space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Adjoint wavefield Return type Array interface.adjoint_rec(model, src_coords, rec_coords, data, space_order=8) Adjoint/backward modeling of a shot record (receivers as source) Ps*F^T*Pr^T*d. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) data ( Array ) \u2013 Shot gather space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record (adjoint wavefield at source position(s)) Return type Array interface.adjoint_w(model, rec_coords, data, wavelet, space_order=8) Adjoint/backward modeling of a shot record (receivers as source) for an extended source setup Pw*F^T*Pr^T*d_obs. Parameters model ( Model ) \u2013 Physical model rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) data ( Array ) \u2013 Shot gather wavelet ( Array ) \u2013 Time signature of the forward source for stacking along time space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns spatial distribution Return type Array interface.adjoint_wf_src(model, u, src_coords, space_order=8) Adjoint/backward modeling of a full wavefield (full wavefield as adjoint source) Ps*F^T*u. Parameters model ( Model ) \u2013 Physical model u ( Array or TimeFunction ) \u2013 Time-space dependent source src_coords ( Array ) \u2013 Source coordinates space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record (sampled at source position(s)) Return type Array interface.adjoint_wf_src_norec(model, u, space_order=8) Adjoint/backward modeling of a full wavefield (full wavefield as adjoint source) F^T*u. Parameters model ( Model ) \u2013 Physical model u ( Array or TimeFunction ) \u2013 Time-space dependent source space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Adjoint wavefield Return type Array interface.born_rec(model, src_coords, wavelet, rec_coords, space_order=8, isic=False) Linearized (Born) modeling of a point source for a model perturbation (square slowness) dm. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition Returns Shot record Return type Array interface.born_rec_w(model, weight, wavelet, rec_coords, space_order=8, isic=False) Linearized (Born) modeling of an extended source for a model perturbation (square slowness) dm with an extended source Parameters model ( Model ) \u2013 Physical model weight ( Array ) \u2013 Spatial distriubtion of the extended source wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition Returns Shot record Return type Array interface.forward_no_rec(model, src_coords, wavelet, space_order=8) Forward modeling of a point source without receiver. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Wavefield Return type Array interface.forward_rec(model, src_coords, wavelet, rec_coords, space_order=8) Forward modeling of a point source with receivers Pr*F*Ps^T*q. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record Return type Array interface.forward_rec_w(model, weight, wavelet, rec_coords, space_order=8) Forward modeling of an extended source with receivers Pr*F*Pw^T*w Parameters model ( Model ) \u2013 Physical model weights ( Array ) \u2013 Spatial distribution of the extended source. wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record Return type Array interface.forward_rec_wf(model, src_coords, wavelet, rec_coords, t_sub=1, space_order=8) Forward modeling of a point source Pr*F*Ps^T*q and return wavefield. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Array \u2013 Shot record TimeFunction \u2013 Wavefield interface.forward_wf_src(model, u, rec_coords, space_order=8) Forward modeling of a full wavefield source Pr*F*u. Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or Array ) \u2013 Time-space dependent wavefield rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record Return type Array interface.forward_wf_src_norec(model, u, space_order=8) Forward modeling of a full wavefield source without receiver F*u. Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or Array ) \u2013 Time-space dependent wavefield space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Wavefield Return type Array interface.grad_fwi(model, recin, rec_coords, u, space_order=8) FWI gradient, i.e adjoint Jacobian on a data residual. Parameters model ( Model ) \u2013 Physical model recin ( Array ) \u2013 Data residual rec_coords ( Array ) \u2013 Receivers coordinates u ( TimeFunction ) \u2013 Forward wavefield space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns FWI gradient Return type Array interface.wri_func(model, src_coords, wavelet, rec_coords, recin, yin, space_order=8, isic=False, ws=None, t_sub=1, grad='m', grad_corr=False, alpha_op=False, w_fun=None, eps=0, freq_list=[], wfilt=None) Time domain wavefield reconstruction inversion wrapper kernels module kernels.acoustic_kernel(model, u, fw=True, q=None) Acoustic wave equation time stepper Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or tuple ) \u2013 wavefield (tuple if TTI) fw ( Bool ) \u2013 Whether forward or backward in time propagation q ( TimeFunction or Expr ) \u2013 Full time-space source kernels.tti_kernel(model, u1, u2, fw=True, q=None) TTI wave equation (one from my paper) time stepper Parameters model ( Model ) \u2013 Physical model u1 ( TimeFunction ) \u2013 First component (pseudo-P) of the wavefield u2 ( TimeFunction ) \u2013 First component (pseudo-P) of the wavefield fw ( Bool ) \u2013 Whether forward or backward in time propagation q ( TimeFunction or Expr ) \u2013 Full time-space source as a tuple (one value for each component) kernels.wave_kernel(model, u, fw=True, q=None) Pde kernel corresponding the the model for the input wavefield Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or tuple ) \u2013 wavefield (tuple if TTI) fw ( Bool ) \u2013 Whether forward or backward in time propagation q ( TimeFunction or Expr ) \u2013 Full time-space source models module class models.Model(origin, spacing, shape, m, space_order=2, nbl=40, dtype= , epsilon=None, delta=None, theta=None, phi=None, rho=1, dm=None, fs=False, **kwargs) The physical model used in seismic inversion processes. Parameters origin ( tuple of floats ) \u2013 Origin of the model in m as a tuple in (x,y,z) order. spacing ( tuple of floats ) \u2013 Grid size in m as a Tuple in (x,y,z) order. shape ( tuple of int ) \u2013 Number of grid points size in (x,y,z) order. space_order ( int ) \u2013 Order of the spatial stencil discretisation. m ( array_like or float ) \u2013 Squared slownes in s^2/km^2 nbl ( int , optional ) \u2013 The number of absorbin layers for boundary damping. dtype ( np.float32 or np.float64 ) \u2013 Defaults to 32. epsilon ( array_like or float , optional ) \u2013 Thomsen epsilon parameter (0<epsilon<1). delta ( array_like or float ) \u2013 Thomsen delta parameter (0<delta<1), delta<epsilon. theta ( array_like or float ) \u2013 Tilt angle in radian. phi ( array_like or float ) \u2013 Asymuth angle in radian. dt ( Float ) \u2013 User provided computational time-step property critical_dt() Critical computational time step value from the CFL condition. property dm() Model perturbation for linearized modeling property dt() User provided dt property is_tti() Whether the model is TTI or isotopic property m() Function holding the squared slowness in s^2/km^2. property space_order() Spatial discretization order property spacing_map() Map between spacing symbols and their values for each SpaceDimension. property vp() Symbolic representation of the velocity vp = sqrt(1 / m) propagators module propagators.adjoint(model, y, src_coords, rcv_coords, space_order=8, q=0, dft_sub=None, save=False, ws=None, norm_v=False, w_fun=None, freq_list=None) Low level propagator, to be used through interface.py Compute adjoint wavefield v = adjoint(F(m))*y and related quantities (||v||_w, v(xsrc)) propagators.born(model, src_coords, rcv_coords, wavelet, space_order=8, save=False, q=None, return_op=False, isic=False, freq_list=None, dft_sub=None, ws=None, t_sub=1, nlind=False) Low level propagator, to be used through interface.py Compute linearized wavefield U = J(m)* \u03b4 m and related quantities. propagators.forward(model, src_coords, rcv_coords, wavelet, space_order=8, save=False, q=None, return_op=False, freq_list=None, dft_sub=None, ws=None, t_sub=1, **kwargs) Low level propagator, to be used through interface.py Compute forward wavefield u = A(m)^{-1}*f and related quantities (u(xrcv)) propagators.forward_grad(model, src_coords, rcv_coords, wavelet, v, space_order=8, q=None, ws=None, isic=False, w=None, freq=None, **kwargs) Low level propagator, to be used through interface.py Compute forward wavefield u = A(m)^{-1}*f and related quantities (u(xrcv)) propagators.gradient(model, residual, rcv_coords, u, return_op=False, space_order=8, w=None, freq=None, dft_sub=None, isic=False) Low level propagator, to be used through interface.py Compute the action of the adjoint Jacobian onto a residual J\u2019* \u03b4 d. propagators.name(model) sensitivity module sensitivity.basic_src(model, u, **kwargs) Basic source for linearized modeling Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) model ( Model ) \u2013 Model containing the perturbation dm sensitivity.crosscorr_freq(u, v, model, freq=None, dft_sub=None, **kwargs) Standard cross-correlation imaging condition with on-th-fly-dft Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure freq ( Array ) \u2013 Array of frequencies for on-the-fly DFT factor ( int ) \u2013 Subsampling factor for DFT sensitivity.crosscorr_time(u, v, model, **kwargs) Cross correlation of forward and adjoint wavefield Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure sensitivity.func_name(freq=None, isic=False) Get key for imaging condition/linearized source function sensitivity.grad_expr(gradm, u, v, model, w=None, freq=None, dft_sub=None, isic=False) Gradient update stencil Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure w ( Float or Expr ( optional ) ) \u2013 Weight for the gradient expression (default=1) freq ( Array ) \u2013 Array of frequencies for on-the-fly DFT factor ( int ) \u2013 Subsampling factor for DFT isic ( Bool ) \u2013 Whether or not to use inverse scattering imaging condition (not supported yet) sensitivity.inner_grad(u, v) Inner product of the gradient of two Function. Parameters u ( TimeFunction or Function ) \u2013 First wavefield v ( TimeFunction or Function ) \u2013 Second wavefield sensitivity.isic_freq(u, v, model, **kwargs) Inverse scattering imaging condition Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure sensitivity.isic_src(model, u, **kwargs) ISIC source for linearized modeling Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) model ( Model ) \u2013 Model containing the perturbation dm sensitivity.isic_time(u, v, model, **kwargs) Inverse scattering imaging condition Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure sensitivity.lin_src(model, u, isic=False) Source for linearized modeling Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) model ( Model ) \u2013 Model containing the perturbation dm sources module class sources.PointSource(*args, **kwargs) Symbolic data object for a set of sparse point sources Parameters name ( String ) \u2013 Name of the symbol representing this source grid ( Grid ) \u2013 Grid object defining the computational domain. coordinates ( Array ) \u2013 Point coordinates for this source data ( ( Optional ) Data ) \u2013 values to initialise point data ntime ( Int ( Optional ) ) \u2013 Number of timesteps for which to allocate data npoint ( Int ( Optional ) ) \u2013 of sparse points represented by this source ( Number ) \u2013 dimension ( Dimension ( Optional ) ) \u2013 object for representing the number of points in this source either the dimensions ntime and npoint or the fully ( Note , ) \u2013 data array need to be provided. ( initialised ) \u2013 default_assumptions( = {'commutative': True, 'complex': True, 'extended_real': True, 'finite': True, 'hermitian': True, 'imaginary': False, 'infinite': False, 'real': True ) is_commutative( = Tru ) is_complex( = Tru ) is_extended_real( = Tru ) is_finite( = Tru ) is_hermitian( = Tru ) is_imaginary( = Fals ) is_infinite( = Fals ) is_real( = Tru ) sources.Receiver() alias of sources.PointSource class sources.RickerSource(*args, **kwargs) Symbolic object that encapsulate a set of sources with a pre-defined Ricker wavelet: http://subsurfwiki.org/wiki/Ricker_wavelet name: Name for the resulting symbol grid: Grid object defining the computational domain. f0: Peak frequency for Ricker wavelet in kHz time: Discretized values of time in ms default_assumptions( = {'commutative': True, 'complex': True, 'extended_real': True, 'finite': True, 'hermitian': True, 'imaginary': False, 'infinite': False, 'real': True ) is_commutative( = Tru ) is_complex( = Tru ) is_extended_real( = Tru ) is_finite( = Tru ) is_hermitian( = Tru ) is_imaginary( = Fals ) is_infinite( = Fals ) is_real( = Tru ) wavelet(timev) class sources.TimeAxis(start=None, step=None, num=None, stop=None) Data object to store the TimeAxis. Exactly three of the four key arguments must be prescribed. Because of remainder values it is not possible to create a TimeAxis that exactly adhears to the inputs therefore start, stop, step and num values should be taken from the TimeAxis object rather than relying upon the input values. The four possible cases are: * start is None: start = step*(1 - num) + stop * step is None: step = (stop - start)/(num - 1) * num is None: num = ceil((stop - start + step)/step) and because of remainder stop = step*(num - 1) + start * stop is None: stop = step*(num - 1) + start Parameters start ( float , optional ) \u2013 Start of time axis. step ( float , optional ) \u2013 Time interval. num ( int , optional ) \u2013 Number of values (Note: this is the number of intervals + 1). Stop value is reset to correct for remainder. stop ( float , optional ) \u2013 End time. time_values() wave_utils module wave_utils.extended_src_weights(model, wavelet, v) Adjoint of extended source. This function returns the expression to obtain the spatially varrying weights from the wavefield and time-dependent wavelet Parameters model ( Model ) \u2013 Physical model structure wavelet ( Array ) \u2013 Time-serie for the time-varying source v ( TimeFunction ) \u2013 Wavefield to get the weights from wave_utils.extented_src(model, weight, wavelet, q=0) Extended source for modelling where the source is the outer product of a spatially varying weight and a time-dependent wavelet i.e.: u.dt2 - u.laplace = w(x)*q(t) This function returns the extended source w(x)*q(t) Parameters model ( Model ) \u2013 Physical model structure weight ( Array ) \u2013 Array of weight for the spatial Function wavelet ( Array ) \u2013 Time-serie for the time-varying source q ( Symbol or Expr ( optional ) ) \u2013 Previously existing source to be added to (source will be q + w(x)*q(t)) wave_utils.freesurface(model, eq) Generate the stencil that mirrors the field as a free surface modeling for the acoustic wave equation Parameters model ( Model ) \u2013 Physical model eq ( Eq or List of Eq ) \u2013 Equation to apply mirror to wave_utils.idft(v, freq=None) Symbolic inverse dft of v Parameters v ( TimeFunction or Tuple ) \u2013 Wavefield to take inverse DFT of freq ( Array ) \u2013 Array of frequencies for on-the-fly DFT wave_utils.otf_dft(u, freq, dt, factor=None) On the fly DFT wavefield (frequency slices) and expression Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield freq ( Array ) \u2013 Array of frequencies for on-the-fly DFT factor ( int ) \u2013 Subsampling factor for DFT wave_utils.sub_time(time, factor, dt=1, freq=None) Subsampled time axis Parameters time ( Dimension ) \u2013 time Dimension factor ( int ) \u2013 Subsampling factor wave_utils.wavefield(model, space_order, save=False, nt=None, fw=True, name='', t_sub=1) Create the wavefield for the wave equation Parameters model ( Model ) \u2013 Physical model space_order ( int ) \u2013 Spatial discretization order save ( Bool ) \u2013 Whether or not to save the time history nt ( int ( optional ) ) \u2013 Number of time steps if the wavefield is saved fw ( Bool ) \u2013 Forward or backward (for naming) name ( string ) \u2013 Custom name attached to default (u+name) wave_utils.wavefield_subsampled(model, u, nt, t_sub, space_order=8) Create a subsampled wavefield Parameters model ( Model ) \u2013 Physical model u ( TimeFunction ) \u2013 Forward wavefield for modeling nt ( int ) \u2013 Number of time steps on original time axis t_sub ( int ) \u2013 Factor for time-subsampling space_order ( int ) \u2013 Spatial discretization order wave_utils.weighted_norm(u, weight=None) Space-time norm of a wavefield, split into norm in time first then in space to avoid breaking loops Parameters u ( TimeFunction or Tuple of TimeFunction ) \u2013 Wavefield to take the norm of weight ( String ) \u2013 Spacial weight to apply wave_utils.wf_as_src(v, w=1, freq_list=None) Weighted source as a time-space wavefield Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) w ( Float or Expr ( optional ) ) \u2013 Weight for the source expression (default=1) Module contents","title":"Python API"},{"location":"pysource/#pysource-package","text":"","title":"pysource package"},{"location":"pysource/#submodules","text":"","title":"Submodules"},{"location":"pysource/#fd_utils-module","text":"","title":"FD_utils module"},{"location":"pysource/#fd_utilsr_matmodel","text":"Rotation matrix according to tilt and asymut. Parameters model ( Model ) \u2013 Model structure","title":"FD_utils.R_mat(model)"},{"location":"pysource/#fd_utilsdivsfunc-so_fact1-side-1","text":"GrDivergenceadient shifted by half a grid point, only to be used in combination with grads.","title":"FD_utils.divs(func, so_fact=1, side=- 1)"},{"location":"pysource/#fd_utilsgradsfunc-so_fact1-side1","text":"Gradient shifted by half a grid point, only to be used in combination with divs.","title":"FD_utils.grads(func, so_fact=1, side=1)"},{"location":"pysource/#fd_utilslaplacianv-irho","text":"Laplacian with density div( 1/rho grad) (u)","title":"FD_utils.laplacian(v, irho)"},{"location":"pysource/#fd_utilssa_ttiu-v-model","text":"Tensor factorized SSA TTI wave equation spatial derivatives. Parameters u ( TimeFunction ) \u2013 first TTI field v ( TimeFunction ) \u2013 second TTI field model ( Model ) \u2013 Model structure","title":"FD_utils.sa_tti(u, v, model)"},{"location":"pysource/#fd_utilsthomsen_matmodel","text":"Diagonal Matrices with Thomsen parameters for vectorial temporaries computation. Parameters model ( Model ) \u2013 Model structure","title":"FD_utils.thomsen_mat(model)"},{"location":"pysource/#checkpoint-module","text":"","title":"checkpoint module"},{"location":"pysource/#class-checkpointcheckpointoperatorop-kwargs","text":"Devito\u2019s concrete implementation of the ABC pyrevolve.Operator. This class wraps devito.Operator so it conforms to the pyRevolve API. pyRevolve will call apply with arguments t_start and t_end. Devito calls these arguments t_s and t_e so the following dict is used to perform the translations between different names. Parameters op ( Operator ) \u2013 devito.Operator object that this object will wrap. args ( dict ) \u2013 If devito.Operator.apply() expects any arguments, they can be provided here to be cached. Any calls to CheckpointOperator.apply() will automatically include these cached arguments in the call to the underlying devito.Operator.apply().","title":"class checkpoint.CheckpointOperator(op, **kwargs)"},{"location":"pysource/#applyt_start-t_end","text":"If the devito operator requires some extra arguments in the call to apply they can be stored in the args property of this object so pyRevolve calls pyRevolve.Operator.apply() without caring about these extra arguments while this method passes them on correctly to devito.Operator","title":"apply(t_start, t_end)"},{"location":"pysource/#t_arg_names-t_end-time_m-t_start-time_m","text":"","title":"t_arg_names( = {'t_end': 'time_M', 't_start': 'time_m' )"},{"location":"pysource/#class-checkpointdevitocheckpointobjects","text":"Devito\u2019s concrete implementation of the Checkpoint abstract base class provided by pyRevolve. Holds a list of symbol objects that hold data.","title":"class checkpoint.DevitoCheckpoint(objects)"},{"location":"pysource/#property-dtype","text":"data type","title":"property dtype()"},{"location":"pysource/#get_datatimestep","text":"returns the data (wavefield) for the time-step timestep","title":"get_data(timestep)"},{"location":"pysource/#get_data_locationtimestep","text":"returns the data (wavefield) for the time-step timestep","title":"get_data_location(timestep)"},{"location":"pysource/#load","text":"NotImplementedError","title":"load()"},{"location":"pysource/#save","text":"NotImplementedError","title":"save()"},{"location":"pysource/#property-size","text":"The memory consumption of the data contained in a checkpoint.","title":"property size()"},{"location":"pysource/#checkpointget_symbol_datasymbol-timestep","text":"Return the symbol corresponding to the data at time-step timestep","title":"checkpoint.get_symbol_data(symbol, timestep)"},{"location":"pysource/#geom_utils-module","text":"","title":"geom_utils module"},{"location":"pysource/#geom_utilssrc_recmodel-u-src_coordsnone-rec_coordsnone-waveletnone-fwtrue-ntnone","text":"Generates the source injection and receiver interpolation. This function is fully abstracted and does not care whether this is a forward or adjoint wave-equation. The source is the source term of the equation The receiver is the measurment term Therefore, for the adjoint, this function has to be called as: src_rec(model, v, src_coords=rec_coords, \u2026) because the data is the sources Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or tuple ) \u2013 Wavefield to inject into and read from src_coords ( Array ) \u2013 Physical coordinates of the sources rec_coords ( Array ) \u2013 Physical coordinates of the receivers wavelet ( Array ) \u2013 Data for the source fw=True \u2013 Whether the direction is forward or backward in time nt ( int ) \u2013 Number of time steps","title":"geom_utils.src_rec(model, u, src_coords=None, rec_coords=None, wavelet=None, fw=True, nt=None)"},{"location":"pysource/#interface-module","text":"","title":"interface module"},{"location":"pysource/#interfacej_adjointmodel-src_coords-wavelet-rec_coords-recin-space_order8-checkpointingfalse-n_checkpointsnone-t_sub1-maxmemnone-freq_list-dft_subnone-isicfalse-wsnone","text":"Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Supports three modes: * Checkpinting * Frequency compression (on-the-fly DFT) * Standard zero lag cross correlation over time Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) recin ( Array ) \u2013 Receiver data space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 checkpointing ( Bool ) \u2013 Whether or not to use checkpointing n_checkpoints ( Int ) \u2013 Number of checkpoints for checkpointing maxmem ( Float ) \u2013 Maximum memory to use for checkpointing freq_list ( List ) \u2013 List of frequencies for on-the-fly DFT dft_sub ( Int ) \u2013 Subsampling factor for on-the-fly DFT isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition ws ( Array ) \u2013 Extended source spatial distribution Returns Adjoint jacobian on the input data (gradient) Return type Array","title":"interface.J_adjoint(model, src_coords, wavelet, rec_coords, recin, space_order=8, checkpointing=False, n_checkpoints=None, t_sub=1, maxmem=None, freq_list=[], dft_sub=None, isic=False, ws=None)"},{"location":"pysource/#interfacej_adjoint_checkpointingmodel-src_coords-wavelet-rec_coords-recin-space_order8-is_residualfalse-n_checkpointsnone-born_fwdfalse-maxmemnone-return_objfalse-isicfalse-wsnone-t_sub1-nlindfalse","text":"Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with Checkpointing. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) recin ( Array ) \u2013 Receiver data space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 checkpointing ( Bool ) \u2013 Whether or not to use checkpointing n_checkpoints ( Int ) \u2013 Number of checkpoints for checkpointing maxmem ( Float ) \u2013 Maximum memory to use for checkpointing isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition ws ( Array ) \u2013 Extended source spatial distribution is_residual ( Bool ) \u2013 Whether to treat the input as the residual or as the observed data born_fwd ( Bool ) \u2013 Whether to use the forward or linearized forward modeling operator nlind ( Bool ) \u2013 Whether to remove the non linear data from the input data. This option is only available in combination with born_fwd Returns Adjoint jacobian on the input data (gradient) Return type Array","title":"interface.J_adjoint_checkpointing(model, src_coords, wavelet, rec_coords, recin, space_order=8, is_residual=False, n_checkpoints=None, born_fwd=False, maxmem=None, return_obj=False, isic=False, ws=None, t_sub=1, nlind=False)"},{"location":"pysource/#interfacej_adjoint_freqmodel-src_coords-wavelet-rec_coords-recin-space_order8-freq_list-is_residualfalse-return_objfalse-nlindfalse-dft_subnone-isicfalse-wsnone-t_sub1-born_fwdfalse","text":"Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with Frequency compression (on-the-fly DFT). Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) recin ( Array ) \u2013 Receiver data space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 freq_list ( List ) \u2013 List of frequencies for on-the-fly DFT dft_sub ( Int ) \u2013 Subsampling factor for on-the-fly DFT isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition ws ( Array ) \u2013 Extended source spatial distribution is_residual ( Bool ) \u2013 Whether to treat the input as the residual or as the observed data born_fwd ( Bool ) \u2013 Whether to use the forward or linearized forward modeling operator nlind ( Bool ) \u2013 Whether to remove the non linear data from the input data. This option is only available in combination with born_fwd Returns Adjoint jacobian on the input data (gradient) Return type Array","title":"interface.J_adjoint_freq(model, src_coords, wavelet, rec_coords, recin, space_order=8, freq_list=[], is_residual=False, return_obj=False, nlind=False, dft_sub=None, isic=False, ws=None, t_sub=1, born_fwd=False)"},{"location":"pysource/#interfacej_adjoint_standardmodel-src_coords-wavelet-rec_coords-recin-space_order8-is_residualfalse-return_objfalse-born_fwdfalse-isicfalse-wsnone-t_sub1-nlindfalse","text":"Adjoint Jacobian (adjoint fo born modeling operator) operator on a shot record as a source (i.e data residual). Outputs the gradient with standard zero lag cross correlation over time. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) recin ( Array ) \u2013 Receiver data space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition ws ( Array ) \u2013 Extended source spatial distribution is_residual ( Bool ) \u2013 Whether to treat the input as the residual or as the observed data born_fwd ( Bool ) \u2013 Whether to use the forward or linearized forward modeling operator nlind ( Bool ) \u2013 Whether to remove the non linear data from the input data. This option is only available in combination with born_fwd Returns Adjoint jacobian on the input data (gradient) Return type Array","title":"interface.J_adjoint_standard(model, src_coords, wavelet, rec_coords, recin, space_order=8, is_residual=False, return_obj=False, born_fwd=False, isic=False, ws=None, t_sub=1, nlind=False)"},{"location":"pysource/#interfaceadjoint_no_recmodel-rec_coords-data-space_order8","text":"Adjoint/backward modeling of a shot record (receivers as source) without source sampling F^T*Pr^T*d_obs. Parameters model ( Model ) \u2013 Physical model rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) data ( Array ) \u2013 Shot gather space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Adjoint wavefield Return type Array","title":"interface.adjoint_no_rec(model, rec_coords, data, space_order=8)"},{"location":"pysource/#interfaceadjoint_recmodel-src_coords-rec_coords-data-space_order8","text":"Adjoint/backward modeling of a shot record (receivers as source) Ps*F^T*Pr^T*d. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) data ( Array ) \u2013 Shot gather space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record (adjoint wavefield at source position(s)) Return type Array","title":"interface.adjoint_rec(model, src_coords, rec_coords, data, space_order=8)"},{"location":"pysource/#interfaceadjoint_wmodel-rec_coords-data-wavelet-space_order8","text":"Adjoint/backward modeling of a shot record (receivers as source) for an extended source setup Pw*F^T*Pr^T*d_obs. Parameters model ( Model ) \u2013 Physical model rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) data ( Array ) \u2013 Shot gather wavelet ( Array ) \u2013 Time signature of the forward source for stacking along time space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns spatial distribution Return type Array","title":"interface.adjoint_w(model, rec_coords, data, wavelet, space_order=8)"},{"location":"pysource/#interfaceadjoint_wf_srcmodel-u-src_coords-space_order8","text":"Adjoint/backward modeling of a full wavefield (full wavefield as adjoint source) Ps*F^T*u. Parameters model ( Model ) \u2013 Physical model u ( Array or TimeFunction ) \u2013 Time-space dependent source src_coords ( Array ) \u2013 Source coordinates space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record (sampled at source position(s)) Return type Array","title":"interface.adjoint_wf_src(model, u, src_coords, space_order=8)"},{"location":"pysource/#interfaceadjoint_wf_src_norecmodel-u-space_order8","text":"Adjoint/backward modeling of a full wavefield (full wavefield as adjoint source) F^T*u. Parameters model ( Model ) \u2013 Physical model u ( Array or TimeFunction ) \u2013 Time-space dependent source space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Adjoint wavefield Return type Array","title":"interface.adjoint_wf_src_norec(model, u, space_order=8)"},{"location":"pysource/#interfaceborn_recmodel-src_coords-wavelet-rec_coords-space_order8-isicfalse","text":"Linearized (Born) modeling of a point source for a model perturbation (square slowness) dm. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition Returns Shot record Return type Array","title":"interface.born_rec(model, src_coords, wavelet, rec_coords, space_order=8, isic=False)"},{"location":"pysource/#interfaceborn_rec_wmodel-weight-wavelet-rec_coords-space_order8-isicfalse","text":"Linearized (Born) modeling of an extended source for a model perturbation (square slowness) dm with an extended source Parameters model ( Model ) \u2013 Physical model weight ( Array ) \u2013 Spatial distriubtion of the extended source wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 isic ( Bool ) \u2013 Whether or not to use ISIC imaging condition Returns Shot record Return type Array","title":"interface.born_rec_w(model, weight, wavelet, rec_coords, space_order=8, isic=False)"},{"location":"pysource/#interfaceforward_no_recmodel-src_coords-wavelet-space_order8","text":"Forward modeling of a point source without receiver. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Wavefield Return type Array","title":"interface.forward_no_rec(model, src_coords, wavelet, space_order=8)"},{"location":"pysource/#interfaceforward_recmodel-src_coords-wavelet-rec_coords-space_order8","text":"Forward modeling of a point source with receivers Pr*F*Ps^T*q. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record Return type Array","title":"interface.forward_rec(model, src_coords, wavelet, rec_coords, space_order=8)"},{"location":"pysource/#interfaceforward_rec_wmodel-weight-wavelet-rec_coords-space_order8","text":"Forward modeling of an extended source with receivers Pr*F*Pw^T*w Parameters model ( Model ) \u2013 Physical model weights ( Array ) \u2013 Spatial distribution of the extended source. wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record Return type Array","title":"interface.forward_rec_w(model, weight, wavelet, rec_coords, space_order=8)"},{"location":"pysource/#interfaceforward_rec_wfmodel-src_coords-wavelet-rec_coords-t_sub1-space_order8","text":"Forward modeling of a point source Pr*F*Ps^T*q and return wavefield. Parameters model ( Model ) \u2013 Physical model src_coords ( Array ) \u2013 Coordiantes of the source(s) wavelet ( Array ) \u2013 Source signature rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Array \u2013 Shot record TimeFunction \u2013 Wavefield","title":"interface.forward_rec_wf(model, src_coords, wavelet, rec_coords, t_sub=1, space_order=8)"},{"location":"pysource/#interfaceforward_wf_srcmodel-u-rec_coords-space_order8","text":"Forward modeling of a full wavefield source Pr*F*u. Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or Array ) \u2013 Time-space dependent wavefield rec_coords ( Array ) \u2013 Coordiantes of the receiver(s) space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Shot record Return type Array","title":"interface.forward_wf_src(model, u, rec_coords, space_order=8)"},{"location":"pysource/#interfaceforward_wf_src_norecmodel-u-space_order8","text":"Forward modeling of a full wavefield source without receiver F*u. Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or Array ) \u2013 Time-space dependent wavefield space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns Wavefield Return type Array","title":"interface.forward_wf_src_norec(model, u, space_order=8)"},{"location":"pysource/#interfacegrad_fwimodel-recin-rec_coords-u-space_order8","text":"FWI gradient, i.e adjoint Jacobian on a data residual. Parameters model ( Model ) \u2013 Physical model recin ( Array ) \u2013 Data residual rec_coords ( Array ) \u2013 Receivers coordinates u ( TimeFunction ) \u2013 Forward wavefield space_order ( Int ( optional ) ) \u2013 Spatial discretization order, defaults to 8 Returns FWI gradient Return type Array","title":"interface.grad_fwi(model, recin, rec_coords, u, space_order=8)"},{"location":"pysource/#interfacewri_funcmodel-src_coords-wavelet-rec_coords-recin-yin-space_order8-isicfalse-wsnone-t_sub1-gradm-grad_corrfalse-alpha_opfalse-w_funnone-eps0-freq_list-wfiltnone","text":"Time domain wavefield reconstruction inversion wrapper","title":"interface.wri_func(model, src_coords, wavelet, rec_coords, recin, yin, space_order=8, isic=False, ws=None, t_sub=1, grad='m', grad_corr=False, alpha_op=False, w_fun=None, eps=0, freq_list=[], wfilt=None)"},{"location":"pysource/#kernels-module","text":"","title":"kernels module"},{"location":"pysource/#kernelsacoustic_kernelmodel-u-fwtrue-qnone","text":"Acoustic wave equation time stepper Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or tuple ) \u2013 wavefield (tuple if TTI) fw ( Bool ) \u2013 Whether forward or backward in time propagation q ( TimeFunction or Expr ) \u2013 Full time-space source","title":"kernels.acoustic_kernel(model, u, fw=True, q=None)"},{"location":"pysource/#kernelstti_kernelmodel-u1-u2-fwtrue-qnone","text":"TTI wave equation (one from my paper) time stepper Parameters model ( Model ) \u2013 Physical model u1 ( TimeFunction ) \u2013 First component (pseudo-P) of the wavefield u2 ( TimeFunction ) \u2013 First component (pseudo-P) of the wavefield fw ( Bool ) \u2013 Whether forward or backward in time propagation q ( TimeFunction or Expr ) \u2013 Full time-space source as a tuple (one value for each component)","title":"kernels.tti_kernel(model, u1, u2, fw=True, q=None)"},{"location":"pysource/#kernelswave_kernelmodel-u-fwtrue-qnone","text":"Pde kernel corresponding the the model for the input wavefield Parameters model ( Model ) \u2013 Physical model u ( TimeFunction or tuple ) \u2013 wavefield (tuple if TTI) fw ( Bool ) \u2013 Whether forward or backward in time propagation q ( TimeFunction or Expr ) \u2013 Full time-space source","title":"kernels.wave_kernel(model, u, fw=True, q=None)"},{"location":"pysource/#models-module","text":"","title":"models module"},{"location":"pysource/#class-modelsmodelorigin-spacing-shape-m-space_order2-nbl40-dtype-epsilonnone-deltanone-thetanone-phinone-rho1-dmnone-fsfalse-kwargs","text":"The physical model used in seismic inversion processes. Parameters origin ( tuple of floats ) \u2013 Origin of the model in m as a tuple in (x,y,z) order. spacing ( tuple of floats ) \u2013 Grid size in m as a Tuple in (x,y,z) order. shape ( tuple of int ) \u2013 Number of grid points size in (x,y,z) order. space_order ( int ) \u2013 Order of the spatial stencil discretisation. m ( array_like or float ) \u2013 Squared slownes in s^2/km^2 nbl ( int , optional ) \u2013 The number of absorbin layers for boundary damping. dtype ( np.float32 or np.float64 ) \u2013 Defaults to 32. epsilon ( array_like or float , optional ) \u2013 Thomsen epsilon parameter (0<epsilon<1). delta ( array_like or float ) \u2013 Thomsen delta parameter (0<delta<1), delta<epsilon. theta ( array_like or float ) \u2013 Tilt angle in radian. phi ( array_like or float ) \u2013 Asymuth angle in radian. dt ( Float ) \u2013 User provided computational time-step","title":"class models.Model(origin, spacing, shape, m, space_order=2, nbl=40, dtype=, epsilon=None, delta=None, theta=None, phi=None, rho=1, dm=None, fs=False, **kwargs)"},{"location":"pysource/#property-critical_dt","text":"Critical computational time step value from the CFL condition.","title":"property critical_dt()"},{"location":"pysource/#property-dm","text":"Model perturbation for linearized modeling","title":"property dm()"},{"location":"pysource/#property-dt","text":"User provided dt","title":"property dt()"},{"location":"pysource/#property-is_tti","text":"Whether the model is TTI or isotopic","title":"property is_tti()"},{"location":"pysource/#property-m","text":"Function holding the squared slowness in s^2/km^2.","title":"property m()"},{"location":"pysource/#property-space_order","text":"Spatial discretization order","title":"property space_order()"},{"location":"pysource/#property-spacing_map","text":"Map between spacing symbols and their values for each SpaceDimension.","title":"property spacing_map()"},{"location":"pysource/#property-vp","text":"Symbolic representation of the velocity vp = sqrt(1 / m)","title":"property vp()"},{"location":"pysource/#propagators-module","text":"","title":"propagators module"},{"location":"pysource/#propagatorsadjointmodel-y-src_coords-rcv_coords-space_order8-q0-dft_subnone-savefalse-wsnone-norm_vfalse-w_funnone-freq_listnone","text":"Low level propagator, to be used through interface.py Compute adjoint wavefield v = adjoint(F(m))*y and related quantities (||v||_w, v(xsrc))","title":"propagators.adjoint(model, y, src_coords, rcv_coords, space_order=8, q=0, dft_sub=None, save=False, ws=None, norm_v=False, w_fun=None, freq_list=None)"},{"location":"pysource/#propagatorsbornmodel-src_coords-rcv_coords-wavelet-space_order8-savefalse-qnone-return_opfalse-isicfalse-freq_listnone-dft_subnone-wsnone-t_sub1-nlindfalse","text":"Low level propagator, to be used through interface.py Compute linearized wavefield U = J(m)* \u03b4 m and related quantities.","title":"propagators.born(model, src_coords, rcv_coords, wavelet, space_order=8, save=False, q=None, return_op=False, isic=False, freq_list=None, dft_sub=None, ws=None, t_sub=1, nlind=False)"},{"location":"pysource/#propagatorsforwardmodel-src_coords-rcv_coords-wavelet-space_order8-savefalse-qnone-return_opfalse-freq_listnone-dft_subnone-wsnone-t_sub1-kwargs","text":"Low level propagator, to be used through interface.py Compute forward wavefield u = A(m)^{-1}*f and related quantities (u(xrcv))","title":"propagators.forward(model, src_coords, rcv_coords, wavelet, space_order=8, save=False, q=None, return_op=False, freq_list=None, dft_sub=None, ws=None, t_sub=1, **kwargs)"},{"location":"pysource/#propagatorsforward_gradmodel-src_coords-rcv_coords-wavelet-v-space_order8-qnone-wsnone-isicfalse-wnone-freqnone-kwargs","text":"Low level propagator, to be used through interface.py Compute forward wavefield u = A(m)^{-1}*f and related quantities (u(xrcv))","title":"propagators.forward_grad(model, src_coords, rcv_coords, wavelet, v, space_order=8, q=None, ws=None, isic=False, w=None, freq=None, **kwargs)"},{"location":"pysource/#propagatorsgradientmodel-residual-rcv_coords-u-return_opfalse-space_order8-wnone-freqnone-dft_subnone-isicfalse","text":"Low level propagator, to be used through interface.py Compute the action of the adjoint Jacobian onto a residual J\u2019* \u03b4 d.","title":"propagators.gradient(model, residual, rcv_coords, u, return_op=False, space_order=8, w=None, freq=None, dft_sub=None, isic=False)"},{"location":"pysource/#propagatorsnamemodel","text":"","title":"propagators.name(model)"},{"location":"pysource/#sensitivity-module","text":"","title":"sensitivity module"},{"location":"pysource/#sensitivitybasic_srcmodel-u-kwargs","text":"Basic source for linearized modeling Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) model ( Model ) \u2013 Model containing the perturbation dm","title":"sensitivity.basic_src(model, u, **kwargs)"},{"location":"pysource/#sensitivitycrosscorr_frequ-v-model-freqnone-dft_subnone-kwargs","text":"Standard cross-correlation imaging condition with on-th-fly-dft Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure freq ( Array ) \u2013 Array of frequencies for on-the-fly DFT factor ( int ) \u2013 Subsampling factor for DFT","title":"sensitivity.crosscorr_freq(u, v, model, freq=None, dft_sub=None, **kwargs)"},{"location":"pysource/#sensitivitycrosscorr_timeu-v-model-kwargs","text":"Cross correlation of forward and adjoint wavefield Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure","title":"sensitivity.crosscorr_time(u, v, model, **kwargs)"},{"location":"pysource/#sensitivityfunc_namefreqnone-isicfalse","text":"Get key for imaging condition/linearized source function","title":"sensitivity.func_name(freq=None, isic=False)"},{"location":"pysource/#sensitivitygrad_exprgradm-u-v-model-wnone-freqnone-dft_subnone-isicfalse","text":"Gradient update stencil Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure w ( Float or Expr ( optional ) ) \u2013 Weight for the gradient expression (default=1) freq ( Array ) \u2013 Array of frequencies for on-the-fly DFT factor ( int ) \u2013 Subsampling factor for DFT isic ( Bool ) \u2013 Whether or not to use inverse scattering imaging condition (not supported yet)","title":"sensitivity.grad_expr(gradm, u, v, model, w=None, freq=None, dft_sub=None, isic=False)"},{"location":"pysource/#sensitivityinner_gradu-v","text":"Inner product of the gradient of two Function. Parameters u ( TimeFunction or Function ) \u2013 First wavefield v ( TimeFunction or Function ) \u2013 Second wavefield","title":"sensitivity.inner_grad(u, v)"},{"location":"pysource/#sensitivityisic_frequ-v-model-kwargs","text":"Inverse scattering imaging condition Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure","title":"sensitivity.isic_freq(u, v, model, **kwargs)"},{"location":"pysource/#sensitivityisic_srcmodel-u-kwargs","text":"ISIC source for linearized modeling Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) model ( Model ) \u2013 Model containing the perturbation dm","title":"sensitivity.isic_src(model, u, **kwargs)"},{"location":"pysource/#sensitivityisic_timeu-v-model-kwargs","text":"Inverse scattering imaging condition Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) v ( TimeFunction or Tuple ) \u2013 Adjoint wavefield (tuple of fields for TTI) model ( Model ) \u2013 Model structure","title":"sensitivity.isic_time(u, v, model, **kwargs)"},{"location":"pysource/#sensitivitylin_srcmodel-u-isicfalse","text":"Source for linearized modeling Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) model ( Model ) \u2013 Model containing the perturbation dm","title":"sensitivity.lin_src(model, u, isic=False)"},{"location":"pysource/#sources-module","text":"","title":"sources module"},{"location":"pysource/#class-sourcespointsourceargs-kwargs","text":"Symbolic data object for a set of sparse point sources Parameters name ( String ) \u2013 Name of the symbol representing this source grid ( Grid ) \u2013 Grid object defining the computational domain. coordinates ( Array ) \u2013 Point coordinates for this source data ( ( Optional ) Data ) \u2013 values to initialise point data ntime ( Int ( Optional ) ) \u2013 Number of timesteps for which to allocate data npoint ( Int ( Optional ) ) \u2013 of sparse points represented by this source ( Number ) \u2013 dimension ( Dimension ( Optional ) ) \u2013 object for representing the number of points in this source either the dimensions ntime and npoint or the fully ( Note , ) \u2013 data array need to be provided. ( initialised ) \u2013","title":"class sources.PointSource(*args, **kwargs)"},{"location":"pysource/#default_assumptions-commutative-true-complex-true-extended_real-true-finite-true-hermitian-true-imaginary-false-infinite-false-real-true","text":"","title":"default_assumptions( = {'commutative': True, 'complex': True, 'extended_real': True, 'finite': True, 'hermitian': True, 'imaginary': False, 'infinite': False, 'real': True )"},{"location":"pysource/#is_commutative-tru","text":"","title":"is_commutative( = Tru )"},{"location":"pysource/#is_complex-tru","text":"","title":"is_complex( = Tru )"},{"location":"pysource/#is_extended_real-tru","text":"","title":"is_extended_real( = Tru )"},{"location":"pysource/#is_finite-tru","text":"","title":"is_finite( = Tru )"},{"location":"pysource/#is_hermitian-tru","text":"","title":"is_hermitian( = Tru )"},{"location":"pysource/#is_imaginary-fals","text":"","title":"is_imaginary( = Fals )"},{"location":"pysource/#is_infinite-fals","text":"","title":"is_infinite( = Fals )"},{"location":"pysource/#is_real-tru","text":"","title":"is_real( = Tru )"},{"location":"pysource/#sourcesreceiver","text":"alias of sources.PointSource","title":"sources.Receiver()"},{"location":"pysource/#class-sourcesrickersourceargs-kwargs","text":"Symbolic object that encapsulate a set of sources with a pre-defined Ricker wavelet: http://subsurfwiki.org/wiki/Ricker_wavelet name: Name for the resulting symbol grid: Grid object defining the computational domain. f0: Peak frequency for Ricker wavelet in kHz time: Discretized values of time in ms","title":"class sources.RickerSource(*args, **kwargs)"},{"location":"pysource/#default_assumptions-commutative-true-complex-true-extended_real-true-finite-true-hermitian-true-imaginary-false-infinite-false-real-true_1","text":"","title":"default_assumptions( = {'commutative': True, 'complex': True, 'extended_real': True, 'finite': True, 'hermitian': True, 'imaginary': False, 'infinite': False, 'real': True )"},{"location":"pysource/#is_commutative-tru_1","text":"","title":"is_commutative( = Tru )"},{"location":"pysource/#is_complex-tru_1","text":"","title":"is_complex( = Tru )"},{"location":"pysource/#is_extended_real-tru_1","text":"","title":"is_extended_real( = Tru )"},{"location":"pysource/#is_finite-tru_1","text":"","title":"is_finite( = Tru )"},{"location":"pysource/#is_hermitian-tru_1","text":"","title":"is_hermitian( = Tru )"},{"location":"pysource/#is_imaginary-fals_1","text":"","title":"is_imaginary( = Fals )"},{"location":"pysource/#is_infinite-fals_1","text":"","title":"is_infinite( = Fals )"},{"location":"pysource/#is_real-tru_1","text":"","title":"is_real( = Tru )"},{"location":"pysource/#wavelettimev","text":"","title":"wavelet(timev)"},{"location":"pysource/#class-sourcestimeaxisstartnone-stepnone-numnone-stopnone","text":"Data object to store the TimeAxis. Exactly three of the four key arguments must be prescribed. Because of remainder values it is not possible to create a TimeAxis that exactly adhears to the inputs therefore start, stop, step and num values should be taken from the TimeAxis object rather than relying upon the input values. The four possible cases are: * start is None: start = step*(1 - num) + stop * step is None: step = (stop - start)/(num - 1) * num is None: num = ceil((stop - start + step)/step) and because of remainder stop = step*(num - 1) + start * stop is None: stop = step*(num - 1) + start Parameters start ( float , optional ) \u2013 Start of time axis. step ( float , optional ) \u2013 Time interval. num ( int , optional ) \u2013 Number of values (Note: this is the number of intervals + 1). Stop value is reset to correct for remainder. stop ( float , optional ) \u2013 End time.","title":"class sources.TimeAxis(start=None, step=None, num=None, stop=None)"},{"location":"pysource/#time_values","text":"","title":"time_values()"},{"location":"pysource/#wave_utils-module","text":"","title":"wave_utils module"},{"location":"pysource/#wave_utilsextended_src_weightsmodel-wavelet-v","text":"Adjoint of extended source. This function returns the expression to obtain the spatially varrying weights from the wavefield and time-dependent wavelet Parameters model ( Model ) \u2013 Physical model structure wavelet ( Array ) \u2013 Time-serie for the time-varying source v ( TimeFunction ) \u2013 Wavefield to get the weights from","title":"wave_utils.extended_src_weights(model, wavelet, v)"},{"location":"pysource/#wave_utilsextented_srcmodel-weight-wavelet-q0","text":"Extended source for modelling where the source is the outer product of a spatially varying weight and a time-dependent wavelet i.e.: u.dt2 - u.laplace = w(x)*q(t) This function returns the extended source w(x)*q(t) Parameters model ( Model ) \u2013 Physical model structure weight ( Array ) \u2013 Array of weight for the spatial Function wavelet ( Array ) \u2013 Time-serie for the time-varying source q ( Symbol or Expr ( optional ) ) \u2013 Previously existing source to be added to (source will be q + w(x)*q(t))","title":"wave_utils.extented_src(model, weight, wavelet, q=0)"},{"location":"pysource/#wave_utilsfreesurfacemodel-eq","text":"Generate the stencil that mirrors the field as a free surface modeling for the acoustic wave equation Parameters model ( Model ) \u2013 Physical model eq ( Eq or List of Eq ) \u2013 Equation to apply mirror to","title":"wave_utils.freesurface(model, eq)"},{"location":"pysource/#wave_utilsidftv-freqnone","text":"Symbolic inverse dft of v Parameters v ( TimeFunction or Tuple ) \u2013 Wavefield to take inverse DFT of freq ( Array ) \u2013 Array of frequencies for on-the-fly DFT","title":"wave_utils.idft(v, freq=None)"},{"location":"pysource/#wave_utilsotf_dftu-freq-dt-factornone","text":"On the fly DFT wavefield (frequency slices) and expression Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield freq ( Array ) \u2013 Array of frequencies for on-the-fly DFT factor ( int ) \u2013 Subsampling factor for DFT","title":"wave_utils.otf_dft(u, freq, dt, factor=None)"},{"location":"pysource/#wave_utilssub_timetime-factor-dt1-freqnone","text":"Subsampled time axis Parameters time ( Dimension ) \u2013 time Dimension factor ( int ) \u2013 Subsampling factor","title":"wave_utils.sub_time(time, factor, dt=1, freq=None)"},{"location":"pysource/#wave_utilswavefieldmodel-space_order-savefalse-ntnone-fwtrue-name-t_sub1","text":"Create the wavefield for the wave equation Parameters model ( Model ) \u2013 Physical model space_order ( int ) \u2013 Spatial discretization order save ( Bool ) \u2013 Whether or not to save the time history nt ( int ( optional ) ) \u2013 Number of time steps if the wavefield is saved fw ( Bool ) \u2013 Forward or backward (for naming) name ( string ) \u2013 Custom name attached to default (u+name)","title":"wave_utils.wavefield(model, space_order, save=False, nt=None, fw=True, name='', t_sub=1)"},{"location":"pysource/#wave_utilswavefield_subsampledmodel-u-nt-t_sub-space_order8","text":"Create a subsampled wavefield Parameters model ( Model ) \u2013 Physical model u ( TimeFunction ) \u2013 Forward wavefield for modeling nt ( int ) \u2013 Number of time steps on original time axis t_sub ( int ) \u2013 Factor for time-subsampling space_order ( int ) \u2013 Spatial discretization order","title":"wave_utils.wavefield_subsampled(model, u, nt, t_sub, space_order=8)"},{"location":"pysource/#wave_utilsweighted_normu-weightnone","text":"Space-time norm of a wavefield, split into norm in time first then in space to avoid breaking loops Parameters u ( TimeFunction or Tuple of TimeFunction ) \u2013 Wavefield to take the norm of weight ( String ) \u2013 Spacial weight to apply","title":"wave_utils.weighted_norm(u, weight=None)"},{"location":"pysource/#wave_utilswf_as_srcv-w1-freq_listnone","text":"Weighted source as a time-space wavefield Parameters u ( TimeFunction or Tuple ) \u2013 Forward wavefield (tuple of fields for TTI or dft) w ( Float or Expr ( optional ) ) \u2013 Weight for the source expression (default=1)","title":"wave_utils.wf_as_src(v, w=1, freq_list=None)"},{"location":"pysource/#module-contents","text":"","title":"Module contents"},{"location":"tutorials/","text":"Tutorials These tutorials provide instructions of how to set up various modeling or inversion scenarios with JUDI. For a list of runnable Julia scripts and reproducable research, please also check out the examples directory on Github. 2D Modeling Quickstart To set up a simple 2D modeling experiment with JUDI with an OBN-type acquisition (receivers everywhere), we start by loading the module and building a two layer model: using JUDI # Grid n = (120, 100) # (x,z) d = (10., 10.) o = (0., 0.) # Velocity [km/s] v = ones(Float32, n) .* 1.4f0 v[:, 50:end] .= 5f0 # Squared slowness m = (1f0 ./ v).^2 For working with JUDI operators, we need to set up a model structure, which contains the grid information, as well as the slowness. Optionally, we can provide an array of the density in [g/cm^3] (by default a density of 1 is used): # Density (optional) rho = ones(Float32, n) # Model structure: model = Model(n, d, o, m; rho=rho) Next, we define our source acquisition geometry, which needs to be defined as a Geometry structure. The Geometry function requires the x-, y- and z-coordinates of the source locations as input, as well as the modeling time and samping interval of the wavelet. In general, each parameter can be passed as a cell array, where each cell entry provides the information for the respective source location. The helper function convertToCell converts a Julia range to a cell array, which makes defining the source geometry easier: # Set up source geometry nsrc = 4 # no. of sources xsrc = convertToCell(range(400f0, stop=800f0, length=nsrc)) ysrc = convertToCell(range(0f0, stop=0f0, length=nsrc)) zsrc = convertToCell(range(20f0, stop=20f0, length=nsrc)) # Modeling time and sampling interval time = 1000f0 # ms dt = 2f0 # ms # Set up source structure src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) Now we can define our source wavelet. The source must be defined as a judiVector , which takes the source geometry, as well as the source data (i.e. the wavelet) as an input argument: # Source wavelet f0 = 0.01f0 # kHz wavelet = ricker_wavelet(time, dt, f0) q = judiVector(src_geometry, wavelet) In general, wavelet can be a cell array with a different wavelet in each cell, i.e. for every source location. Here, we want to use the same wavelet for all 4 source experiments, so we can simply pass a single vector. As we already specified in our src_geometry object that we want to have 4 source locations, judiVector will automaticallty copy the wavelet for every experiment. Next, we set up the receiver acquisition geometry. Here, we define an OBN acquisition, where the receivers are spread out over the entire domain and each source experiment uses the same set of receivers. Again, we can in principle pass the coordinates as cell arrays, with one cell per source location. Since we want to use the same geometry for every source, we can use a short cut and define the coordinates as Julia ranges and pass nsrc=nsrc as an optional argument to the Geometry function. This tells the function that we want to use our receiver set up for nsrc distinct source experiments: # Set up receiver geometry (for 2D, set yrec to zero) nxrec = 120 xrec = range(50f0, stop=1150f0, length=nxrec) yrec = 0f0 zrec = range(50f0, stop=50f0, length=nxrec) # Set up receiver structure rec_geometry = Geometry(xrec, yrec, zrec; dt=dt, t=time, nsrc=nsrc) With our model and source and receiver geometries in place, we can proceed to defining our linear operator for seismic modeling. First, we need to define an info object, which contains some basic dimensionality information that needs to be shared between operators so that they can determine their size: # Set up info structure for linear operators ntComp = get_computational_nt(src_geometry, rec_geometry, model) info = Info(prod(n), nsrc, ntComp) Next, we can define separate operators for source/receiver projections and a forward modeling operator: # Setup operators Pr = judiProjection(info, rec_geometry) A_inv = judiModeling(info, model) Ps = judiProjection(info, src_geometry) We can see, that from JUDI's perspective, source and receivers are treated equally and are represented by the same operators ( judiProjection ) and vectors ( judiVector ). We also could've skipped setting up the projection operators and directly created: F = judiModeling(info, model, src_geometry, rec_geometry) which is equivalent to creating the combined operator: F = Pr*A_inv*Ps' Finally, to model our seismic data, we run: d_obs = Pr*A_inv*Ps'*q # or d_obs = F*q We can plot a 2D shot record by accessing the .data field of the judiVector , which contains the data in the original (non-vectorized) dimensions: using PyPlot imshow(d_obs.data[1], vmin=-5, vmax=5, cmap=\"seismic\", aspect=\"auto\") We can also set up a Jacobian operator for Born modeling and reverse-time migration. First we set up a (constant) migration velocity model: v0 = ones(Float32, n) .* 1.4f0 m0 = (1f0 ./ v0).^2 dm = m - m0 # model perturbation/image # Model structure model0 = Model(n, d, o, m0) We can create the Jacobian directly from a (non-linear) modeling operator and a source vector: A0_inv = judiModeling(info, model0) # modeling operator for migration velocity J = judiJacobian(Pr*A0_inv*Ps', q) We can use this operator to model single scattered data, as well as for migration our previous data: d_lin = J*vec(dm) # RTM rtm = J'*d_obs To plot, first reshape the image: rtm = reshape(rtm, model0.n) imshow(rtm', cmap=\"gray\", vmin=-1e3, vmax=1e3) 3D Modeling Quickstart Setting up a 3D experiment largely follows the instructions for the 2D example. Instead of a 2D model, we define our velocity model as: using JUDI # Grid n = (120, 100, 80) # (x,y,z) d = (10., 10., 10.) o = (0., 0., 0.) # Velocity [km/s] v = ones(Float32, n) .* 1.4f0 v[:, :, 40:end] .= 5f0 # Squared slowness and model structure m = (1f0 ./ v).^2 model = Model(n, d, o, m) Our source coordinates now also need to have the y-coordinate defined: # Set up source geometry nsrc = 4 # no. of sources xsrc = convertToCell(range(400f0, stop=800f0, length=nsrc)) ysrc = convertToCell(range(200f0, stop=1000f0, length=nsrc)) zsrc = convertToCell(range(20f0, stop=20f0, length=nsrc)) # Modeling time and sampling interval time = 1000f0 # ms dt = 2f0 # ms # Set up source structure src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) Our source wavelet, is set up as in the 2D case: # Source wavelet f0 = 0.01f0 # kHz wavelet = ricker_wavelet(time, dt, f0) q = judiVector(src_geometry, wavelet) For the receivers, we generally need to define each coordinate (x, y, z) for every receiver. I.e. xrec , yrec and zrec each have the length of the total number of receivers. However, oftentimes we are interested in a regular receiver grid, which can be defined by two basis vectors and a constant depth value for all receivers. We can then use the setup_3D_grid helper function to create the full set of coordinates: # Receiver geometry nxrec = 120 nyrec = 100 xrec = range(50f0, stop=1150f0, length=nxrec) yrec = range(100f0, stop=900f0, length=nyrec) zrec = 50f0 # Construct 3D grid from basis vectors (xrec, yrec, zrec) = setup_3D_grid(xrec, yrec, zrec) # Set up receiver structure rec_geometry = Geometry(xrec, yrec, zrec; dt=dt, t=time, nsrc=nsrc) Setting up the modeling operators is done as in the previous 2D case: # Set up info structure for linear operators ntComp = get_computational_nt(src_geometry, rec_geometry, model) info = Info(prod(n), nsrc, ntComp) # Setup operators Pr = judiProjection(info, rec_geometry) A_inv = judiModeling(info, model) Ps = judiProjection(info, src_geometry) # Model data d_obs = Pr*A_inv*Ps'*q The 3D shot records are still saved as 2D arrays of dimensions time x (nxrec*nyrec) : using PyPlot imshow(d_obs.data[1], vmin=-.4, vmax=.4, cmap=\"seismic\", aspect=\"auto\") Vertical and tilted-transverse isotropic modeling (VTI, TTI) JUDI supports both VTI and TTI modeling based on a coupled pseudo-acoustic wave equation. To enable VTI/TTI modeling, simply pass Thomsen parameters as well as the tilt angles to the Model structure as optional keyword arguments: # Grid and model n = (120, 100, 80) d = (10., 10., 10) o = (0., 0., 0.) # Velocity v = ones(Float32, n) .* 1.5f0 m = 1f0 ./ v.^2 # Thomsen parameters epsilon = ones(Float32, n) .* 0.2f0 delta = ones(Float32, n) .* 0.1f0 # Tile angles for TTI theta = ones(Float32, n) .* pi/2f0 phi = ones(Float32, n) .* pi/3f0 # 3D only # Set up model structure with Thomsen parameters model = Model(n, d, o, m; rho=rho, epsilon=epsilon, delta=delta, theta=theta, delta=delta) Modeling with density To use density, pass rho in the units of [g/cm^3] as an optional keyword argument to the Model structure. The default density is rho=1f0 (i.e. density of water): # Grid and model n = (120, 100) d = (10., 10.) o = (0., 0.) v = ones(Float32, n) .* 1.5f0 m = 1f0 ./ v.^2 rho = ones(Float32, n) .* 1.1f0 # Set up model structure with density model = Model(n, d, o, m; rho=rho) 2D Marine streamer acquisition For a marine streamer acquisition, we need to define a moving set of receivers representing a streamer that is towed behind a seismic source vessel. In JUDI, this is easily done by defining a different set of receivers for each source location. Here, we explain how to set up the Geometry objects for a 2D marine streamer acquisition. If we define that our streamer is to the right side of the source vessel, this has the effect that part of the streamer is outside the grid while our vessel is in the right side of the model. To circumvent this, we can say that our streamer is on the right side of the source while the vessel is in the left-hand side of the model and vice versa. This way, we get the full maximum offset coverage for every source location (assuming that the maximum offset is less or equal than half the domain size). First, we have to specify our domain size (the physical extent of our model), as well as the number of receivers and the minimum and maximum offset: domain_x = (model.n[1] - 1)*model.d[1] # horizontal extent of model nrec = 120 # no. of receivers xmin = 50f0 # leave buffer zone w/o source and receivers of this size xmax = domain_x - 50f0 min_offset = 10f0 # distance between source and first receiver max_offset = 400f0 # distance between source and last xmid = domain_x / 2 # midpoint of model source_spacing = 25f0 # source interval [m] For the JUDI Geometry objects, we need to create cell arrays for the source and receiver coordinates, with one cell entry per source location: # Source/receivers nsrc = 20 # number of shot locations # Receiver coordinates xrec = Array{Any}(undef, nsrc) yrec = Array{Any}(undef, nsrc) zrec = Array{Any}(undef, nsrc) # Source coordinates xsrc = Array{Any}(undef, nsrc) ysrc = Array{Any}(undef, nsrc) zsrc = Array{Any}(undef, nsrc) Next, we compute the source and receiver coordinates for when the vessel moves from left to right in the right-hand side of the model: # Vessel goes from left to right in right-hand side of model nsrc_half = Int(nsrc/2) for j=1:nsrc_half xloc = xmid + (j-1)*source_spacing # Current receiver locations xrec[j] = range(xloc - max_offset, xloc - min_offset, length=nrec) yrec[j] = 0. zrec[j] = range(50f0, 50f0, length=nrec) # Current source xsrc[j] = xloc ysrc[j] = 0f0 zsrc[j] = 20f0 end Then, we repeat this for the case where the vessel goes from right to left in the left-hand model side: # Vessel goes from right to left in left-hand side of model for j=1:nsrc_half xloc = xmid - (j-1)*source_spacing # Current receiver locations xrec[nsrc_half + j] = range(xloc + min_offset, xloc + max_offset, length=nrec) yrec[nsrc_half + j] = 0f0 zrec[nsrc_half + j] = range(50f0, 50f0, length=nrec) # Current source xsrc[nsrc_half + j] = xloc ysrc[nsrc_half + j] = 0f0 zsrc[nsrc_half + j] = 20f0 end Finally, we can set the modeling time and sampling interval and create the Geometry objects: # receiver sampling and recording time time = 10000f0 # receiver recording time [ms] dt = 4f0 # receiver sampling interval # Set geometry objects rec_geometry = Geometry(xrec, yrec, zrec; dt=dt, t=time) src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) You can find a full (reproducable) example for generating a marine streamer data set for the Sigsbee 2A model here . Simultaneous sources To set up a simultaneous source with JUDI, we first create a cell array with nsrc cells, where nsrc is the number of separate experiments (here nsrc=1 ). For a simultaneous source, we create an array of source coordinates for each cell entry. In fact, this is exactly like setting up the receiver geometry, in which case we define multiple receivers per shot location. Here, we define a single experiment with a simultaneous source consisting of four sources: nsrc = 1 # single simultaneous source xsrc = Array{Any}(undef, nsrc) ysrc = Array{Any}(undef, nsrc) zsrc = Array{Any}(undef, nsrc) # Set up source geometry xsrc[1] = [250f0, 500f0, 750f0, 1000f0] # four simultaneous sources ysrc[1] = 0f0 zsrc[1] = [50f0, 50f0, 50f0, 50f0] # Source sampling and number of time steps time = 2000f0 dt = 4f0 # Set up source structure src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) With the simultaneous source geometry in place, we can now create our simultaneous data. As we have four sources per sim. source, we create an array of dimensions 4 x src_geometry.nt[1] and fill it with wavelets of different time shifts: # Create wavelet f0 = 0.01 # source peak frequencies q = ricker_wavelet(500f0, dt, f0) # 500 ms wavelet # Create array with different time shifts of the wavelet wavelet = zeros(Float32, 4, src_geometry.nt[1]) wavelet[1, 1:1+length(q)-1] = q wavelet[2, 41:41+length(q)-1] = q wavelet[3, 121:121+length(q)-1] = q wavelet[4, 201:201+length(q)-1] = q Finally, we create our simultaneous source as a judiVector : # Source wavelet q = judiVector(src_geometry, wavelet) Working with wavefields JUDI allows computing full time domain wavefields and using them as right-hand sides for wave equations solves. This tutorial shows how. We start by setting up a basic 2D experiment: using JUDI # Grid n = (120, 100) # (x,z) d = (10., 10.) o = (0., 0.) # Velocity [km/s] v = ones(Float32, n) .* 1.4f0 v[:, 50:end] .= 5f0 # Squared slowness m = (1f0 ./ v).^2 # Model structure: model = Model(n, d, o, m) Next, we set up the source geometry for a single source experiment: # Set up source geometry nsrc = 1 # no. of sources xsrc = convertToCell([600f0]) ysrc = convertToCell([0f0]) zsrc = convertToCell([20f0]) # Modeling time and sampling interval time = 600f0 # ms dt = 4f0 # ms # Set up source structure src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) # Source wavelet f0 = 0.01f0 # kHz wavelet = ricker_wavelet(time, dt, f0) q = judiVector(src_geometry, wavelet) As in the 2D quick start tutorial, we create our info structure, modeling operator and source projection operator: # Set up info structure for linear operators ntComp = get_computational_nt(src_geometry, model) info = Info(prod(n), nsrc, ntComp) # Setup operators A_inv = judiModeling(info, model) Ps = judiProjection(info, src_geometry) To model a wavefield, we simply omit the receiver sampling operator: u = A_inv*Ps'*q This return an abstract data vector called judiWavefield . Similar to judiVectors , we can access the data for each source number i via u.data[i] . The data is a 3D array of size (nt, nx, nz) for 2D and a 4D array of size (nt, nx, ny, nz) for 3D. We can plot the wavefield of the 600th time step with: using PyPlot imshow(u.data[1][600, :, :]', vmin=-5, vmax=5, cmap=\"seismic\", aspect=\"auto\") We can also use the computed wavefield u as a right-hand side for forward and adjoint wave equation solves: v = A_inv*u w = A_inv'*u Similarly, by setting up a receiver projection operator, we can use wavefields as right-hand sides, but restrict the output to the receiver locations. Extended source modeling JUDI supports extened source modeling, which injects a 1D wavelet q at every point in the subsurface weighted by a spatially varying extended source. To demonstrate extended source modeling, we first set up a runnable 2D experiment with JUDI. We start with defining the model: using JUDI # Grid n = (120, 100) # (x,z) d = (10., 10.) o = (0., 0.) # Velocity [km/s] v = ones(Float32, n) .* 1.4f0 v[:, 50:end] .= 5f0 # Squared slowness m = (1f0 ./ v).^2 # Model structure: model = Model(n, d, o, m) Next, we set up the receiver geometry: # Number of experiments nsrc = 2 # Set up receiver geometry nxrec = 120 xrec = range(50f0, stop=1150f0, length=nxrec) yrec = 0f0 zrec = range(50f0, stop=50f0, length=nxrec) # Modeling time and receiver sampling interval time = 2000 dt = 4 # Set up receiver structure rec_geometry = Geometry(xrec, yrec, zrec; dt=dt, t=time, nsrc=nsrc) For the extended source, we do not need to set up a source geometry object, but we need to define a wavelet function: # Source wavelet f0 = 0.01f0 # MHz wavelet = ricker_wavelet(time, dt, f0) As before, we set up an info structure, as well as a modeling operator and a receiver sampling operator: # Set up info structure for linear operators ntComp = get_computational_nt(rec_geometry, model) info = Info(prod(n), nsrc, ntComp) # Setup operators A_inv = judiModeling(info, model) Pr = judiProjection(info, rec_geometry) We define our extended source as a so called judiWeights vector. Similar to a judiVector , the data of this abstract vector is stored as a cell array, where each cell corresponds to one source experiment. We create a cell array of length two and create a random array of the size of the model as our extended source: weights = Array{Array}(undef, nsrc) for j=1:nsrc weights[j] = randn(Float32, model.n) end w = judiWeights(weights) To inject the extended source into the model and weight it by the wavelet, we create a special projection operator called judiLRWF (for JUDI low-rank wavefield). This operator needs to know the wavelet we defined earlier. We can then create our full modeling operator, by combining Pw with A_inv and the receiver sampling operator: # Create operator for injecting the weights, multiplied by the provided wavelet(s) Pw = judiLRWF(info, wavelet) # Model observed data w/ extended source F = Pr*A_inv*adjoint(Pw) Extended source modeling supports both forward and adjoint modeling: # Simultaneous observed data d_sim = F*w dw = adjoint(F)*d_sim As for regular modeling, we can create a Jacobian for linearized modeling and migration. First we define a migration velocity model and the corresponding modeling operator A0_inv : # Migration velocity and squared slowness v0 = ones(Float32, n) .* 1.4f0 m0 = (1f0 ./ v0).^2 # Model structure and modeling operator for migration velocity model0 = Model(n, d, o, m0) A0_inv = judiModeling(info, model0) # Jacobian and RTM J = judiJacobian(Pr*A0_inv*adjoint(Pw), w) rtm = adjoint(J)*d_sim As before, we can plot the image after reshaping it into its original dimensions: rtm = reshape(rtm, model.n) imshow(rtm', cmap=\"gray\", vmin=-3e6, vmax=3e6) Please also refer to the reproducable example on github for 2D and 3D extended modeling. Impedance imaging (inverse scattering) JUDI supports imaging (RTM) and demigration (linearized modeling) using the linearized inverse scattering imaging condition (ISIC) and its corresponding adjoint. ISIC can be enabled via the Options class. You can set this options when you initially create the modeling operator: # Options strucuture opt = Options(isic=true) # Set up modeling operator A0_inv = judiModeling(info, model0; options=opt) When you create a Jacobian from a forward modeling operator, the Jacobian inherits the options from A0_inv : J = judiJacobian(Pr*A0_inv*Ps', q) J.options.isic # -> true Alternatively, you can directly set the option in your Jacobian: J.options.isic = true # enable isic J.options.isic = false # disable isic Optimal checkpointing JUDI supports optimal checkpointing via Devito's interface to the Revolve library. To enable checkpointing, use the Options class: # Options strucuture opt = Options(optimal_checkpointing=true) # Set up modeling operator A0_inv = judiModeling(info, model0; options=opt) When you create a Jacobian from a forward modeling operator, the Jacobian inherits the options from A0_inv : J = judiJacobian(Pr*A0_inv*Ps', q) J.options.optimal_checkpointing # -> true Alternatively, you can directly set the option in your Jacobian: J.options.optimal_checkpointing = true # enable checkpointing J.options.optimal_checkpointing = false # disable checkpointing On-the-fly Fourier transforms JUDI supports seismic imaging in the frequency domain using on-the-fly discrete Fourier transforms (DFTs). To compute an RTM image in the frequency domain for a given set of frequencies, we first create a cell array for the frequencies of each source experiment: nsrc = 4 # assume 4 source experiments frequencies = Array{Any}(undef, nsrc) Now we can define single or multiple frequencies for each shot location for which the RTM image will be computed: # For every source location, compute RTM image for 10 and 20 Hz for j=1:nsrc frequencies[j] = [0.001, 0.002] end The frequencies are passed to the Jacobian via the options field. Assuming we already have a Jacobian set up, we set the frequencies via: J.options.frequencies = frequencies Instead of the same two frequencies for each source experiment, we could have chosen different random sets of frequencies, which creates an RTM with incoherent noise. We can also draw random frequencies using the frequency spectrum of the true source as the probability density function. To create a distribution for a given source q ( judiVector ) from which we can draw frequency samples, use: q_dist = generate_distribution(q) Then we can assigne a random set of frequencies in a specified range as follows: nfreq = 10 # no. of frequencies per source location for j=1:nsrc J.options.frequencies[j] = select_frequencies(q_dist; fmin=0.003, fmax=0.04, nf=nfreq) end Once the options.frequencies field is set, on-the-fly DFTs are used for both born modeling and RTM. To save computational cost, we can limit the number of DFTs that are performed. Rather than computing the DFT at every time step, we can define a subsampling factor as follows: # Compute DFT every 4 time steps J.options.dft_subsampling_factor=4","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"These tutorials provide instructions of how to set up various modeling or inversion scenarios with JUDI. For a list of runnable Julia scripts and reproducable research, please also check out the examples directory on Github.","title":"Tutorials"},{"location":"tutorials/#2d-modeling-quickstart","text":"To set up a simple 2D modeling experiment with JUDI with an OBN-type acquisition (receivers everywhere), we start by loading the module and building a two layer model: using JUDI # Grid n = (120, 100) # (x,z) d = (10., 10.) o = (0., 0.) # Velocity [km/s] v = ones(Float32, n) .* 1.4f0 v[:, 50:end] .= 5f0 # Squared slowness m = (1f0 ./ v).^2 For working with JUDI operators, we need to set up a model structure, which contains the grid information, as well as the slowness. Optionally, we can provide an array of the density in [g/cm^3] (by default a density of 1 is used): # Density (optional) rho = ones(Float32, n) # Model structure: model = Model(n, d, o, m; rho=rho) Next, we define our source acquisition geometry, which needs to be defined as a Geometry structure. The Geometry function requires the x-, y- and z-coordinates of the source locations as input, as well as the modeling time and samping interval of the wavelet. In general, each parameter can be passed as a cell array, where each cell entry provides the information for the respective source location. The helper function convertToCell converts a Julia range to a cell array, which makes defining the source geometry easier: # Set up source geometry nsrc = 4 # no. of sources xsrc = convertToCell(range(400f0, stop=800f0, length=nsrc)) ysrc = convertToCell(range(0f0, stop=0f0, length=nsrc)) zsrc = convertToCell(range(20f0, stop=20f0, length=nsrc)) # Modeling time and sampling interval time = 1000f0 # ms dt = 2f0 # ms # Set up source structure src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) Now we can define our source wavelet. The source must be defined as a judiVector , which takes the source geometry, as well as the source data (i.e. the wavelet) as an input argument: # Source wavelet f0 = 0.01f0 # kHz wavelet = ricker_wavelet(time, dt, f0) q = judiVector(src_geometry, wavelet) In general, wavelet can be a cell array with a different wavelet in each cell, i.e. for every source location. Here, we want to use the same wavelet for all 4 source experiments, so we can simply pass a single vector. As we already specified in our src_geometry object that we want to have 4 source locations, judiVector will automaticallty copy the wavelet for every experiment. Next, we set up the receiver acquisition geometry. Here, we define an OBN acquisition, where the receivers are spread out over the entire domain and each source experiment uses the same set of receivers. Again, we can in principle pass the coordinates as cell arrays, with one cell per source location. Since we want to use the same geometry for every source, we can use a short cut and define the coordinates as Julia ranges and pass nsrc=nsrc as an optional argument to the Geometry function. This tells the function that we want to use our receiver set up for nsrc distinct source experiments: # Set up receiver geometry (for 2D, set yrec to zero) nxrec = 120 xrec = range(50f0, stop=1150f0, length=nxrec) yrec = 0f0 zrec = range(50f0, stop=50f0, length=nxrec) # Set up receiver structure rec_geometry = Geometry(xrec, yrec, zrec; dt=dt, t=time, nsrc=nsrc) With our model and source and receiver geometries in place, we can proceed to defining our linear operator for seismic modeling. First, we need to define an info object, which contains some basic dimensionality information that needs to be shared between operators so that they can determine their size: # Set up info structure for linear operators ntComp = get_computational_nt(src_geometry, rec_geometry, model) info = Info(prod(n), nsrc, ntComp) Next, we can define separate operators for source/receiver projections and a forward modeling operator: # Setup operators Pr = judiProjection(info, rec_geometry) A_inv = judiModeling(info, model) Ps = judiProjection(info, src_geometry) We can see, that from JUDI's perspective, source and receivers are treated equally and are represented by the same operators ( judiProjection ) and vectors ( judiVector ). We also could've skipped setting up the projection operators and directly created: F = judiModeling(info, model, src_geometry, rec_geometry) which is equivalent to creating the combined operator: F = Pr*A_inv*Ps' Finally, to model our seismic data, we run: d_obs = Pr*A_inv*Ps'*q # or d_obs = F*q We can plot a 2D shot record by accessing the .data field of the judiVector , which contains the data in the original (non-vectorized) dimensions: using PyPlot imshow(d_obs.data[1], vmin=-5, vmax=5, cmap=\"seismic\", aspect=\"auto\") We can also set up a Jacobian operator for Born modeling and reverse-time migration. First we set up a (constant) migration velocity model: v0 = ones(Float32, n) .* 1.4f0 m0 = (1f0 ./ v0).^2 dm = m - m0 # model perturbation/image # Model structure model0 = Model(n, d, o, m0) We can create the Jacobian directly from a (non-linear) modeling operator and a source vector: A0_inv = judiModeling(info, model0) # modeling operator for migration velocity J = judiJacobian(Pr*A0_inv*Ps', q) We can use this operator to model single scattered data, as well as for migration our previous data: d_lin = J*vec(dm) # RTM rtm = J'*d_obs To plot, first reshape the image: rtm = reshape(rtm, model0.n) imshow(rtm', cmap=\"gray\", vmin=-1e3, vmax=1e3)","title":"2D Modeling Quickstart"},{"location":"tutorials/#3d-modeling-quickstart","text":"Setting up a 3D experiment largely follows the instructions for the 2D example. Instead of a 2D model, we define our velocity model as: using JUDI # Grid n = (120, 100, 80) # (x,y,z) d = (10., 10., 10.) o = (0., 0., 0.) # Velocity [km/s] v = ones(Float32, n) .* 1.4f0 v[:, :, 40:end] .= 5f0 # Squared slowness and model structure m = (1f0 ./ v).^2 model = Model(n, d, o, m) Our source coordinates now also need to have the y-coordinate defined: # Set up source geometry nsrc = 4 # no. of sources xsrc = convertToCell(range(400f0, stop=800f0, length=nsrc)) ysrc = convertToCell(range(200f0, stop=1000f0, length=nsrc)) zsrc = convertToCell(range(20f0, stop=20f0, length=nsrc)) # Modeling time and sampling interval time = 1000f0 # ms dt = 2f0 # ms # Set up source structure src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) Our source wavelet, is set up as in the 2D case: # Source wavelet f0 = 0.01f0 # kHz wavelet = ricker_wavelet(time, dt, f0) q = judiVector(src_geometry, wavelet) For the receivers, we generally need to define each coordinate (x, y, z) for every receiver. I.e. xrec , yrec and zrec each have the length of the total number of receivers. However, oftentimes we are interested in a regular receiver grid, which can be defined by two basis vectors and a constant depth value for all receivers. We can then use the setup_3D_grid helper function to create the full set of coordinates: # Receiver geometry nxrec = 120 nyrec = 100 xrec = range(50f0, stop=1150f0, length=nxrec) yrec = range(100f0, stop=900f0, length=nyrec) zrec = 50f0 # Construct 3D grid from basis vectors (xrec, yrec, zrec) = setup_3D_grid(xrec, yrec, zrec) # Set up receiver structure rec_geometry = Geometry(xrec, yrec, zrec; dt=dt, t=time, nsrc=nsrc) Setting up the modeling operators is done as in the previous 2D case: # Set up info structure for linear operators ntComp = get_computational_nt(src_geometry, rec_geometry, model) info = Info(prod(n), nsrc, ntComp) # Setup operators Pr = judiProjection(info, rec_geometry) A_inv = judiModeling(info, model) Ps = judiProjection(info, src_geometry) # Model data d_obs = Pr*A_inv*Ps'*q The 3D shot records are still saved as 2D arrays of dimensions time x (nxrec*nyrec) : using PyPlot imshow(d_obs.data[1], vmin=-.4, vmax=.4, cmap=\"seismic\", aspect=\"auto\")","title":"3D Modeling Quickstart"},{"location":"tutorials/#vertical-and-tilted-transverse-isotropic-modeling-vti-tti","text":"JUDI supports both VTI and TTI modeling based on a coupled pseudo-acoustic wave equation. To enable VTI/TTI modeling, simply pass Thomsen parameters as well as the tilt angles to the Model structure as optional keyword arguments: # Grid and model n = (120, 100, 80) d = (10., 10., 10) o = (0., 0., 0.) # Velocity v = ones(Float32, n) .* 1.5f0 m = 1f0 ./ v.^2 # Thomsen parameters epsilon = ones(Float32, n) .* 0.2f0 delta = ones(Float32, n) .* 0.1f0 # Tile angles for TTI theta = ones(Float32, n) .* pi/2f0 phi = ones(Float32, n) .* pi/3f0 # 3D only # Set up model structure with Thomsen parameters model = Model(n, d, o, m; rho=rho, epsilon=epsilon, delta=delta, theta=theta, delta=delta)","title":"Vertical and tilted-transverse isotropic modeling (VTI, TTI)"},{"location":"tutorials/#modeling-with-density","text":"To use density, pass rho in the units of [g/cm^3] as an optional keyword argument to the Model structure. The default density is rho=1f0 (i.e. density of water): # Grid and model n = (120, 100) d = (10., 10.) o = (0., 0.) v = ones(Float32, n) .* 1.5f0 m = 1f0 ./ v.^2 rho = ones(Float32, n) .* 1.1f0 # Set up model structure with density model = Model(n, d, o, m; rho=rho)","title":"Modeling with density"},{"location":"tutorials/#2d-marine-streamer-acquisition","text":"For a marine streamer acquisition, we need to define a moving set of receivers representing a streamer that is towed behind a seismic source vessel. In JUDI, this is easily done by defining a different set of receivers for each source location. Here, we explain how to set up the Geometry objects for a 2D marine streamer acquisition. If we define that our streamer is to the right side of the source vessel, this has the effect that part of the streamer is outside the grid while our vessel is in the right side of the model. To circumvent this, we can say that our streamer is on the right side of the source while the vessel is in the left-hand side of the model and vice versa. This way, we get the full maximum offset coverage for every source location (assuming that the maximum offset is less or equal than half the domain size). First, we have to specify our domain size (the physical extent of our model), as well as the number of receivers and the minimum and maximum offset: domain_x = (model.n[1] - 1)*model.d[1] # horizontal extent of model nrec = 120 # no. of receivers xmin = 50f0 # leave buffer zone w/o source and receivers of this size xmax = domain_x - 50f0 min_offset = 10f0 # distance between source and first receiver max_offset = 400f0 # distance between source and last xmid = domain_x / 2 # midpoint of model source_spacing = 25f0 # source interval [m] For the JUDI Geometry objects, we need to create cell arrays for the source and receiver coordinates, with one cell entry per source location: # Source/receivers nsrc = 20 # number of shot locations # Receiver coordinates xrec = Array{Any}(undef, nsrc) yrec = Array{Any}(undef, nsrc) zrec = Array{Any}(undef, nsrc) # Source coordinates xsrc = Array{Any}(undef, nsrc) ysrc = Array{Any}(undef, nsrc) zsrc = Array{Any}(undef, nsrc) Next, we compute the source and receiver coordinates for when the vessel moves from left to right in the right-hand side of the model: # Vessel goes from left to right in right-hand side of model nsrc_half = Int(nsrc/2) for j=1:nsrc_half xloc = xmid + (j-1)*source_spacing # Current receiver locations xrec[j] = range(xloc - max_offset, xloc - min_offset, length=nrec) yrec[j] = 0. zrec[j] = range(50f0, 50f0, length=nrec) # Current source xsrc[j] = xloc ysrc[j] = 0f0 zsrc[j] = 20f0 end Then, we repeat this for the case where the vessel goes from right to left in the left-hand model side: # Vessel goes from right to left in left-hand side of model for j=1:nsrc_half xloc = xmid - (j-1)*source_spacing # Current receiver locations xrec[nsrc_half + j] = range(xloc + min_offset, xloc + max_offset, length=nrec) yrec[nsrc_half + j] = 0f0 zrec[nsrc_half + j] = range(50f0, 50f0, length=nrec) # Current source xsrc[nsrc_half + j] = xloc ysrc[nsrc_half + j] = 0f0 zsrc[nsrc_half + j] = 20f0 end Finally, we can set the modeling time and sampling interval and create the Geometry objects: # receiver sampling and recording time time = 10000f0 # receiver recording time [ms] dt = 4f0 # receiver sampling interval # Set geometry objects rec_geometry = Geometry(xrec, yrec, zrec; dt=dt, t=time) src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) You can find a full (reproducable) example for generating a marine streamer data set for the Sigsbee 2A model here .","title":"2D Marine streamer acquisition"},{"location":"tutorials/#simultaneous-sources","text":"To set up a simultaneous source with JUDI, we first create a cell array with nsrc cells, where nsrc is the number of separate experiments (here nsrc=1 ). For a simultaneous source, we create an array of source coordinates for each cell entry. In fact, this is exactly like setting up the receiver geometry, in which case we define multiple receivers per shot location. Here, we define a single experiment with a simultaneous source consisting of four sources: nsrc = 1 # single simultaneous source xsrc = Array{Any}(undef, nsrc) ysrc = Array{Any}(undef, nsrc) zsrc = Array{Any}(undef, nsrc) # Set up source geometry xsrc[1] = [250f0, 500f0, 750f0, 1000f0] # four simultaneous sources ysrc[1] = 0f0 zsrc[1] = [50f0, 50f0, 50f0, 50f0] # Source sampling and number of time steps time = 2000f0 dt = 4f0 # Set up source structure src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) With the simultaneous source geometry in place, we can now create our simultaneous data. As we have four sources per sim. source, we create an array of dimensions 4 x src_geometry.nt[1] and fill it with wavelets of different time shifts: # Create wavelet f0 = 0.01 # source peak frequencies q = ricker_wavelet(500f0, dt, f0) # 500 ms wavelet # Create array with different time shifts of the wavelet wavelet = zeros(Float32, 4, src_geometry.nt[1]) wavelet[1, 1:1+length(q)-1] = q wavelet[2, 41:41+length(q)-1] = q wavelet[3, 121:121+length(q)-1] = q wavelet[4, 201:201+length(q)-1] = q Finally, we create our simultaneous source as a judiVector : # Source wavelet q = judiVector(src_geometry, wavelet)","title":"Simultaneous sources"},{"location":"tutorials/#working-with-wavefields","text":"JUDI allows computing full time domain wavefields and using them as right-hand sides for wave equations solves. This tutorial shows how. We start by setting up a basic 2D experiment: using JUDI # Grid n = (120, 100) # (x,z) d = (10., 10.) o = (0., 0.) # Velocity [km/s] v = ones(Float32, n) .* 1.4f0 v[:, 50:end] .= 5f0 # Squared slowness m = (1f0 ./ v).^2 # Model structure: model = Model(n, d, o, m) Next, we set up the source geometry for a single source experiment: # Set up source geometry nsrc = 1 # no. of sources xsrc = convertToCell([600f0]) ysrc = convertToCell([0f0]) zsrc = convertToCell([20f0]) # Modeling time and sampling interval time = 600f0 # ms dt = 4f0 # ms # Set up source structure src_geometry = Geometry(xsrc, ysrc, zsrc; dt=dt, t=time) # Source wavelet f0 = 0.01f0 # kHz wavelet = ricker_wavelet(time, dt, f0) q = judiVector(src_geometry, wavelet) As in the 2D quick start tutorial, we create our info structure, modeling operator and source projection operator: # Set up info structure for linear operators ntComp = get_computational_nt(src_geometry, model) info = Info(prod(n), nsrc, ntComp) # Setup operators A_inv = judiModeling(info, model) Ps = judiProjection(info, src_geometry) To model a wavefield, we simply omit the receiver sampling operator: u = A_inv*Ps'*q This return an abstract data vector called judiWavefield . Similar to judiVectors , we can access the data for each source number i via u.data[i] . The data is a 3D array of size (nt, nx, nz) for 2D and a 4D array of size (nt, nx, ny, nz) for 3D. We can plot the wavefield of the 600th time step with: using PyPlot imshow(u.data[1][600, :, :]', vmin=-5, vmax=5, cmap=\"seismic\", aspect=\"auto\") We can also use the computed wavefield u as a right-hand side for forward and adjoint wave equation solves: v = A_inv*u w = A_inv'*u Similarly, by setting up a receiver projection operator, we can use wavefields as right-hand sides, but restrict the output to the receiver locations.","title":"Working with wavefields"},{"location":"tutorials/#extended-source-modeling","text":"JUDI supports extened source modeling, which injects a 1D wavelet q at every point in the subsurface weighted by a spatially varying extended source. To demonstrate extended source modeling, we first set up a runnable 2D experiment with JUDI. We start with defining the model: using JUDI # Grid n = (120, 100) # (x,z) d = (10., 10.) o = (0., 0.) # Velocity [km/s] v = ones(Float32, n) .* 1.4f0 v[:, 50:end] .= 5f0 # Squared slowness m = (1f0 ./ v).^2 # Model structure: model = Model(n, d, o, m) Next, we set up the receiver geometry: # Number of experiments nsrc = 2 # Set up receiver geometry nxrec = 120 xrec = range(50f0, stop=1150f0, length=nxrec) yrec = 0f0 zrec = range(50f0, stop=50f0, length=nxrec) # Modeling time and receiver sampling interval time = 2000 dt = 4 # Set up receiver structure rec_geometry = Geometry(xrec, yrec, zrec; dt=dt, t=time, nsrc=nsrc) For the extended source, we do not need to set up a source geometry object, but we need to define a wavelet function: # Source wavelet f0 = 0.01f0 # MHz wavelet = ricker_wavelet(time, dt, f0) As before, we set up an info structure, as well as a modeling operator and a receiver sampling operator: # Set up info structure for linear operators ntComp = get_computational_nt(rec_geometry, model) info = Info(prod(n), nsrc, ntComp) # Setup operators A_inv = judiModeling(info, model) Pr = judiProjection(info, rec_geometry) We define our extended source as a so called judiWeights vector. Similar to a judiVector , the data of this abstract vector is stored as a cell array, where each cell corresponds to one source experiment. We create a cell array of length two and create a random array of the size of the model as our extended source: weights = Array{Array}(undef, nsrc) for j=1:nsrc weights[j] = randn(Float32, model.n) end w = judiWeights(weights) To inject the extended source into the model and weight it by the wavelet, we create a special projection operator called judiLRWF (for JUDI low-rank wavefield). This operator needs to know the wavelet we defined earlier. We can then create our full modeling operator, by combining Pw with A_inv and the receiver sampling operator: # Create operator for injecting the weights, multiplied by the provided wavelet(s) Pw = judiLRWF(info, wavelet) # Model observed data w/ extended source F = Pr*A_inv*adjoint(Pw) Extended source modeling supports both forward and adjoint modeling: # Simultaneous observed data d_sim = F*w dw = adjoint(F)*d_sim As for regular modeling, we can create a Jacobian for linearized modeling and migration. First we define a migration velocity model and the corresponding modeling operator A0_inv : # Migration velocity and squared slowness v0 = ones(Float32, n) .* 1.4f0 m0 = (1f0 ./ v0).^2 # Model structure and modeling operator for migration velocity model0 = Model(n, d, o, m0) A0_inv = judiModeling(info, model0) # Jacobian and RTM J = judiJacobian(Pr*A0_inv*adjoint(Pw), w) rtm = adjoint(J)*d_sim As before, we can plot the image after reshaping it into its original dimensions: rtm = reshape(rtm, model.n) imshow(rtm', cmap=\"gray\", vmin=-3e6, vmax=3e6) Please also refer to the reproducable example on github for 2D and 3D extended modeling.","title":"Extended source modeling"},{"location":"tutorials/#impedance-imaging-inverse-scattering","text":"JUDI supports imaging (RTM) and demigration (linearized modeling) using the linearized inverse scattering imaging condition (ISIC) and its corresponding adjoint. ISIC can be enabled via the Options class. You can set this options when you initially create the modeling operator: # Options strucuture opt = Options(isic=true) # Set up modeling operator A0_inv = judiModeling(info, model0; options=opt) When you create a Jacobian from a forward modeling operator, the Jacobian inherits the options from A0_inv : J = judiJacobian(Pr*A0_inv*Ps', q) J.options.isic # -> true Alternatively, you can directly set the option in your Jacobian: J.options.isic = true # enable isic J.options.isic = false # disable isic","title":"Impedance imaging (inverse scattering)"},{"location":"tutorials/#optimal-checkpointing","text":"JUDI supports optimal checkpointing via Devito's interface to the Revolve library. To enable checkpointing, use the Options class: # Options strucuture opt = Options(optimal_checkpointing=true) # Set up modeling operator A0_inv = judiModeling(info, model0; options=opt) When you create a Jacobian from a forward modeling operator, the Jacobian inherits the options from A0_inv : J = judiJacobian(Pr*A0_inv*Ps', q) J.options.optimal_checkpointing # -> true Alternatively, you can directly set the option in your Jacobian: J.options.optimal_checkpointing = true # enable checkpointing J.options.optimal_checkpointing = false # disable checkpointing","title":"Optimal checkpointing"},{"location":"tutorials/#on-the-fly-fourier-transforms","text":"JUDI supports seismic imaging in the frequency domain using on-the-fly discrete Fourier transforms (DFTs). To compute an RTM image in the frequency domain for a given set of frequencies, we first create a cell array for the frequencies of each source experiment: nsrc = 4 # assume 4 source experiments frequencies = Array{Any}(undef, nsrc) Now we can define single or multiple frequencies for each shot location for which the RTM image will be computed: # For every source location, compute RTM image for 10 and 20 Hz for j=1:nsrc frequencies[j] = [0.001, 0.002] end The frequencies are passed to the Jacobian via the options field. Assuming we already have a Jacobian set up, we set the frequencies via: J.options.frequencies = frequencies Instead of the same two frequencies for each source experiment, we could have chosen different random sets of frequencies, which creates an RTM with incoherent noise. We can also draw random frequencies using the frequency spectrum of the true source as the probability density function. To create a distribution for a given source q ( judiVector ) from which we can draw frequency samples, use: q_dist = generate_distribution(q) Then we can assigne a random set of frequencies in a specified range as follows: nfreq = 10 # no. of frequencies per source location for j=1:nsrc J.options.frequencies[j] = select_frequencies(q_dist; fmin=0.003, fmax=0.04, nf=nfreq) end Once the options.frequencies field is set, on-the-fly DFTs are used for both born modeling and RTM. To save computational cost, we can limit the number of DFTs that are performed. Rather than computing the DFT at every time step, we can define a subsampling factor as follows: # Compute DFT every 4 time steps J.options.dft_subsampling_factor=4","title":"On-the-fly Fourier transforms"},{"location":"tutorials/fwi_example_NLopt/","text":"FWI with Quasi-Newton methods from the NLopt library In this notebook, we demonstrate how to interface the NLopt optimization library for full-waveform inversion with a limited-memory Quasi-Newton (L-BFGS) algorithm. Once again, we start by adding additional workers for parallel computing and by loading all necessary modules: using Distributed; addprocs(2) @everywhere using SegyIO, HDF5, PyPlot, JUDI, NLopt, Random, LinearAlgebra, Printf We load the FWI starting model from the HDF5 model file and set up the JUDI model structure: m0, n, d, o = read(h5open(\"overthrust_model.h5\",\"r\"),\"m0\",\"n\",\"d\",\"o\"); title(\"Starting model\") model0 = Model((n[1],n[2]), (d[1],d[2]), (o[1],o[2]), m0); imshow(sqrt.(1f0./m0)', cmap=\"GnBu\", extent=(0,10,3,0)); xlabel(\"Lateral position [km]\"); ylabel(\"Depth [km]\"); Then we read the SEG-Y file containing our test data set. The data was generated with a 2D excerpt from the Overthrust velocity model and consists of 31 shot records with 2 seconds recording time. We load the data and set up a JUDI seismic data vector: block = segy_read(\"overthrust_shot_records.segy\"); d_obs = judiVector(block); \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=7076688, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /Users/mathiaslouboutin/.julia/packages/SegyIO/uw4ZW/src/read/read_file.jl:26 extent = [0, 10, 2, 0] figure(figsize=(7, 7)) subplot(221) imshow(d_obs.data[1], vmin=-1, vmax=1, cmap=\"PuOr\", extent=extent, aspect=4, interpolation=\"hamming\") xlabel(\"Receiver position(km)\") ylabel(\"Time(s)\") subplot(222) imshow(d_obs.data[6], vmin=-1, vmax=1, cmap=\"PuOr\", extent=extent, aspect=4, interpolation=\"hamming\") xlabel(\"Receiver position(km)\") ylabel(\"Time(s)\") subplot(223) imshow(d_obs.data[11], vmin=-1, vmax=1, cmap=\"PuOr\", extent=extent, aspect=4, interpolation=\"hamming\") xlabel(\"Receiver position(km)\") ylabel(\"Time(s)\") subplot(224) imshow(d_obs.data[16], vmin=-1, vmax=1, cmap=\"PuOr\", extent=extent, aspect=4, interpolation=\"hamming\") xlabel(\"Receiver position(km)\") ylabel(\"Time(s)\") tight_layout() Since the SEG-Y file contains the source coordinates, but not the wavelet itself, we create a JUDI Geometry structure for the source and then manually set up an 8 Hz Ricker wavelet. As for the observed data, we set up a JUDI seismic data vector q with the source geometry and wavelet: src_geometry = Geometry(block; key=\"source\"); src_data = ricker_wavelet(src_geometry.t[1], src_geometry.dt[1], 0.008f0); q = judiVector(src_geometry, src_data); Optimization Rather than implementing the L-BFGS algorithms in Julia ourselves, we interface the NLopt optimization library. This library requires objective functions with the current variable and gradient as input arguments and the function value as the only output argument. For this reason, we build a wrapper that is customized for the NLopt library around our fwi_objective function. The function f! takes a vectorized estimate of the current model as well as the (vectorized) gradient as input arguments. NLopt uses double precision for floating point variables, so the first step inside f! is to reshape and convert the model to single precision. Then we choose a randomized subset of sources and shot records and compute the function value fval and gradient of the FWI objective function. We then set the gradient in the water layer to zero and overwrite the input gradient grad with the new gradient. Furthermore, we keep track of the number of function evaluations through increasing the count variable, which will serve as the termination criterion for the algorithm. In Julia, we set up f! in the following way: batchsize = 8; count = 0; # NLopt objective function function f!(x, grad) global count if count == 0 @printf(\"%10s %15s %15s\\n\",\"Iteration\",\"Function Val\",\"norm(g)\") end # Update model model0.m = Float32.(reshape(x,model0.n)) # Seclect batch and calculate gradient i = randperm(d_obs.nsrc)[1:batchsize] fval, gradient = fwi_objective(model0, q[i], d_obs[i]) # Reset gradient in water column to zero gradient = reshape(gradient, model0.n) gradient[:,1:21] .= 0f0 grad[1:end] = vec(gradient) global count; count += 1 @printf(\"%10d %15.5e %15.5e\\n\",count, fval, norm(g)) return convert(Float64, fval) end UndefVarError: @printf not defined g = zeros(prod(model0.n)) f0 = f!(vec(model0.m), g) # Reset count global count = 0; 1 255339.66398837214 262117.01773563828 255339.66398837214 imshow(reshape(g, model0.n)', vmin=-1e3, vmax=1e3, extent=(0,10,3,0), cmap=\"jet\") title(\"FWI first gradient\") xlabel(\"Lateral position [km]\"); ylabel(\"Depth [km]\"); As in our gradient descent and Gauss-Newton example, we define bound constraints for the squared slowness to prevent velocities from becoming negative or too large: # Set up bound constrains v0 = sqrt.(1f0./model0.m) vmin = ones(Float32, model0.n) .* 1.3f0; vmax = ones(Float32, model0.n) .* 6.5f0; # Convert to squared slowness mmin = vec((1f0 ./ vmax).^2); mmax = vec((1f0 ./ vmin).^2); The NLopt library offers a range of different optimization algorithms, from which we choose the L-BFGS method. We create an optimization object called opt by specifying the algorithm we want to use and the dimenions of the unknown model vector. We then set the upper and lower bounds of the variable, define f! as the objective function and set the termination criterion to be a maximum of 15 function evaluations: opt = Opt(:LD_LBFGS, prod(model0.n)) lower_bounds!(opt, mmin) upper_bounds!(opt, mmax) min_objective!(opt, f!) maxeval!(opt, 15) Remark: Subsampling the number of sources should in practice never be used for second order methods such as L-BFGS. Specialized stochastic second order methods exist, but differ from standard Quasi-Newton methods. We only use source subsampling to reduce the computational cost of our example. Having set up the objective function, bound constraints and termination criterion, we can now run the inversion: This example requires ~200 MB of memory per gradient, i.e. 800 MB with four parallel workers. It runs for approximately 15 minutes. (minf, minx, ret) = optimize(opt, vec(model0.m)); 2 257901.94477162338 258980.10388516955 3 172803.59079827153 302780.85054677405 4 189130.6172962864 318396.30082959705 5 206791.76877585545 375180.5596427598 6 214141.76860964662 406769.76629408816 7 364202.2299721926 359639.79808253766 8 144399.94956911763 208320.48800925835 9 115243.88926892391 196391.16164069102 10 83024.91172473418 233775.52396071967 11 79410.95713778166 217893.00687219884 12 67300.58613575318 210013.1922979365 13 51630.938175045296 108049.05286704176 14 46403.458416860216 117827.36750250543 15 43086.70610388414 94403.35456695667 16 35267.624712575205 96966.99249506553 We plot the final velocity model after 15 function evaluations: imshow(sqrt.(1f0./reshape(minx, model0.n))', cmap=\"GnBu\", extent=(0,10,3,0), vmin=1.5, vmax=5.4); title(\"FWI with L-BFGS\") xlabel(\"Lateral position [km]\"); ylabel(\"Depth [km]\");","title":"fwi example NLopt"},{"location":"tutorials/fwi_example_NLopt/#fwi-with-quasi-newton-methods-from-the-nlopt-library","text":"In this notebook, we demonstrate how to interface the NLopt optimization library for full-waveform inversion with a limited-memory Quasi-Newton (L-BFGS) algorithm. Once again, we start by adding additional workers for parallel computing and by loading all necessary modules: using Distributed; addprocs(2) @everywhere using SegyIO, HDF5, PyPlot, JUDI, NLopt, Random, LinearAlgebra, Printf We load the FWI starting model from the HDF5 model file and set up the JUDI model structure: m0, n, d, o = read(h5open(\"overthrust_model.h5\",\"r\"),\"m0\",\"n\",\"d\",\"o\"); title(\"Starting model\") model0 = Model((n[1],n[2]), (d[1],d[2]), (o[1],o[2]), m0); imshow(sqrt.(1f0./m0)', cmap=\"GnBu\", extent=(0,10,3,0)); xlabel(\"Lateral position [km]\"); ylabel(\"Depth [km]\"); Then we read the SEG-Y file containing our test data set. The data was generated with a 2D excerpt from the Overthrust velocity model and consists of 31 shot records with 2 seconds recording time. We load the data and set up a JUDI seismic data vector: block = segy_read(\"overthrust_shot_records.segy\"); d_obs = judiVector(block); \u250c Warning: Fixed length trace flag set in stream: IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=7076688, maxsize=Inf, ptr=3601, mark=-1) \u2514 @ SegyIO /Users/mathiaslouboutin/.julia/packages/SegyIO/uw4ZW/src/read/read_file.jl:26 extent = [0, 10, 2, 0] figure(figsize=(7, 7)) subplot(221) imshow(d_obs.data[1], vmin=-1, vmax=1, cmap=\"PuOr\", extent=extent, aspect=4, interpolation=\"hamming\") xlabel(\"Receiver position(km)\") ylabel(\"Time(s)\") subplot(222) imshow(d_obs.data[6], vmin=-1, vmax=1, cmap=\"PuOr\", extent=extent, aspect=4, interpolation=\"hamming\") xlabel(\"Receiver position(km)\") ylabel(\"Time(s)\") subplot(223) imshow(d_obs.data[11], vmin=-1, vmax=1, cmap=\"PuOr\", extent=extent, aspect=4, interpolation=\"hamming\") xlabel(\"Receiver position(km)\") ylabel(\"Time(s)\") subplot(224) imshow(d_obs.data[16], vmin=-1, vmax=1, cmap=\"PuOr\", extent=extent, aspect=4, interpolation=\"hamming\") xlabel(\"Receiver position(km)\") ylabel(\"Time(s)\") tight_layout() Since the SEG-Y file contains the source coordinates, but not the wavelet itself, we create a JUDI Geometry structure for the source and then manually set up an 8 Hz Ricker wavelet. As for the observed data, we set up a JUDI seismic data vector q with the source geometry and wavelet: src_geometry = Geometry(block; key=\"source\"); src_data = ricker_wavelet(src_geometry.t[1], src_geometry.dt[1], 0.008f0); q = judiVector(src_geometry, src_data);","title":"FWI with Quasi-Newton methods from the NLopt library"},{"location":"tutorials/fwi_example_NLopt/#optimization","text":"Rather than implementing the L-BFGS algorithms in Julia ourselves, we interface the NLopt optimization library. This library requires objective functions with the current variable and gradient as input arguments and the function value as the only output argument. For this reason, we build a wrapper that is customized for the NLopt library around our fwi_objective function. The function f! takes a vectorized estimate of the current model as well as the (vectorized) gradient as input arguments. NLopt uses double precision for floating point variables, so the first step inside f! is to reshape and convert the model to single precision. Then we choose a randomized subset of sources and shot records and compute the function value fval and gradient of the FWI objective function. We then set the gradient in the water layer to zero and overwrite the input gradient grad with the new gradient. Furthermore, we keep track of the number of function evaluations through increasing the count variable, which will serve as the termination criterion for the algorithm. In Julia, we set up f! in the following way: batchsize = 8; count = 0; # NLopt objective function function f!(x, grad) global count if count == 0 @printf(\"%10s %15s %15s\\n\",\"Iteration\",\"Function Val\",\"norm(g)\") end # Update model model0.m = Float32.(reshape(x,model0.n)) # Seclect batch and calculate gradient i = randperm(d_obs.nsrc)[1:batchsize] fval, gradient = fwi_objective(model0, q[i], d_obs[i]) # Reset gradient in water column to zero gradient = reshape(gradient, model0.n) gradient[:,1:21] .= 0f0 grad[1:end] = vec(gradient) global count; count += 1 @printf(\"%10d %15.5e %15.5e\\n\",count, fval, norm(g)) return convert(Float64, fval) end UndefVarError: @printf not defined g = zeros(prod(model0.n)) f0 = f!(vec(model0.m), g) # Reset count global count = 0; 1 255339.66398837214 262117.01773563828 255339.66398837214 imshow(reshape(g, model0.n)', vmin=-1e3, vmax=1e3, extent=(0,10,3,0), cmap=\"jet\") title(\"FWI first gradient\") xlabel(\"Lateral position [km]\"); ylabel(\"Depth [km]\"); As in our gradient descent and Gauss-Newton example, we define bound constraints for the squared slowness to prevent velocities from becoming negative or too large: # Set up bound constrains v0 = sqrt.(1f0./model0.m) vmin = ones(Float32, model0.n) .* 1.3f0; vmax = ones(Float32, model0.n) .* 6.5f0; # Convert to squared slowness mmin = vec((1f0 ./ vmax).^2); mmax = vec((1f0 ./ vmin).^2); The NLopt library offers a range of different optimization algorithms, from which we choose the L-BFGS method. We create an optimization object called opt by specifying the algorithm we want to use and the dimenions of the unknown model vector. We then set the upper and lower bounds of the variable, define f! as the objective function and set the termination criterion to be a maximum of 15 function evaluations: opt = Opt(:LD_LBFGS, prod(model0.n)) lower_bounds!(opt, mmin) upper_bounds!(opt, mmax) min_objective!(opt, f!) maxeval!(opt, 15) Remark: Subsampling the number of sources should in practice never be used for second order methods such as L-BFGS. Specialized stochastic second order methods exist, but differ from standard Quasi-Newton methods. We only use source subsampling to reduce the computational cost of our example. Having set up the objective function, bound constraints and termination criterion, we can now run the inversion: This example requires ~200 MB of memory per gradient, i.e. 800 MB with four parallel workers. It runs for approximately 15 minutes. (minf, minx, ret) = optimize(opt, vec(model0.m)); 2 257901.94477162338 258980.10388516955 3 172803.59079827153 302780.85054677405 4 189130.6172962864 318396.30082959705 5 206791.76877585545 375180.5596427598 6 214141.76860964662 406769.76629408816 7 364202.2299721926 359639.79808253766 8 144399.94956911763 208320.48800925835 9 115243.88926892391 196391.16164069102 10 83024.91172473418 233775.52396071967 11 79410.95713778166 217893.00687219884 12 67300.58613575318 210013.1922979365 13 51630.938175045296 108049.05286704176 14 46403.458416860216 117827.36750250543 15 43086.70610388414 94403.35456695667 16 35267.624712575205 96966.99249506553 We plot the final velocity model after 15 function evaluations: imshow(sqrt.(1f0./reshape(minx, model0.n))', cmap=\"GnBu\", extent=(0,10,3,0), vmin=1.5, vmax=5.4); title(\"FWI with L-BFGS\") xlabel(\"Lateral position [km]\"); ylabel(\"Depth [km]\");","title":"Optimization"},{"location":"tutorials/judi_leading_edge_tutorial/","text":"Geophysics tutorial Full-Waveform Inversion - Part 3: optimization Philipp Witte 1 *, Mathias Louboutin 1 , Keegan Lensink 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: pwitte.slim@gmail.com Introduction This tutorial is the third part of a full-waveform inversion (FWI) tutorial series with a step-by-step walkthrough of setting up forward and adjoint wave equations and building a basic FWI inversion framework. For discretizing and solving wave equations, we use Devito , a Python-based domain-specific language for automated generation of finite-difference code (Lange et al., 2016). The first two parts of this tutorial (Louboutin et al., 2017, 2018) demonstrated how to solve the acoustic wave equation for modeling seismic shot records and how to compute the gradient of the FWI objective function using the adjoint-state method. With these two key ingredients, we will now build an inversion framework that can be used to minimize the FWI least-squares objective function. FWI is a computationally and mathematically challenging problem. The computational complexity comes from the fact that an already expensive solution procedure for the wave equation needs to be repeated for a large number of source positions for each iteration of the optimization algorithm. The mathematical complexity comes from the fact that the FWI objective is known to have many local minima due to cycle skipping. NOT FOR MANUSCRIPT Furthermore, since the solution is not unique it is generally not possible to unambiguously recover the parameterization of the subsurface from the given data alone, making FWI an active field of research (e.g. Leeuwen et al., 2013; Warner and Guasch, 2014; Peters and Herrmann, 2017). This tutorial demonstrates how we can set up a basic FWI framework with two alternative gradient-based optimization algorithms: stochastic gradient descent, and the Gauss\u2013Newton method (Nocedal and Wright, 2009). We implement our inversion framework with the Julia Devito Inversion framework (JUDI), a parallel software package for seismic modeling and inversion in the Julia programming language. JUDI provides abstractions and function wrappers that allow the implementation of wave-equation-based inversion problems such as FWI using code that closely follows the mathematical notation, while using Devito\u2019s automatic code generation for solving the underlying wave equations. All the code to run the algorithms and generate the figures in this paper can be found at http://github.com/SEG. Optimizing the FWI objective function The goal of this tutorial series is to optimize the FWI objective function with the $\\ell_2$-misfit: $$ \\mathop{\\hbox{minimize}} {\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum {i=1}^{n_s} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, $$ where $\\mathbf{d}^\\mathrm{pred}_i$ and $\\mathbf{d}^\\mathrm{obs}_i$ are the predicted and observed seismic shot records of the $i^{\\text{th}}$ source location and $\\mathbf{m}$ is the velocity model (expressed as squared slowness). In part one, we demonstrated how to implement a forward modeling operator to generate the predicted shot records, which we will denote as $\\mathbf{d}^\\mathrm{pred}_i = \\mathbf{F}(\\mathbf{m},\\mathbf{q}_i)$. In the second tutorial, we then showed how we can compute the gradient $\\nabla f(\\mathbf{m})$ of the objective function and update our initial model using gradient descent. There is a snag, however. This first-order optimization algorithm has a linear convergence rate at best, and typically requires many iterations to converge. Second-order optimization methods converge considerably faster. To implement them, we first approximate the objective with a second-order Taylor expansion: $$ f(\\mathbf{m}) = f(\\mathbf{m}_0) + \\nabla f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\delta \\mathbf{m}^\\top \\nabla^2 f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\mathcal{O}(\\delta \\mathbf{m}^3), $$ where $\\mathcal{O}(\\delta \\mathbf{m}^3)$ represents the error term, $\\nabla f(\\mathbf{m}_0)$ is the gradient as implemented in part two, and $\\nabla^2 f(\\mathbf{m}_0)$ is the Hessian of the objective function, which we will refer to as $\\mathbf{H}$. Rather than using the negative gradient to incrementally update our model, as in gradient descent, we directly calculate a model update $\\delta \\mathbf{m}$ that leads us to the minimum. This is called Newton's method: $$ \\delta \\mathbf{m} = - \\mathbf{H}(\\mathbf{m}_0)^{-1} \\nabla f(\\mathbf{m}_0). $$ Although the method converges to the minimum of the FWI objective function quickly, it comes at the cost of having to compute and invert the Hessian matrix (Nocedal and Wright, 2009). Fortunately, for least squares problems, such as FWI, the Hessian can be approximated by the Gauss-Newton (GN) Hessian $\\mathbf{J}^\\top \\mathbf{J}$, where $\\mathbf{J}$ is the Jacobian matrix. This is the partial derivative of the forward modeling operator $\\mathbf{F}(\\mathbf{m},\\mathbf{q})$ with respect to $\\mathbf{m}$ \u2014 something we can easily compute. Furthermore, the Jacobian can also be used to express the gradient of the FWI objective function as $\\nabla f(\\mathbf{m} 0) = \\mathbf{J}^\\top (\\mathbf{d}^\\mathrm{pred}_i - \\mathbf{d}_i^\\mathrm{obs})$, where $\\mathbf{J}^\\top$ is the adjoint (transposed) Jacobian. This is useful, because we now have a set of operators $\\mathbf{F}, \\mathbf{J}$ and $\\mathbf{H} {GN}=\\mathbf{J}^\\top\\mathbf{J}$, through which we can express both first and second order optimization algorithms for FWI. Although forming these matrices explicitly is not possible, since they can become extremely large, we only need the action of these operators on vectors. This allows us to implement these operators matrix-free. In the following section we will demonstrate how to set up these operators in our JUDI software framework and to how to use them to implement FWI algorithms. NOT FOR MANUSCRIPT [SegyIO]:https://github.com/slimgroup/SegyIO.jl The Julia Devito Inversion framework is a parallel matrix-free linear operator library for seismic modeling and inversion based on Devito and [SeisIO], a performant Julia package for reading and writing large data volumes in SEG-Y format. JUDI allows implementing seismic inversion algorithms as linear algebra operations, enabling rapid translations of FWI algorithms to executable Julia code. The underlying wave equations are set up and solved using Devito, as described in the first two tutorials, and are interfaced from Julia using the [PyCall](https://github.com/JuliaPy/PyCall.jl) package (Johnson, 2017). For reading and writing SEG-Y data, JUDI uses the SeisIO package, a sophisticated SEG-Y reader that allows us to scan large 3D data sets for creating look-up tables with header summaries. However, since our data set is relatively small, we will directly load the full file into memory. The `segy_read` command takes the file name as an input and returns a dense data block. This is our observed data and we store it as a JUDI vector. # NOT FOR MANUSCRIPT # using Distributed # addprocs(4); using JUDI.TimeModeling, JUDI.SLIM_optim, SegyIO, Random, Statistics Implementing FWI in JUDI We start our demonstration by reading our data set, which consists of 16 shot records and was generated with an excerpt from the SEG/EAGE Overthrust model (Aminzadeh et al. 1997). We store it as a judiVector : block = segy_read(\"overthrust_shot_records.segy\") d_obs = judiVector(block); using PyPlot i = 8 figure(figsize=(15,6)) imshow(d_obs.data[i], cmap=\"seismic\", extent=[0,size(d_obs.data[i],2),2,0], aspect=\"auto\", vmin=-3, vmax=3) xlabel(\"Receiver number\", size=12) ylabel(\"Time [s]\", size=12) text(3, 0.13, \"Shot record $i\", size=16) show() Figure 1 : Observed shot record number 8. JUDI vectors such as d_obs can be used like a regular Julia vectors, so we can compute norms via norm(d_obs) or the inner product via dot(d_obs, d_obs) , but they contain the shot records in their original dimension. Shot records can be accessed via their respective shot number with d_obs.data[shot_no] , while the header information can be accessed with d_obs.geometry . We extract the source geometry from our SEG-Y file and then manually set up a source vector q with an 8 Hz Ricker wavelet: f = 0.008 # kHz src_geom = Geometry(block; key=\"source\") src_data = ricker_wavelet(src_geom.t[1], src_geom.dt[1], f) q = judiVector(src_geom, src_data); plot(q.data[1]) show() NOT FOR MANUSCRIPT Since our data set consists of $16$ shot records, both `d_obs` and `q` contain the data and geometries for all source positions. We can check the number of source positions with `d_obs.nsrc` and `q.nsrc` and we can extract the part of the vector that corresponds to one or multiple shots with `d_obs[shot_no], q[shot_no]`. We will now set up the forward modeling operator $\\mathbf{F}(\\mathbf{m},\\mathbf{q})$ as a matrix-free operator for the inverse wave equation $\\mathbf{A}(\\mathbf{m})^{-1}$, where $\\mathbf{m}$ is the current model, and source/receiver injection and sampling operators $\\mathbf{P} \\mathrm{s}$ and $\\mathbf{P} \\mathrm{r}$. Since the dimensions of the inverse wave equation operator depend on the number of computational time steps, we calculate this number using the get_computational_nt function and set up an info object that contains some dimensionality information required by all operators. Then we can define Pr and Ps as matrix-free operators implementing Devito sparse point injection and interpolation (Louboutin et al., 2017). Multiplications with Ps and Pr represent sampling the wavefield at source/receiver locations, while their adjoints Ps', Pr' denote injecting either source wavelets or shot records into the computational grid. These projection and modelling operators can then be set up in Julia in the following way: using HDF5 m0, n, d, o = read(h5open(\"overthrust_model.h5\",\"r\"),\"m0\",\"n\",\"d\",\"o\") model0 = Model((n[1],n[2]), (d[1],d[2]), (o[1],o[2]), m0); ntComp = get_computational_nt(q.geometry, d_obs.geometry, model0) info = Info(prod(model0.n), d_obs.nsrc, ntComp) Pr = judiProjection(info, d_obs.geometry) Ps = judiProjection(info, q.geometry) Ainv = judiModeling(info, model0); The forward modeling step can be expressed mathematically as $$ F(\\mathbf{m};\\mathbf{q})=\\mathbf{P}_r\\mathbf{A}^{-1}(\\mathbf{m})\\mathbf{P}_s^\\top\\mathbf{q} $$ which is expressed in Julia as d_pred = Pr * Ainv * Ps' * q This forward models all 16 predicted shot records in parallel. Notice that, in instantiating Ainv , we made the wave equation solver implicitly dependent on model0 . Finally, we set up the matrix-free Jacobian operator J and the Gauss\u2013Newton Hessian J' * J . As mentioned in the introduction, J is the partial derivative of the forward modeling operator $\\mathbf{F}(\\mathbf{m}, \\mathbf{q})$ with respect to the model m and is therefore directly constructed from our modeling operator Pr * Ainv * Ps' and a specified source vector q : J = judiJacobian(Pr * Ainv * Ps', q); NOT FOR MANUSCRIPT Note that, if we started our Julia session with multiple CPU cores or nodes (`julia -p n`, with `n` being the number of workers), the wave equation solves are automatically parallelized over source locations and all shots are collected in the `d_pred` vector. We can also model a single or subset of shots by indexing the operators with the respective shot numbers. E.g. if we want to model the first two shots, we define `i=[1,2]` and then run `d_sub = Pr[i]*Ainv[i]*Ps[i]'*q[i]`. The FWI gradient would then be given by: `g = J[i]' * (d_pred - d_obs[i])` If we want to solve an adjoint wave equation with the observed data as the adjoint source and restrictions of the wavefields back to the source locations, we can simply run `qad = Ps * Ainv' * Pr' * d_obs`, exemplifying the advantages of casting FWI in a proper computational linear algebra framework. Once we have `J` we can also form the Gauss\u2013Newton Hessian: `H_GN = J' * J` In the context of seismic inversion, the Jacobian is also called the linearized modeling or demigration operator and its adjoint J' is the migration operator. One drawback of this notation is that the forward wavefields for the gradient calculation have to be recomputed, since the forward modeling operator only returns the shot records and not the complete wavefields. For this reason, JUDI has an additional function for computing the gradients of the FWI objective function f,g = fwi_objective(model0,q[i],d_obs[i]) , which takes the current model, source and data vectors as an input and computes the objective value and gradient in parallel without having to recompute the forward wavefields. FWI via gradient descent With expressions for modeling operators, Jacobians and gradients of the FWI objective, we can now implement different FWI algorithms in a few lines of code. We will start with a basic gradient descent example with a line search. To reduce the computational cost of full gradient descent, we will use a stochastic approach in which we only compute the gradient and function value for a randomized subset of source locations. In JUDI, this is accomplished by choosing a random vector of integers between 1 and 16 and indexing the data vectors as described earlier. Furthermore, we will apply a projection operator proj(x) , which prevent velocities (or squared slownesses) becoming negative or too large by clipping values outside the allowed range. A few extra variables are defined in the notebook, but the full algorithm for FWI with stochastic gradient descent and box constraints is implemented as follows: # Set up bound constraints. v0 = sqrt.(1f0./model0.m) vmin = ones(Float32, model0.n) .* 1.3f0 vmax = ones(Float32, model0.n) .* 6.5f0 # Fix water column. vmin[:,1:21] = v0[:,1:21] vmax[:,1:21] = v0[:,1:21] # Convert to squared slowness. mmin = vec((1f0./vmax).^2) mmax = vec((1f0./vmin).^2); maxiter = 10 batchsize = 8 # Number of shots for each iteration. proj(x) = reshape(median([vec(mmin) vec(x) vec(mmax)], dims=2), model0.n) fhistory_SGD = zeros(Float32, maxiter); for j=1:maxiter # FWI objective function value and gradient. i = randperm(d_obs.nsrc)[1:batchsize] fval, grad = fwi_objective(model0, q[i], d_obs[i]) fhistory_SGD[j] = fval # Line search and update model. update = backtracking_linesearch(model0, q[i], d_obs[i], fval, grad, proj; alpha=1f0) model0.m += reshape(update, model0.n) # Apply box constraints. model0.m = proj(model0.m) end model_SGD = copy(model0.m); JUDI's backtracking_linesearch function performs an approximate line search and returns a model update that leads to a decrease of the objective function value (Armijo condition; Nocedal and Wright, 2009). The result after 10 iterations of SGD with box constraints is shown in Figure 2. In practice, where starting models are typically less accurate than in our example, FWI is often performed from low to high frequencies, since the objective function has less local minima for lower frequencies (Bunks et al., 1995). In this multi-scale FWI approach, a low-pass filtered version of the data is used to invert for a low resolution velocity model first and higher frequencies are added in subsequent iterations. FWI via the Gauss\u2013Newton method As discussed earlier, the convergence rate of GD depends on the objective function, but requires many FWI iterations necessary to reach an acceptable solution. Using our matrix-free operator for the Jacobian J, we can modify the above code to implement the Gauss\u2013Newton method (Equation 3) to improve the convergence rate. In practice, directly inverting the Gauss\u2013Newton Hessian J'* J should be avoided, because the matrix is badly conditioned and takes many iterations to invert. Instead, we perform a few iterations of a least-squares solver, lsqr() , to approximately solve J * p = d_pred - d_obs and obtain the update direction p . lsqr , from the Julia IterativeSolvers package, is a conjugate-gradient type algorithm for solving least squares problems and is mathematically equivalent to inverting J' * J , but has better numerical properties (Paige and Saunders, 1982). We implement the Gauss-Newton method as follows: model0.m = m0 # Reset velocity model. fhistory_GN = zeros(Float32,maxiter); using IterativeSolvers # Return data as Julia array Ainv.options.return_array = true d_vec = convert_to_array(d_obs) for j=1:maxiter # Model predicted data. d_pred = Pr * Ainv * Ps' * q # GN update direction. p = lsqr(J, d_pred - d_obs; maxiter=6) fhistory_GN[j] = .5f0 * norm(d_pred - d_vec)^2 # OMIT LINE FROM MANUSCRIPT # update model and box constraints. model0.m = model0.m - reshape(p, model0.n) end NOT FOR MANUSCRIPT An important benefit of matrix-free operators is that we do not need to implement our own least-squares solver, but can pass `J` and the data residual `d_pred - d_obs` to a third-party optimization library. The operator `J` does not need to be an explicit matrix, since `lsqr` only uses matrix-vector products. In contrast to our SGD algorithm, we use all shot records in every iteration, since stochastic methods for second order algorithms are less well understood, making this approach considerably more expensive than our previous algorithm. However, as shown in figures 2 and 3, it achieves a superior result, with a considerably lower misfit compared to the known model. Furthermore, figure 3 shows that it achieves the improved result in relatively few iterations. figure(figsize=(15, 12)) subplot(311) imshow(sqrt.(1f0./m0)', cmap=\"GnBu\", extent=(0,10,3,0), vmin=1.5, vmax=5.4) text(0.15, 0.3, \"Starting model\", size=14, color=\"black\") ylabel(\"Depth [km]\", size=12) colorbar() text(10.35, 1.5, \"Velocity [km/s]\", va=\"center\", size=12, rotation=90) subplot(312) imshow(sqrt.(1f0./model_SGD)', cmap=\"GnBu\", extent=(0,10,3,0), vmin=1.5, vmax=5.4) misfit = round(fhistory_SGD[end]) text(0.15, 0.3, \"Gradient descent, misfit = $misfit\", size=14, color=\"black\") ylabel(\"Depth [km]\", size=12) colorbar() text(10.35, 1.5, \"Velocity [km/s]\", va=\"center\", size=12, rotation=90) subplot(313) imshow(sqrt.(1f0./model0.m)', cmap=\"GnBu\", extent=(0,10,3,0), vmin=1.5, vmax=5.4) misfit = round(fhistory_GN[end]) text(0.15, 0.3, \"Gauss\u2013Newton, misfit = $misfit\", size=14, color=\"black\") xlabel(\"Lateral position [km]\", size=12) ylabel(\"Depth [km]\", size=12) colorbar() text(10.35, 1.5, \"Velocity [km/s]\", va=\"center\", size=12, rotation=90) show() fhistory_SGD = fhistory_SGD/norm(fhistory_SGD, Inf) fhistory_GN = fhistory_GN/norm(fhistory_GN, Inf); figure(figsize=(8,3)) plot(1:10, fhistory_SGD, label=\"Gradient descent\") plot(1:10, fhistory_GN, label=\"Gauss\u2013Newton\") text(9.8, 0.28, \"Gradient descent\", ha=\"right\", color=\"steelblue\") text(9.8, 0.09, \"Gauss\u2013Newton\", ha=\"right\", color=\"chocolate\") xlabel(\"Iteration number\", size=12) ylabel(\"Misfit\", size=12) xlim(1, 10) show() Figure 3 : Normalized function values for the FWI inversion example with stochastic gradient descent and the Gauss-Newton method. An alternative to (Gauss\u2013)Newton methods are quasi-Newton methods, which build up an approximation of the Hessian from previous gradients only and require no additional PDE solves or matrix inversions. Implementing an efficient and correct version of this method, such as the L-BFGS algorithm, exceeds a few lines of code and we therefore leave this exercise to the reader. Instead of implementing more complicated algorithms by hand, it is also possible to interface third-party Julia optimization libraries and an example for this is given in the notebook fwi_example_NLopt.ipynb . Even though all examples shown here are two-dimensional, in order to make them reproducible on a laptop or desktop PC, JUDI can be used for 3D modeling and inversion without having to change the code, since the number of dimensions are automatically inferred from the velocity model and data dimensions. Conclusions In this final part of our FWI tutorial series, we demonstrated how to set up basic optimization algorithms for waveform inversion using JUDI. The methods shown here are all gradient based and differ in the way how update directions for the velocity model are computed. Our numerical examples can serve for the reader as a basis for developing more advanced FWI workflows, which usually include additional data preprocessing, frequency continuation techniques or further model constraints. Acknowledgments This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre. References Aminzadeh, F., Brac, J., and Kunz, T., 1997. 3D Salt and Overthrust models. SEG/EAGE Modeling Series, No. 1: Distribution CD of Salt and Overthrust models, SEG Book Series Tulsa, Oklahoma. Bezanson, J., Karpinski, S., Shah, V. B., and Edelman, A., 2012, Julia: A fast dynamic language for technical computing: CoRR. Retrieved from http://arxiv.org/abs/1209.5145 Bunks, C., Saleck, F. M., Zaleski, S., and Chavent, G., 1995, Multiscale seismic waveform inversion: GEOPHYSICS, 60, 1457\u20131473. doi:10.1190/1.1443880 Johnson, S., 2017, Calling python functions from the julia language: GitHub repository. https://github.com/JuliaPy/PyCall.jl; GitHub. Lange, M., Kukreja, N., Louboutin, M., Luporini, F., Zacarias, F. V., Pandolfo, V., \u2026 Gorman, G., 2016, Devito: Towards a generic finite difference DSL using symbolic python: 6th workshop on python for high-performance and scientific computing. doi:10.1109/PyHPC.2016.9 Leeuwen, T. van, Aravkin, A. Y., Calandra, H., and Herrmann, F. J., 2013, In which domain should we measure the misfit for robust full waveform inversion? EAGE annual conference proceedings. doi:10.3997/2214-4609.20130839 Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2017, Full-waveform inversion - part 1: Forward modeling: Retrieved from https://www.slim.eos.ubc.ca/Publications/Private/Submitted/2017/louboutin2017fwi/louboutin2017fwi.html Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2018, Full-waveform inversion - part 2: Adjoint modeling: Nocedal, J., and Wright, S., 2009, Numerical optimization: (2nd ed.). Springer. Paige, C. C., and Saunders, M. A., 1982, LSQR: An algorithm for sparse linear equations and sparse least squares: ACM Trans. Math. Softw., 8, 43\u201371. doi:10.1145/355984.355989 Peters, B., and Herrmann, F. J., 2017, Constraints versus penalties for edge-preserving full-waveform inversion: The Leading Edge, 36, 94\u2013100. doi:10.1190/tle36010094.1 Warner, M., and Guasch, L., 2014, Adaptive waveform inversion: Theory: In SEG technical program expanded abstracts 2014 (pp. 1089\u20131093). doi:10.1190/segam2014-0371.1","title":"Judi leading edge tutorial"},{"location":"tutorials/judi_leading_edge_tutorial/#geophysics-tutorial","text":"","title":"Geophysics tutorial"},{"location":"tutorials/judi_leading_edge_tutorial/#full-waveform-inversion-part-3-optimization","text":"Philipp Witte 1 *, Mathias Louboutin 1 , Keegan Lensink 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: pwitte.slim@gmail.com","title":"Full-Waveform Inversion - Part 3: optimization"},{"location":"tutorials/judi_leading_edge_tutorial/#introduction","text":"This tutorial is the third part of a full-waveform inversion (FWI) tutorial series with a step-by-step walkthrough of setting up forward and adjoint wave equations and building a basic FWI inversion framework. For discretizing and solving wave equations, we use Devito , a Python-based domain-specific language for automated generation of finite-difference code (Lange et al., 2016). The first two parts of this tutorial (Louboutin et al., 2017, 2018) demonstrated how to solve the acoustic wave equation for modeling seismic shot records and how to compute the gradient of the FWI objective function using the adjoint-state method. With these two key ingredients, we will now build an inversion framework that can be used to minimize the FWI least-squares objective function. FWI is a computationally and mathematically challenging problem. The computational complexity comes from the fact that an already expensive solution procedure for the wave equation needs to be repeated for a large number of source positions for each iteration of the optimization algorithm. The mathematical complexity comes from the fact that the FWI objective is known to have many local minima due to cycle skipping.","title":"Introduction"},{"location":"tutorials/judi_leading_edge_tutorial/#optimizing-the-fwi-objective-function","text":"The goal of this tutorial series is to optimize the FWI objective function with the $\\ell_2$-misfit: $$ \\mathop{\\hbox{minimize}} {\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum {i=1}^{n_s} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, $$ where $\\mathbf{d}^\\mathrm{pred}_i$ and $\\mathbf{d}^\\mathrm{obs}_i$ are the predicted and observed seismic shot records of the $i^{\\text{th}}$ source location and $\\mathbf{m}$ is the velocity model (expressed as squared slowness). In part one, we demonstrated how to implement a forward modeling operator to generate the predicted shot records, which we will denote as $\\mathbf{d}^\\mathrm{pred}_i = \\mathbf{F}(\\mathbf{m},\\mathbf{q}_i)$. In the second tutorial, we then showed how we can compute the gradient $\\nabla f(\\mathbf{m})$ of the objective function and update our initial model using gradient descent. There is a snag, however. This first-order optimization algorithm has a linear convergence rate at best, and typically requires many iterations to converge. Second-order optimization methods converge considerably faster. To implement them, we first approximate the objective with a second-order Taylor expansion: $$ f(\\mathbf{m}) = f(\\mathbf{m}_0) + \\nabla f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\delta \\mathbf{m}^\\top \\nabla^2 f(\\mathbf{m}_0) \\delta \\mathbf{m} + \\mathcal{O}(\\delta \\mathbf{m}^3), $$ where $\\mathcal{O}(\\delta \\mathbf{m}^3)$ represents the error term, $\\nabla f(\\mathbf{m}_0)$ is the gradient as implemented in part two, and $\\nabla^2 f(\\mathbf{m}_0)$ is the Hessian of the objective function, which we will refer to as $\\mathbf{H}$. Rather than using the negative gradient to incrementally update our model, as in gradient descent, we directly calculate a model update $\\delta \\mathbf{m}$ that leads us to the minimum. This is called Newton's method: $$ \\delta \\mathbf{m} = - \\mathbf{H}(\\mathbf{m}_0)^{-1} \\nabla f(\\mathbf{m}_0). $$ Although the method converges to the minimum of the FWI objective function quickly, it comes at the cost of having to compute and invert the Hessian matrix (Nocedal and Wright, 2009). Fortunately, for least squares problems, such as FWI, the Hessian can be approximated by the Gauss-Newton (GN) Hessian $\\mathbf{J}^\\top \\mathbf{J}$, where $\\mathbf{J}$ is the Jacobian matrix. This is the partial derivative of the forward modeling operator $\\mathbf{F}(\\mathbf{m},\\mathbf{q})$ with respect to $\\mathbf{m}$ \u2014 something we can easily compute. Furthermore, the Jacobian can also be used to express the gradient of the FWI objective function as $\\nabla f(\\mathbf{m} 0) = \\mathbf{J}^\\top (\\mathbf{d}^\\mathrm{pred}_i - \\mathbf{d}_i^\\mathrm{obs})$, where $\\mathbf{J}^\\top$ is the adjoint (transposed) Jacobian. This is useful, because we now have a set of operators $\\mathbf{F}, \\mathbf{J}$ and $\\mathbf{H} {GN}=\\mathbf{J}^\\top\\mathbf{J}$, through which we can express both first and second order optimization algorithms for FWI. Although forming these matrices explicitly is not possible, since they can become extremely large, we only need the action of these operators on vectors. This allows us to implement these operators matrix-free. In the following section we will demonstrate how to set up these operators in our JUDI software framework and to how to use them to implement FWI algorithms.","title":"Optimizing the FWI objective function"},{"location":"tutorials/judi_leading_edge_tutorial/#implementing-fwi-in-judi","text":"We start our demonstration by reading our data set, which consists of 16 shot records and was generated with an excerpt from the SEG/EAGE Overthrust model (Aminzadeh et al. 1997). We store it as a judiVector : block = segy_read(\"overthrust_shot_records.segy\") d_obs = judiVector(block); using PyPlot i = 8 figure(figsize=(15,6)) imshow(d_obs.data[i], cmap=\"seismic\", extent=[0,size(d_obs.data[i],2),2,0], aspect=\"auto\", vmin=-3, vmax=3) xlabel(\"Receiver number\", size=12) ylabel(\"Time [s]\", size=12) text(3, 0.13, \"Shot record $i\", size=16) show() Figure 1 : Observed shot record number 8. JUDI vectors such as d_obs can be used like a regular Julia vectors, so we can compute norms via norm(d_obs) or the inner product via dot(d_obs, d_obs) , but they contain the shot records in their original dimension. Shot records can be accessed via their respective shot number with d_obs.data[shot_no] , while the header information can be accessed with d_obs.geometry . We extract the source geometry from our SEG-Y file and then manually set up a source vector q with an 8 Hz Ricker wavelet: f = 0.008 # kHz src_geom = Geometry(block; key=\"source\") src_data = ricker_wavelet(src_geom.t[1], src_geom.dt[1], f) q = judiVector(src_geom, src_data); plot(q.data[1]) show()","title":"Implementing FWI in JUDI"},{"location":"tutorials/judi_leading_edge_tutorial/#fwi-via-gradient-descent","text":"With expressions for modeling operators, Jacobians and gradients of the FWI objective, we can now implement different FWI algorithms in a few lines of code. We will start with a basic gradient descent example with a line search. To reduce the computational cost of full gradient descent, we will use a stochastic approach in which we only compute the gradient and function value for a randomized subset of source locations. In JUDI, this is accomplished by choosing a random vector of integers between 1 and 16 and indexing the data vectors as described earlier. Furthermore, we will apply a projection operator proj(x) , which prevent velocities (or squared slownesses) becoming negative or too large by clipping values outside the allowed range. A few extra variables are defined in the notebook, but the full algorithm for FWI with stochastic gradient descent and box constraints is implemented as follows: # Set up bound constraints. v0 = sqrt.(1f0./model0.m) vmin = ones(Float32, model0.n) .* 1.3f0 vmax = ones(Float32, model0.n) .* 6.5f0 # Fix water column. vmin[:,1:21] = v0[:,1:21] vmax[:,1:21] = v0[:,1:21] # Convert to squared slowness. mmin = vec((1f0./vmax).^2) mmax = vec((1f0./vmin).^2); maxiter = 10 batchsize = 8 # Number of shots for each iteration. proj(x) = reshape(median([vec(mmin) vec(x) vec(mmax)], dims=2), model0.n) fhistory_SGD = zeros(Float32, maxiter); for j=1:maxiter # FWI objective function value and gradient. i = randperm(d_obs.nsrc)[1:batchsize] fval, grad = fwi_objective(model0, q[i], d_obs[i]) fhistory_SGD[j] = fval # Line search and update model. update = backtracking_linesearch(model0, q[i], d_obs[i], fval, grad, proj; alpha=1f0) model0.m += reshape(update, model0.n) # Apply box constraints. model0.m = proj(model0.m) end model_SGD = copy(model0.m); JUDI's backtracking_linesearch function performs an approximate line search and returns a model update that leads to a decrease of the objective function value (Armijo condition; Nocedal and Wright, 2009). The result after 10 iterations of SGD with box constraints is shown in Figure 2. In practice, where starting models are typically less accurate than in our example, FWI is often performed from low to high frequencies, since the objective function has less local minima for lower frequencies (Bunks et al., 1995). In this multi-scale FWI approach, a low-pass filtered version of the data is used to invert for a low resolution velocity model first and higher frequencies are added in subsequent iterations.","title":"FWI via gradient descent"},{"location":"tutorials/judi_leading_edge_tutorial/#fwi-via-the-gaussnewton-method","text":"As discussed earlier, the convergence rate of GD depends on the objective function, but requires many FWI iterations necessary to reach an acceptable solution. Using our matrix-free operator for the Jacobian J, we can modify the above code to implement the Gauss\u2013Newton method (Equation 3) to improve the convergence rate. In practice, directly inverting the Gauss\u2013Newton Hessian J'* J should be avoided, because the matrix is badly conditioned and takes many iterations to invert. Instead, we perform a few iterations of a least-squares solver, lsqr() , to approximately solve J * p = d_pred - d_obs and obtain the update direction p . lsqr , from the Julia IterativeSolvers package, is a conjugate-gradient type algorithm for solving least squares problems and is mathematically equivalent to inverting J' * J , but has better numerical properties (Paige and Saunders, 1982). We implement the Gauss-Newton method as follows: model0.m = m0 # Reset velocity model. fhistory_GN = zeros(Float32,maxiter); using IterativeSolvers # Return data as Julia array Ainv.options.return_array = true d_vec = convert_to_array(d_obs) for j=1:maxiter # Model predicted data. d_pred = Pr * Ainv * Ps' * q # GN update direction. p = lsqr(J, d_pred - d_obs; maxiter=6) fhistory_GN[j] = .5f0 * norm(d_pred - d_vec)^2 # OMIT LINE FROM MANUSCRIPT # update model and box constraints. model0.m = model0.m - reshape(p, model0.n) end","title":"FWI via the Gauss\u2013Newton method"},{"location":"tutorials/judi_leading_edge_tutorial/#conclusions","text":"In this final part of our FWI tutorial series, we demonstrated how to set up basic optimization algorithms for waveform inversion using JUDI. The methods shown here are all gradient based and differ in the way how update directions for the velocity model are computed. Our numerical examples can serve for the reader as a basis for developing more advanced FWI workflows, which usually include additional data preprocessing, frequency continuation techniques or further model constraints.","title":"Conclusions"},{"location":"tutorials/judi_leading_edge_tutorial/#acknowledgments","text":"This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre.","title":"Acknowledgments"},{"location":"tutorials/judi_leading_edge_tutorial/#references","text":"Aminzadeh, F., Brac, J., and Kunz, T., 1997. 3D Salt and Overthrust models. SEG/EAGE Modeling Series, No. 1: Distribution CD of Salt and Overthrust models, SEG Book Series Tulsa, Oklahoma. Bezanson, J., Karpinski, S., Shah, V. B., and Edelman, A., 2012, Julia: A fast dynamic language for technical computing: CoRR. Retrieved from http://arxiv.org/abs/1209.5145 Bunks, C., Saleck, F. M., Zaleski, S., and Chavent, G., 1995, Multiscale seismic waveform inversion: GEOPHYSICS, 60, 1457\u20131473. doi:10.1190/1.1443880 Johnson, S., 2017, Calling python functions from the julia language: GitHub repository. https://github.com/JuliaPy/PyCall.jl; GitHub. Lange, M., Kukreja, N., Louboutin, M., Luporini, F., Zacarias, F. V., Pandolfo, V., \u2026 Gorman, G., 2016, Devito: Towards a generic finite difference DSL using symbolic python: 6th workshop on python for high-performance and scientific computing. doi:10.1109/PyHPC.2016.9 Leeuwen, T. van, Aravkin, A. Y., Calandra, H., and Herrmann, F. J., 2013, In which domain should we measure the misfit for robust full waveform inversion? EAGE annual conference proceedings. doi:10.3997/2214-4609.20130839 Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2017, Full-waveform inversion - part 1: Forward modeling: Retrieved from https://www.slim.eos.ubc.ca/Publications/Private/Submitted/2017/louboutin2017fwi/louboutin2017fwi.html Louboutin, M., Witte, P. A., Lange, M., Kukreja, N., Luporini, F., Gorman, G., and Herrmann, F. J., 2018, Full-waveform inversion - part 2: Adjoint modeling: Nocedal, J., and Wright, S., 2009, Numerical optimization: (2nd ed.). Springer. Paige, C. C., and Saunders, M. A., 1982, LSQR: An algorithm for sparse linear equations and sparse least squares: ACM Trans. Math. Softw., 8, 43\u201371. doi:10.1145/355984.355989 Peters, B., and Herrmann, F. J., 2017, Constraints versus penalties for edge-preserving full-waveform inversion: The Leading Edge, 36, 94\u2013100. doi:10.1190/tle36010094.1 Warner, M., and Guasch, L., 2014, Adaptive waveform inversion: Theory: In SEG technical program expanded abstracts 2014 (pp. 1089\u20131093). doi:10.1190/segam2014-0371.1","title":"References"}]}